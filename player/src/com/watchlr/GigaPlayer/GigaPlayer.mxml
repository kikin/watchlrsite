<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
			   xmlns:s="library://ns.adobe.com/flex/spark" 
			   xmlns:mx="library://ns.adobe.com/flex/mx"
			   xmlns:watchlr="com.watchlr.*"
			   creationComplete="init()" xmlns:GigaPlayer="com.watchlr.GigaPlayer.*" xmlns:Components="com.watchlr.GigaPlayer.Components.*">
	<fx:Style source="assets/GigaPlayer.css"/>
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	<fx:Script>
		<![CDATA[
			import com.watchlr.Globals;
			
			import flash.external.*;
			import flash.utils.Timer;
			
			import mx.core.UIComponent;
			import mx.events.FlexEvent;
			import mx.events.ResizeEvent;
			
			import org.osmf.events.LoadEvent;
			import org.osmf.events.MediaPlayerStateChangeEvent;
			import org.osmf.events.TimeEvent;
			
			import spark.effects.Fade;
			
			
		
			//point beyond seek target that we would like to buffer
			//video before we start playback (a percentage)
			protected var SEEK_BUFFER_PADDING:Number = 20;
			
			//duration of mouse inactivity after which UI
			//chrome fades out
			protected var UI_CHROME_TIMEOUT:Number = 4000;
		
			//we'll need to fetch this from the api whenever the embed's
			//source is modified
			[bindable]
			protected var _seekTarget:Number = 0;
		
			protected var UIChromeFadeoutTimer:Timer;
			
			public function set seekTarget(value:Number):void{
				_seekTarget = value;
				ExternalInterface.call(Globals.JS_SIGNATURES.SEEK_START);
			}
		
			protected function init():void{
				transportControls.gigaPlayer = this;
				positionPrevNextButtons();
				UIChromeFadeoutTimer = new Timer(UI_CHROME_TIMEOUT);
				
				addEventListener(Event.RESIZE, this.onResize);
				addEventListener(MouseEvent.MOUSE_MOVE, onMouseMove);
				UIChromeFadeoutTimer.addEventListener(TimerEvent.TIMER, UIChromeFadeout);
			}
			
			public function onStateChange(event:MediaPlayerStateChangeEvent):void{
				switch(event.state){
					case "ready":
						handleVideoReady();
						break;
					case "paused":
						handleVideoPaused();
						break;
				}
			}
		
			protected function onBytesLoadedChange(event:LoadEvent):void{
				if(!_videoDisplay.playing){
					var bytesLoaded:Number = event.bytes;
					var totalBytes:Number = event.target.bytesTotal;
					if(totalBytes > 0){
						var percent:Number = Math.floor(100 * (bytesLoaded/
																totalBytes));
						if (percent + SEEK_BUFFER_PADDING > 100){
							if(_seekTarget && 100*(duration/_seekTarget) > percent){
								_videoDisplay.seek(_seekTarget);
								ExternalInterface.call(Globals.JS_SIGNATURES.SEEK_END);
								_videoDisplay.play();
							}
						}
						else if(_seekTarget && 100*(duration/_seekTarget) > (percent + SEEK_BUFFER_PADDING)){
							_videoDisplay.seek(_seekTarget);
							ExternalInterface.call(Globals.JS_SIGNATURES.SEEK_END);
							_videoDisplay.play();
						}
					}
				}
				bytesLoadedJSCallbackWrapper(event);
			}
		
			protected function handleVideoReady():void{
				_videoDisplay.pause();
				ExternalInterface.call(Globals.JS_SIGNATURES.ON_PLAYER_READY);
			}
		
			//here you go, ExternalInterface!
			public function setSeekTarget(value:Number):void{
				seekTarget = value;
			}
		
			public function getDuration():Number{
				return _videoDisplay.duration;
			}
		
			public function getCurrentTime():Number{
				return _videoDisplay.currentTime;
			}
		
			protected function onComplete(event:TimeEvent):void{
				ExternalInterface.call(Globals.JS_SIGNATURES.ON_ENDED);
			}
		
			protected function onCurrentTimeChange(event:TimeEvent):void{
				ExternalInterface.call(Globals.JS_SIGNATURES.ON_CURRENT_TIME_CHANGE, _videoDisplay.currentTime);
			}
		
			//so containing js code can know # bytes loaded....
			protected function bytesLoadedJSCallbackWrapper(event:LoadEvent):void{
				ExternalInterface.call(Globals.JS_SIGNATURES.LOAD_PROGRESS, event.bytes, event.target.bytesTotal); 
			}
		
			protected function handleVideoPaused():void{
				Globals.JS_SIGNATURES.ON_PAUSED;	
			}
			
			/*videoDisplay function wrappers*/
			
			protected function get duration():Number{
				return _videoDisplay.duration;
			}
			
			public function get source():Object{
				return _videoDisplay.source;
			}
			
			public function set source(val:Object):void{
				_videoDisplay.source = val;
			}
			
			public function get videoDisplay():VideoDisplay{
				return _videoDisplay;
			}
			
			public function seek(position:Number):void{
				_videoDisplay.seek(position);
			}
			
			public function play():void{
				_videoDisplay.play();
			}
			
			public function pause():void{
				_videoDisplay.pause();
			}
			
			public function get playing():Boolean{
				return _videoDisplay.playing;
			}
			
			/*ugly UI management logic...*/
			protected function onResize(resizeEvent:ResizeEvent):void{
				_videoDisplay.width = width;
				_videoDisplay.height = height;
				_videoDisplay.x = 0;
				_videoDisplay.y = 0;
				positionPrevNextButtons();
			}
			
			protected function positionPrevNextButtons():void{
				prevVideoButton.y = 0.5*height - 0.5*prevVideoButton.height;
				nextVideoButton.y = 0.5*height - 0.5*prevVideoButton.height;
				prevVideoButton.left = 20;
				nextVideoButton.right = 14;
			}
			
			protected function onVideoButtonRollover(event:MouseEvent):void{
				switch(event.target){
					case prevVideoButton:
						pbNoHoverImg.visible=false;
						pbHoverImg.visible=true;
						break;
					case nextVideoButton:
						nbNoHoverImg.visible = false;
						nbHoverImg.visible = true;
						break;
				}
			}
			
			protected function onVideoButtonRollout(event:MouseEvent):void{
				switch(event.target){
					case prevVideoButton:
						pbHoverImg.visible=false;
						pbNoHoverImg.visible=true;
						break;
					case nextVideoButton:
						nbHoverImg.visible=false;
						nbNoHoverImg.visible=true;
						break;
				}
			}
			
			protected function UIChromeFadeout(event:TimerEvent):void{
				prevVideoButton.visible = false;
				nextVideoButton.visible = false;
				transportControls.visible = false;
			}
			
			protected function UIChromeShow():void{
		//		prevVideoButton.visible = true;
		//		nextVideoButton.visible = true;
				transportControls.visible = true;
			}
			
			protected function onMouseMove(event:MouseEvent):void{
				UIChromeShow();
				UIChromeFadeoutTimer.reset();	
				UIChromeFadeoutTimer.start();
			}
		]]>
	</fx:Script>
	<s:Rect width="100%" height="100%">
		<s:fill><s:SolidColor color="#000000" /></s:fill>
	</s:Rect>
	<s:VideoDisplay id="_videoDisplay" x="0" y="0" width="100%" height="100%" 
					mediaPlayerStateChange="onStateChange(event)" 
					bytesLoadedChange="onBytesLoadedChange(event)" 
					complete="onComplete(event)" 
					currentTimeChange="onCurrentTimeChange(event)">
	</s:VideoDisplay>
	<s:Group id="prevVideoButton" x="10" y="100" width="50" height="50" left="20" 
			  rollOver="onVideoButtonRollover(event)" rollOut="onVideoButtonRollout(event)" visible="false">
		<mx:Image id="pbNoHoverImg" source="assets/left_arrow.png" x="0" y="0"></mx:Image>
		<mx:Image id="pbHoverImg" source="assets/left_arrow_glow.png" x="0" y="0" visible="false"></mx:Image>
	</s:Group>
	<s:Group id="nextVideoButton" x="10" y="100" width="50" height="50" right="20" 
			rollOver="onVideoButtonRollover(event)" rollOut="onVideoButtonRollout(event)" visible="false">
		<mx:Image id="nbNoHoverImg" source="assets/right_arrow.png" x="0" y="0"></mx:Image>
		<mx:Image id="nbHoverImg" source="assets/right_arrow_glow.png" x="0" y="0" visible="false"></mx:Image>
	</s:Group>
	<Components:Controls id="transportControls" width="100%" bottom="0">
	</Components:Controls>
</s:Group>
