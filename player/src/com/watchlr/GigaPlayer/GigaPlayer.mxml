<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:fx="http://ns.adobe.com/mxml/2009" 
			   xmlns:s="library://ns.adobe.com/flex/spark" 
			   xmlns:mx="library://ns.adobe.com/flex/mx"
			   xmlns:watchlr="com.watchlr.*"
			   creationComplete="init()" xmlns:GigaPlayer="com.watchlr.GigaPlayer.*" xmlns:Components="com.watchlr.GigaPlayer.Components.*">
	<fx:Style source="assets/GigaPlayer.css"/>
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	<fx:Script>
		<![CDATA[
			import at.matthew.httpstreaming.HTTPStreamingM3U8NetLoader;
			
			import com.watchlr.GigaPlayer.Event.GigaPlayerEvent;
			import com.watchlr.GigaPlayer.Event.StreamURLFetchEvent;
			import com.watchlr.GigaPlayer.Util.Util;
			import com.watchlr.Globals;
			
			import flash.external.*;
			import flash.system.Security;
			import flash.utils.Timer;
			import flash.utils.setTimeout;
			
			import flashx.textLayout.formats.Float;
			
			import mx.collections.ArrayList;
			import mx.core.FlexGlobals;
			import mx.core.UIComponent;
			import mx.events.FlexEvent;
			import mx.events.ResizeEvent;
			import mx.managers.CursorManager;
			
			import org.osmf.elements.VideoElement;
			import org.osmf.events.LoadEvent;
			import org.osmf.events.MediaPlayerStateChangeEvent;
			import org.osmf.events.TimeEvent;
			import org.osmf.net.httpstreaming.HTTPStreamingNetLoader;
			import org.osmf.media.URLResource;
			
			import spark.components.SkinnableContainer;
			import spark.components.supportClasses.SkinnableComponent;
			import spark.effects.Fade;
			
			public var SourceType:Object = { HTML5 : 0, VIMEO : 1, YOUTUBE : 2};
			
			protected var currentVidSourceType:int = SourceType.HTML5;
			protected var curVID:String;
		
			//point beyond seek target that we would like to buffer
			//video before we start playback (a percentage)
			protected var SEEK_BUFFER_PADDING:Number = 20;
			
			//duration of mouse inactivity after which UI
			//chrome fades out
			protected var UI_CHROME_TIMEOUT:Number = 4000;
		
			//we'll need to fetch this from the api whenever the embed's
			//source is modified
			[bindable]
			protected var _seekTarget:Number = 0;
		
			protected var UIChromeFadeoutTimer:Timer;
			
			private var _youTubeLoader:Loader;
			private var _youtubePlayer:Object;
			private var _youTubeLoaderWrapper:UIComponent;
			private var _youTubePlaybackPollTimer:Timer;
			private var _youTubePlayerLoaded:Boolean = false;
			private var _youTubePlayerLastBytesLoadedCount:Number = 0;
			private var YOUTUBE_PLAYBACK_POLL_INTERVAL:Number = 200;
			
			private var _stopCountdown:Boolean = false;
			
			protected var fillElementComponents:ArrayList = new ArrayList();
			
			public function set seekTarget(value:Number):void{
				_seekTarget = value;
				handleVideoSeekStart();
			}
		
			protected function init():void{
				trace('Gigaplayer init');
				controlPallette.gigaPlayer = this;
				positionPrevNextButtons();
				UIChromeFadeoutTimer = new Timer(UI_CHROME_TIMEOUT);
				
				addEventListener(Event.RESIZE, this.onResize);
				addEventListener(MouseEvent.MOUSE_MOVE, onMouseMove);
				UIChromeFadeoutTimer.addEventListener(TimerEvent.TIMER, UIChromeFadeout);
				
				// Initialize youtube player
				Security.allowDomain("www.youtube.com");
				_youTubeLoader = new Loader();
				_youTubeLoader.contentLoaderInfo.addEventListener(Event.INIT, onYouTubeLoaderInit);
				_youTubeLoader.load(new URLRequest("http://www.youtube.com/apiplayer?version=3"));
				
				_youTubeLoaderWrapper = new UIComponent();
				addElement(_youTubeLoaderWrapper);
				
				_youTubePlaybackPollTimer = new Timer(YOUTUBE_PLAYBACK_POLL_INTERVAL);
				_youTubePlaybackPollTimer.addEventListener(TimerEvent.TIMER, pollYouTubePlayer);
				
				fillElementComponents.addItem(_videoDisplay);
				fillElementComponents.addItem(_youTubeLoaderWrapper);
				fillElementComponents.addItem(bgRect);
				
				//set view stack order of elements:
				setChildIndex(bgRect, -1);
				setChildIndex(_videoDisplay, 0);
				setChildIndex(_youTubeLoaderWrapper, 1);
				setChildIndex(controlPallette, 2);
				setChildIndex(loadingIndicatorCountdown, 3);
				setChildIndex(loadingErrorMessage, 4);
				setChildIndex(viewSourceLink, 5);
				setChildIndex(loadingIndiccatorMessage, 6);
				
				//time change callback...
				_videoDisplay.addEventListener(TimeEvent.CURRENT_TIME_CHANGE, onPlayerTimeChange);
				
				//finally, load the video...
				source = FlexGlobals.topLevelApplication.parameters.src;
				
				handlePlayerLoad();	
			}
			
			public function onYouTubeLoaderInit(event:Event): void {
				_youTubePlayerLoaded = false;
				_youTubeLoaderWrapper.addChild(_youTubeLoader);
				
				_youTubeLoader.content.addEventListener("onReady", onYouTubePlayerLoaded);
				_youTubeLoader.content.addEventListener("onError", onYouTubePlayerError);
				_youTubeLoader.content.addEventListener("onStateChange", onYouTubePlayerStateChange);
				
				_youtubePlayer = _youTubeLoader.content;
				_youtubePlayer.addEventListener(MouseEvent.MOUSE_MOVE, onMouseMove);
			}
			
			public function onStateChange(event:MediaPlayerStateChangeEvent):void{
				trace("on state change: " + event.state);
				switch(event.state){
					case "ready": 
						break;
					case "playing":
						handleVideoReady();
						controlPallette.playButton.pauseButton.visible = true;
						controlPallette.playButton.playButton.visible = false;
						break;
					case "paused":
						handleVideoPaused();
						break;
					case "playbackError":
						handleVideoPlaybackError(150);
						break;
					case "buffering":
						break;
				}
			}
		
			protected function handleBytesLoadedChange(event:LoadEvent):void{
				if(!_videoDisplay.playing){
					var bytesLoaded:Number = event.bytes;
					var totalBytes:Number = event.target.bytesTotal;
					if(totalBytes > 0){
						var percent:Number = Math.floor(100 * (bytesLoaded/
																totalBytes));
						if (percent + SEEK_BUFFER_PADDING > 100){
							if(_seekTarget && 100*(_videoDisplay.duration/_seekTarget) > percent){
								_videoDisplay.seek(_seekTarget);
								handleVideoSeekEnd();
								_videoDisplay.play();
							}
						}
						else if(_seekTarget && 100*(_videoDisplay.duration/_seekTarget) > (percent + SEEK_BUFFER_PADDING)){
							_videoDisplay.seek(_seekTarget);
							handleVideoSeekEnd();
							_videoDisplay.play();
						}
						
						var gpEvent:GigaPlayerEvent = new GigaPlayerEvent(GigaPlayerEvent.BYTES_LOADED_CHANGE);
						gpEvent.bytesLoaded = bytesLoaded;
						gpEvent.bytesTotal = totalBytes;
						dispatchEvent(gpEvent);
					}
				}
				bytesLoadedJSCallbackWrapper(event);
			}
			
			protected function onBytesLoadedChange(event:GigaPlayerEvent):void{
				var gpEvent:GigaPlayerEvent = new GigaPlayerEvent(GigaPlayerEvent.BYTES_LOADED_CHANGE);
			}
		
			//here you go, ExternalInterface!
			public function setSeekTarget(value:Number):void{
				if (currentVidSourceType == SourceType.YOUTUBE) {
					// _youTubePlayer.seekTo(value);
				} else {
					seekTarget = value;	
				}
			}
		
			public function getDuration():Number{
				if (currentVidSourceType == SourceType.YOUTUBE) {
					if (_youtubePlayer)
						return _youtubePlayer.getDuration();
				} else {
					return _videoDisplay.duration;
				}
				
				return 0;
			}
		
			public function getCurrentTime():Number{
				if (currentVidSourceType == SourceType.YOUTUBE) {
					if (_youtubePlayer)
						return _youtubePlayer.getCurrentTime();
				} else {
					return _videoDisplay.currentTime;	
				}
				
				return 0;
			}
		
			protected function onComplete(event:TimeEvent):void{
				handleVideoFinished();
			}
		
			protected function onCurrentTimeChange(event:TimeEvent):void{
				handleVideoTimeChanged();
			}
			
			//so containing js code can know # bytes loaded....
			protected function bytesLoadedJSCallbackWrapper(event:LoadEvent):void{
				handleVideoLoadProgress(event.bytes, event.target.bytesTotal); 
			}
			
			/* Firing events to JS. */
			protected function handlePlayerLoad():void{
				ExternalInterface.call(Globals.JS_SIGNATURES.ON_LOAD);
			}
			
			protected function handleVideoReady():void{
				ExternalInterface.call(Globals.JS_SIGNATURES.ON_PLAYING);
			}
		
			protected function handleVideoPaused():void{
				ExternalInterface.call(Globals.JS_SIGNATURES.ON_PAUSED, getCurrentTime());	
			}
			
			protected function handleVideoFinished():void{
				ExternalInterface.call(Globals.JS_SIGNATURES.ON_FINISHED);	
			}
			
			protected function handleVideoTimeChanged():void{
				ExternalInterface.call(Globals.JS_SIGNATURES.ON_CURRENT_TIME_CHANGE, getCurrentTime());	
			}
			
			protected function handleVideoLoadProgress(bytes:Number, bytesTotal:Number):void{
				ExternalInterface.call(Globals.JS_SIGNATURES.LOAD_PROGRESS, bytes, bytesTotal);	
			}
			
			protected function handleVideoSeekStart():void{
				ExternalInterface.call(Globals.JS_SIGNATURES.SEEK_START);	
			}
			
			protected function handleVideoSeekEnd():void{
				ExternalInterface.call(Globals.JS_SIGNATURES.SEEK_END);	
			}
			
			protected function handleVideoPlaybackError(errorCode:Number):void{
				showCountdown();
				updateCountdownTimer(5, errorCode);
			}
			
			private function updateCountdownTimer(countDowntime:Number, errorCode:Number):void {
				if (!_stopCountdown) {
					if (countDowntime == 0) {
						hideCountdown();
						ExternalInterface.call(Globals.JS_SIGNATURES.PLAYBACK_ERROR, errorCode);
					} else {
						loadingIndicatorCountdown.text = countDowntime + '';
						setTimeout(updateCountdownTimer, 1000, --countDowntime, errorCode);
					}	
				}
			}
			
			private function showCountdown(): void {
				_stopCountdown = false;
				var loadingIndicatorCountdownTop:Number = (_videoDisplay.height - controlPallette.height) / 2;
				loadingIndicatorCountdown.top = loadingIndicatorCountdownTop;
				loadingErrorMessage.top = loadingIndicatorCountdownTop - 110;
				viewSourceLink.top = loadingIndicatorCountdownTop - 80;
				loadingIndiccatorMessage.top = loadingIndicatorCountdownTop - 30;
				
				loadingErrorMessage.visible = true;
				viewSourceLink.visible = true;
				loadingIndiccatorMessage.visible = true;
				loadingIndicatorCountdown.visible = true;
			}
			
			private function hideCountdown(): void {
				loadingErrorMessage.visible = false;
				viewSourceLink.visible = false;
				loadingIndiccatorMessage.visible = false;
				loadingIndicatorCountdown.visible = false;	
			}
			
			protected function onViewSourceLinkClicked(event:Event):void {
				_stopCountdown = true;
				var targetURL:URLRequest = new URLRequest(ExternalInterface.call(Globals.JS_SIGNATURES.GET_VIDEO_HOST_URL) as String);
				navigateToURL(targetURL, "_blank");
			}
			
			/*videoDisplay function wrappers*/
			
			public function get source():Object{
				return _videoDisplay.source;
			}
			
			public function set source(val:Object):void{
				var util:Util = new Util();
				var vid:String;
				if (val) {
					trace('Source:' + val.toString());
					hideCountdown();
					if(util.isYouTube(val.toString())){
						vid = util.YTIframeSourceToVID(val.toString());
						currentVidSourceType = SourceType.YOUTUBE;
						playYTVideo(vid);
					}else if (util.isVimeo(val.toString())){
						hideYTPlayer();
						vid = util.VimeoIframeSourceToVID(val.toString());
						util.removeEventListener(StreamURLFetchEvent.STREAM_FETCH, onStreamURLFetch);
						currentVidSourceType = SourceType.VIMEO;
						util.addEventListener(StreamURLFetchEvent.STREAM_FETCH, onStreamURLFetch);
						util.fetchVimeoStream(vid);
					}else{
						hideYTPlayer();
						currentVidSourceType = SourceType.HTML5;
						if (util.isM3U8(val.toString())) {
							trace('Playing m3u8 video');
							videoDisplay.source = new VideoElement(new URLResource(val.toString()), new HTTPStreamingM3U8NetLoader());
						} else {
							_videoDisplay.source = val;	
						}
					}
					curVID = vid;	
				}
			}
			
			public function get videoDisplay():VideoDisplay{
				return _videoDisplay;
			}
			
			public function seek(position:Number):void{
				if(currentVidSourceType == SourceType.YOUTUBE){
					if(_youtubePlayer){
						_youtubePlayer.seekTo(position);
					}
				}
				else{
					_videoDisplay.seek(position);
				}
			}
			
			public function play():void{
				if(currentVidSourceType == SourceType.YOUTUBE){
					if(_youtubePlayer)
						_youtubePlayer.playVideo();
				}
				else{
					_videoDisplay.play();
				}
			}
			
			public function pause():void{
				if(currentVidSourceType == SourceType.YOUTUBE){
					if(_youtubePlayer)
						_youtubePlayer.pauseVideo();
				}
				else
					_videoDisplay.pause();
			}
			
			public function get duration():Number{
				if(currentVidSourceType == SourceType.YOUTUBE){
					if(_youtubePlayer){
						return _youtubePlayer.getDuration();
					}else{
						return -1;
					}
				}else{
					return _videoDisplay.duration;
				}
			}
			
			public function get playing():Boolean{
				if(currentVidSourceType == SourceType.YOUTUBE){
					if(_youtubePlayer){
							return _youtubePlayer.getPlayerState() == '1';
					}
					return false;
				}	
				return _videoDisplay.playing;
			}
			
			public function curTime():Number{
				if(currentVidSourceType == SourceType.YOUTUBE){
					if(_youtubePlayer){
						return _youtubePlayer.getCurrentTime();
					}
					return -1;
				}else{
					return _videoDisplay.currentTime;
				}
			}
			
			/*ugly UI management logic...*/
			protected function onResize(resizeEvent:ResizeEvent):void{
				for(var i:int = 0; i < fillElementComponents.length; i++){
					var component:UIComponent = fillElementComponents.getItemAt(i) as UIComponent;
					fill100(component);
				}
				if (_youtubePlayer)
					_youtubePlayer.setSize(width, height);
				
				positionPrevNextButtons();
			}
			
			protected function fill100(component:UIComponent):void{
				if(component){
					component.width = width;
					component.height = height;
					component.x = 0;
					component.y = 0;
				}
			}
			
			protected function positionPrevNextButtons():void{
				prevVideoButton.y = 0.5*height - 0.5*prevVideoButton.height;
				nextVideoButton.y = 0.5*height - 0.5*prevVideoButton.height;
				prevVideoButton.left = 20;
				nextVideoButton.right = 14;
			}
			
			protected function onVideoButtonRollover(event:MouseEvent):void{
				switch(event.target){
					case prevVideoButton:
						pbNoHoverImg.visible=false;
						pbHoverImg.visible=true;
						break;
					case nextVideoButton:
						nbNoHoverImg.visible = false;
						nbHoverImg.visible = true;
						break;
				}
			}
			
			protected function onVideoButtonRollout(event:MouseEvent):void{
				switch(event.target){
					case prevVideoButton:
						pbHoverImg.visible=false;
						pbNoHoverImg.visible=true;
						break;
					case nextVideoButton:
						nbHoverImg.visible=false;
						nbNoHoverImg.visible=true;
						break;
				}
			}
			
			protected function UIChromeFadeout(event:TimerEvent):void{
				prevVideoButton.visible = false;
				nextVideoButton.visible = false;
				controlPallette.visible = false;
			}
			
			protected function UIChromeShow():void{
		//		prevVideoButton.visible = true;
		//		nextVideoButton.visible = true;
				controlPallette.visible = true;
			}
			
			protected function onMouseMove(event:MouseEvent):void{
				UIChromeShow();
				UIChromeFadeoutTimer.reset();	
				UIChromeFadeoutTimer.start();
			}
			
			protected function onStreamURLFetch(event:StreamURLFetchEvent):void{
				if(event.streamURL){
					videoDisplay.source = event.streamURL;
				}
			}
			
			protected function onYouTubePlayerLoaded(event:Event):void{
				trace('YT load: ' + curVID);
				if(_youtubePlayer){
					_youtubePlayer.setSize(width, height);
					_youTubePlayerLoaded = true;
					if (currentVidSourceType == SourceType.YOUTUBE) {
						playYTVideo(curVID);	
					}
				}
			}
			
			protected function onYouTubePlayerStateChange(event:Event):void{
				trace('state change: ' + Object(event).data);		
				switch (Object(event).data) {
					case -1: { // unstarted
						break;
					}
						
					case 0: { // ended
						handleVideoFinished();
						break;
					}
						
					case 1: { // playing
						handleVideoReady();
						_youTubePlaybackPollTimer.start();
						break;
					}
						
					case 2: { // paused
						handleVideoPaused();
						break;
					}
						
					case 3: { // buffering
						break;
					}
						
					case 5: { // video cueued 
						break;
					}
				}
			}
			
			protected function onYouTubePlayerError(event:Event): void {
				trace('On youtube error: ' + Object(event).data);
				handleVideoPlaybackError(Object(event).data);
			}
			
			protected function playYTVideo(vid:String):void {
				
				// stop playing existing video if the current source type is not youtube
				if (_youtubePlayer && currentVidSourceType != SourceType.YOUTUBE) {
					_videoDisplay.pause();
				}
				
				// show the youtube chromeless player and play the video.
				if (_youtubePlayer && _youTubePlayerLoaded) {
					showYTPlayer();
					trace("Playing youtube video with id: " + vid);
					_youtubePlayer.loadVideoById(vid);
					
					controlPallette.playButton.pauseButton.visible = true;
					controlPallette.playButton.playButton.visible = false;
					
					// UIChromeShow();
					UIChromeFadeoutTimer.reset();	
					UIChromeFadeoutTimer.start();
				}
			}
			
			protected function hideYTPlayer():void{
				// pause the video if any video is playing in youtube chromeless player
				if (_youtubePlayer && currentVidSourceType == SourceType.YOUTUBE) {
					_youtubePlayer.pauseVideo();
					_youTubePlaybackPollTimer.stop();		
				}
				
				// hide the youtube chromeless player
				_youTubeLoaderWrapper.visible = false;
				_youTubeLoader.visible = false;
				_videoDisplay.visible = true;
			}
			
			protected function showYTPlayer():void{
				_videoDisplay.visible = false;
				_youTubeLoaderWrapper.visible = true;
				_youTubeLoader.visible = true;
			}
			
			protected function onPlayerTimeChange(event:TimeEvent):void{
				var timeUpdatedEvent:GigaPlayerEvent = new GigaPlayerEvent(GigaPlayerEvent.TIME_UPDATED);
				timeUpdatedEvent.time = event.time;
				dispatchEvent(timeUpdatedEvent);
			}
			
			protected function pollYouTubePlayer(event:TimerEvent):void{
				if(_youtubePlayer){
					//dispatch a time updated event...
					var time:Number = _youtubePlayer.getCurrentTime();
					var timeUpdatedEvent:GigaPlayerEvent = new GigaPlayerEvent(GigaPlayerEvent.TIME_UPDATED);
					timeUpdatedEvent.time = time;
					dispatchEvent(timeUpdatedEvent); 
					
					//dispatch a bytes loaded event, if necessary...
					var bytesLoaded:Number = _youtubePlayer.getVideoBytesLoaded();
					var bytesTotal:Number = _youtubePlayer.getVideoBytesTotal();
					var bytesChangeEvent:GigaPlayerEvent = new GigaPlayerEvent(GigaPlayerEvent.BYTES_LOADED_CHANGE);
					bytesChangeEvent.bytesLoaded = bytesLoaded;
					bytesChangeEvent.bytesTotal = bytesTotal;
					dispatchEvent(bytesChangeEvent);
				}
			}
			
			public function playPause():void{
				controlPallette.playPause();
			}
		]]>
	</fx:Script>
	<s:Group width="100%" height="100%" id="bgRect">
		<s:Rect width="100%" height="100%">
			<s:fill><s:SolidColor color="#000000" /></s:fill>
		</s:Rect>
	</s:Group>
	<s:VideoDisplay id="_videoDisplay" x="0" y="0" width="100%" height="100%" 
					mediaPlayerStateChange="onStateChange(event)" 
					bytesLoadedChange="handleBytesLoadedChange(event)" 
					complete="onComplete(event)" 
					currentTimeChange="onCurrentTimeChange(event)">
	</s:VideoDisplay>
	<s:Group id="prevVideoButton" x="10" y="100" width="50" height="50" left="20" 
			  rollOver="onVideoButtonRollover(event)" rollOut="onVideoButtonRollout(event)" visible="false">
		<mx:Image id="pbNoHoverImg" source="assets/left_arrow.png" x="0" y="0"></mx:Image>
		<mx:Image id="pbHoverImg" source="assets/left_arrow_glow.png" x="0" y="0" visible="false"></mx:Image>
	</s:Group>
	<s:Group id="nextVideoButton" x="10" y="100" width="50" height="50" right="20" 
			rollOver="onVideoButtonRollover(event)" rollOut="onVideoButtonRollout(event)" visible="false">
		<mx:Image id="nbNoHoverImg" source="assets/right_arrow.png" x="0" y="0"></mx:Image>
		<mx:Image id="nbHoverImg" source="assets/right_arrow_glow.png" x="0" y="0" visible="false"></mx:Image>
	</s:Group>
	<mx:Label id="loadingErrorMessage" text="We could not play this video" fontSize="25" color="0xFFFFFF" visible="false" textAlign="center" width="100%"></mx:Label>
	<mx:Label id="viewSourceLink" selectable="true" link="onViewSourceLinkClicked(event);" fontSize="20" color="0xFFFFFF" visible="false" textAlign="center" width="100%" textDecoration="underline"
			  useHandCursor="true" buttonMode="true">
		<mx:htmlText>
			<![CDATA[<a href='event:http://www.youtube.com' target='_blank'>Watch here</a>]]>
		</mx:htmlText>
	</mx:Label>
	<mx:Label id="loadingIndiccatorMessage" text="Your next video will play in" fontSize="20" color="0xFFFFFF" visible="false" textAlign="center" width="100%"></mx:Label>
	<mx:Label id="loadingIndicatorCountdown" text="5" fontSize="50" color="0xFFFFFF" visible="false" textAlign="center" width="100%"></mx:Label>
	<Components:Controls id="controlPallette" width="100%" bottom="0" left="0">
	</Components:Controls>
</mx:Canvas>
