(function() {/*!
 * jQuery JavaScript Library v1.4.4
 * http://jquery.com/
 *
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2010, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Thu Nov 11 19:04:53 2010 -0500
 */
var jQuery = (function( window, undefined ) {

// Use the correct document accordingly with window argument (sandbox)
var document = window.document;
var jQuery = (function() {

// Define a local copy of jQuery
var jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context );
	},

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// A simple way to check for HTML strings or ID strings
	// (both of which we optimize for)
	quickExpr = /^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]+)$)/,

	// Is it a simple selector
	isSimple = /^.[^:#\[\.,]*$/,

	// Check if a string has a non-whitespace character in it
	rnotwhite = /\S/,
	rwhite = /\s/,

	// Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

	// Check for non-word characters
	rnonword = /\W/,

	// Check for digits
	rdigit = /\d/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

	// Useragent RegExp
	rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

	// Keep a UserAgent string for use with jQuery.browser
	userAgent = navigator.userAgent,

	// For matching the engine and version of the browser
	browserMatch,
	
	// Has the ready events already been bound?
	readyBound = false,
	
	// The functions to execute on DOM ready
	readyList = [],

	// The ready event handler
	DOMContentLoaded,

	// Save a reference to some core methods
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,
	
	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	init: function( selector, context ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), or $(undefined)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}
		
		// The body element only exists once, optimize finding it
		if ( selector === "body" && !context && document.body ) {
			this.context = document;
			this[0] = document.body;
			this.selector = "body";
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			// Are we dealing with HTML string or an ID?
			match = quickExpr.exec( selector );

			// Verify a match, and that no context was specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					doc = (context ? context.ownerDocument || context : document);

					// If a single string is passed in and it's a single tag
					// just do a createElement and skip the rest
					ret = rsingleTag.exec( selector );

					if ( ret ) {
						if ( jQuery.isPlainObject( context ) ) {
							selector = [ document.createElement( ret[1] ) ];
							jQuery.fn.attr.call( selector, context, true );

						} else {
							selector = [ doc.createElement( ret[1] ) ];
						}

					} else {
						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
						selector = (ret.cacheable ? ret.fragment.cloneNode(true) : ret.fragment).childNodes;
					}
					
					return jQuery.merge( this, selector );
					
				// HANDLE: $("#id")
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $("TAG")
			} else if ( !context && !rnonword.test( selector ) ) {
				this.selector = selector;
				this.context = document;
				selector = document.getElementsByTagName( selector );
				return jQuery.merge( this, selector );

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return (context || rootjQuery).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return jQuery( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if (selector.selector !== undefined) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.4.4",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return slice.call( this, 0 );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this.slice(num)[ 0 ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {
		// Build a new jQuery matched element set
		var ret = jQuery();

		if ( jQuery.isArray( elems ) ) {
			push.apply( ret, elems );
		
		} else {
			jQuery.merge( ret, elems );
		}

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + (this.selector ? " " : "") + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},
	
	ready: function( fn ) {
		// Attach the listeners
		jQuery.bindReady();

		// If the DOM is already ready
		if ( jQuery.isReady ) {
			// Execute the function immediately
			fn.call( document, jQuery );

		// Otherwise, remember the function for later
		} else if ( readyList ) {
			// Add the function to the wait list
			readyList.push( fn );
		}

		return this;
	},
	
	eq: function( i ) {
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, +i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ),
			"slice", slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},
	
	end: function() {
		return this.prevObject || jQuery(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	 var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		window.$ = _$;

		if ( deep ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},
	
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,
	
	// Handle when the DOM is ready
	ready: function( wait ) {
		// A third-party is pushing the ready event forwards
		if ( wait === true ) {
			jQuery.readyWait--;
		}

		// Make sure that the DOM is not already loaded
		if ( !jQuery.readyWait || (wait !== true && !jQuery.isReady) ) {
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
			if ( !document.body ) {
				return setTimeout( jQuery.ready, 1 );
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			if ( readyList ) {
				// Execute all of them
				var fn,
					i = 0,
					ready = readyList;

				// Reset the list of functions
				readyList = null;

				while ( (fn = ready[ i++ ]) ) {
					fn.call( document, jQuery );
				}

				// Trigger any bound ready events
				if ( jQuery.fn.trigger ) {
					jQuery( document ).trigger( "ready" ).unbind( "ready" );
				}
			}
		}
	},
	
	bindReady: function() {
		if ( readyBound ) {
			return;
		}

		readyBound = true;

		// Catch cases where $(document).ready() is called after the
		// browser event has already occurred.
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			return setTimeout( jQuery.ready, 1 );
		}

		// Mozilla, Opera and webkit nightlies currently support this event
		if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );
			
			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else if ( document.attachEvent ) {
			// ensure firing before onload,
			// maybe late but safe also for iframes
			document.attachEvent("onreadystatechange", DOMContentLoaded);
			
			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var toplevel = false;

			try {
				toplevel = window.frameElement == null;
			} catch(e) {}

			if ( document.documentElement.doScroll && toplevel ) {
				doScrollCheck();
			}
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	// A crude way of determining if an object is a window
	isWindow: function( obj ) {
		return obj && typeof obj === "object" && "setInterval" in obj;
	},

	isNaN: function( obj ) {
		return obj == null || !rdigit.test( obj ) || isNaN( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}
		
		// Not own constructor property must be Object
		if ( obj.constructor &&
			!hasOwn.call(obj, "constructor") &&
			!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
			return false;
		}
		
		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
	
		var key;
		for ( key in obj ) {}
		
		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		for ( var name in obj ) {
			return false;
		}
		return true;
	},
	
	error: function( msg ) {
		throw msg;
	},
	
	parseJSON: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );
		
		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test(data.replace(rvalidescape, "@")
			.replace(rvalidtokens, "]")
			.replace(rvalidbraces, "")) ) {

			// Try to use the native JSON parser first
			return window.JSON && window.JSON.parse ?
				window.JSON.parse( data ) :
				(new Function("return " + data))();

		} else {
			jQuery.error( "Invalid JSON: " + data );
		}
	},

	noop: function() {},

	// Evalulates a script in a global context
	globalEval: function( data ) {
		if ( data && rnotwhite.test(data) ) {
			// Inspired by code by Andrea Giammarchi
			// http://webreflection.blogspot.com/2007/08/global-scope-evaluation-and-dom.html
			var head = document.getElementsByTagName("head")[0] || document.documentElement,
				script = document.createElement("script");

			script.type = "text/javascript";

			if ( jQuery.support.scriptEval ) {
				script.appendChild( document.createTextNode( data ) );
			} else {
				script.text = data;
			}

			// Use insertBefore instead of appendChild to circumvent an IE6 bug.
			// This arises when a base node is used (#2709).
			head.insertBefore( script, head.firstChild );
			head.removeChild( script );
		}
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
	},

	// args is for internal usage only
	each: function( object, callback, args ) {
		var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction(object);

		if ( args ) {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.apply( object[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( object[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( var value = object[0];
					i < length && callback.call( value, i, value ) !== false; value = object[++i] ) {}
			}
		}

		return object;
	},

	// Use native String.trim function wherever possible
	trim: trim ?
		function( text ) {
			return text == null ?
				"" :
				trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
		},

	// results is for internal usage only
	makeArray: function( array, results ) {
		var ret = results || [];

		if ( array != null ) {
			// The window, strings (and functions) also have 'length'
			// The extra typeof function check is to prevent crashes
			// in Safari 2 (See: #3039)
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			var type = jQuery.type(array);

			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
				push.call( ret, array );
			} else {
				jQuery.merge( ret, array );
			}
		}

		return ret;
	},

	inArray: function( elem, array ) {
		if ( array.indexOf ) {
			return array.indexOf( elem );
		}

		for ( var i = 0, length = array.length; i < length; i++ ) {
			if ( array[ i ] === elem ) {
				return i;
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var i = first.length,
			j = 0;

		if ( typeof second.length === "number" ) {
			for ( var l = second.length; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}
		
		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var ret = [], retVal;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var ret = [], value;

		// Go through the array, translating each of the items to their
		// new value (or values).
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			value = callback( elems[ i ], i, arg );

			if ( value != null ) {
				ret[ ret.length ] = value;
			}
		}

		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	proxy: function( fn, proxy, thisObject ) {
		if ( arguments.length === 2 ) {
			if ( typeof proxy === "string" ) {
				thisObject = fn;
				fn = thisObject[ proxy ];
				proxy = undefined;

			} else if ( proxy && !jQuery.isFunction( proxy ) ) {
				thisObject = proxy;
				proxy = undefined;
			}
		}

		if ( !proxy && fn ) {
			proxy = function() {
				return fn.apply( thisObject || this, arguments );
			};
		}

		// Set the guid of unique handler to the same of original handler, so it can be removed
		if ( fn ) {
			proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;
		}

		// So proxy can be declared as an argument
		return proxy;
	},

	// Mutifunctional method to get and set values to a collection
	// The value/s can be optionally by executed if its a function
	access: function( elems, key, value, exec, fn, pass ) {
		var length = elems.length;
	
		// Setting many attributes
		if ( typeof key === "object" ) {
			for ( var k in key ) {
				jQuery.access( elems, k, key[k], exec, fn, value );
			}
			return elems;
		}
	
		// Setting one attribute
		if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = !pass && exec && jQuery.isFunction(value);
		
			for ( var i = 0; i < length; i++ ) {
				fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
			}
		
			return elems;
		}
	
		// Getting an attribute
		return length ? fn( elems[0], key ) : undefined;
	},

	now: function() {
		return (new Date()).getTime();
	},

	// Use of jQuery.browser is frowned upon.
	// More details: http://docs.jquery.com/Utilities/jQuery.browser
	uaMatch: function( ua ) {
		ua = ua.toLowerCase();

		var match = rwebkit.exec( ua ) ||
			ropera.exec( ua ) ||
			rmsie.exec( ua ) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
			[];

		return { browser: match[1] || "", version: match[2] || "0" };
	},

	browser: {}
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

browserMatch = jQuery.uaMatch( userAgent );
if ( browserMatch.browser ) {
	jQuery.browser[ browserMatch.browser ] = true;
	jQuery.browser.version = browserMatch.version;
}

// Deprecated, use jQuery.browser.webkit instead
if ( jQuery.browser.webkit ) {
	jQuery.browser.safari = true;
}

if ( indexOf ) {
	jQuery.inArray = function( elem, array ) {
		return indexOf.call( array, elem );
	};
}

// Verify that \s matches non-breaking spaces
// (IE fails on this test)
if ( !rwhite.test( "\xA0" ) ) {
	trimLeft = /^[\s\xA0]+/;
	trimRight = /[\s\xA0]+$/;
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
if ( document.addEventListener ) {
	DOMContentLoaded = function() {
		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
		jQuery.ready();
	};

} else if ( document.attachEvent ) {
	DOMContentLoaded = function() {
		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( document.readyState === "complete" ) {
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	};
}

// The DOM ready check for Internet Explorer
function doScrollCheck() {
	if ( jQuery.isReady ) {
		return;
	}

	try {
		// If IE is used, use the trick by Diego Perini
		// http://javascript.nwbox.com/IEContentLoaded/
		document.documentElement.doScroll("left");
	} catch(e) {
		setTimeout( doScrollCheck, 1 );
		return;
	}

	// and execute any waiting functions
	jQuery.ready();
}

return jQuery;
// Expose jQuery to the global object
//return (window.jQuery = window.$ = jQuery);

})();


(function() {

	jQuery.support = {};

	var root = document.documentElement,
		script = document.createElement("script"),
		div = document.createElement("div"),
		id = "script" + jQuery.now();

	div.style.display = "none";
	div.innerHTML = "   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

	var all = div.getElementsByTagName("*"),
		a = div.getElementsByTagName("a")[0],
		select = document.createElement("select"),
		opt = select.appendChild( document.createElement("option") );

	// Can't get basic test support
	if ( !all || !all.length || !a ) {
		return;
	}

	jQuery.support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: div.firstChild.nodeType === 3,

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText insted)
		style: /red/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: a.getAttribute("href") === "/a",

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.55$/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: div.getElementsByTagName("input")[0].value === "on",

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Will be defined later
		deleteExpando: true,
		optDisabled: false,
		checkClone: false,
		scriptEval: false,
		noCloneEvent: true,
		boxModel: null,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableHiddenOffsets: true
	};

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as diabled)
	select.disabled = true;
	jQuery.support.optDisabled = !opt.disabled;

	script.type = "text/javascript";
	try {
		script.appendChild( document.createTextNode( "window." + id + "=1;" ) );
	} catch(e) {}

	root.insertBefore( script, root.firstChild );

	// Make sure that the execution of code works by injecting a script
	// tag with appendChild/createTextNode
	// (IE doesn't support this, fails, and uses .text instead)
	if ( window[ id ] ) {
		jQuery.support.scriptEval = true;
		delete window[ id ];
	}

	// Test to see if it's possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete script.test;

	} catch(e) {
		jQuery.support.deleteExpando = false;
	}

	root.removeChild( script );

	if ( div.attachEvent && div.fireEvent ) {
		div.attachEvent("onclick", function click() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			jQuery.support.noCloneEvent = false;
			div.detachEvent("onclick", click);
		});
		div.cloneNode(true).fireEvent("onclick");
	}

	div = document.createElement("div");
	div.innerHTML = "<input type='radio' name='radiotest' checked='checked'/>";

	var fragment = document.createDocumentFragment();
	fragment.appendChild( div.firstChild );

	// WebKit doesn't clone checked state correctly in fragments
	jQuery.support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;

	// Figure out if the W3C box model works as expected
	// document.body must exist before we can do this
	jQuery(function() {
		var div = document.createElement("div");
		div.style.width = div.style.paddingLeft = "1px";

		document.body.appendChild( div );
		jQuery.boxModel = jQuery.support.boxModel = div.offsetWidth === 2;

		if ( "zoom" in div.style ) {
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			// (IE < 8 does this)
			div.style.display = "inline";
			div.style.zoom = 1;
			jQuery.support.inlineBlockNeedsLayout = div.offsetWidth === 2;

			// Check if elements with layout shrink-wrap their children
			// (IE 6 does this)
			div.style.display = "";
			div.innerHTML = "<div style='width:4px;'></div>";
			jQuery.support.shrinkWrapBlocks = div.offsetWidth !== 2;
		}

		div.innerHTML = "<table><tr><td style='padding:0;display:none'></td><td>t</td></tr></table>";
		var tds = div.getElementsByTagName("td");

		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		jQuery.support.reliableHiddenOffsets = tds[0].offsetHeight === 0;

		tds[0].style.display = "";
		tds[1].style.display = "none";

		// Check if empty table cells still have offsetWidth/Height
		// (IE < 8 fail this test)
		jQuery.support.reliableHiddenOffsets = jQuery.support.reliableHiddenOffsets && tds[0].offsetHeight === 0;
		div.innerHTML = "";

		document.body.removeChild( div ).style.display = "none";
		div = tds = null;
	});

	// Technique from Juriy Zaytsev
	// http://thinkweb2.com/projects/prototype/detecting-event-support-without-browser-sniffing/
	var eventSupported = function( eventName ) {
		var el = document.createElement("div");
		eventName = "on" + eventName;

		var isSupported = (eventName in el);
		if ( !isSupported ) {
			el.setAttribute(eventName, "return;");
			isSupported = typeof el[eventName] === "function";
		}
		el = null;

		return isSupported;
	};

	jQuery.support.submitBubbles = eventSupported("submit");
	jQuery.support.changeBubbles = eventSupported("change");

	// release memory in IE
	root = script = div = all = a = null;
})();



var windowData = {},
	rbrace = /^(?:\{.*\}|\[.*\])$/;

jQuery.extend({
	cache: {},

	// Please use with caution
	uuid: 0,

	// Unique for each copy of jQuery on the page	
	expando: "jQuery" + jQuery.now(),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	data: function( elem, name, data ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		elem = elem == window ?
			windowData :
			elem;

		var isNode = elem.nodeType,
			id = isNode ? elem[ jQuery.expando ] : null,
			cache = jQuery.cache, thisCache;

		if ( isNode && !id && typeof name === "string" && data === undefined ) {
			return;
		}

		// Get the data from the object directly
		if ( !isNode ) {
			cache = elem;

		// Compute a unique ID for the element
		} else if ( !id ) {
			elem[ jQuery.expando ] = id = ++jQuery.uuid;
		}

		// Avoid generating a new cache unless none exists and we
		// want to manipulate it.
		if ( typeof name === "object" ) {
			if ( isNode ) {
				cache[ id ] = jQuery.extend(cache[ id ], name);

			} else {
				jQuery.extend( cache, name );
			}

		} else if ( isNode && !cache[ id ] ) {
			cache[ id ] = {};
		}

		thisCache = isNode ? cache[ id ] : cache;

		// Prevent overriding the named cache with undefined values
		if ( data !== undefined ) {
			thisCache[ name ] = data;
		}

		return typeof name === "string" ? thisCache[ name ] : thisCache;
	},

	removeData: function( elem, name ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		elem = elem == window ?
			windowData :
			elem;

		var isNode = elem.nodeType,
			id = isNode ? elem[ jQuery.expando ] : elem,
			cache = jQuery.cache,
			thisCache = isNode ? cache[ id ] : id;

		// If we want to remove a specific section of the element's data
		if ( name ) {
			if ( thisCache ) {
				// Remove the section of cache data
				delete thisCache[ name ];

				// If we've removed all the data, remove the element's cache
				if ( isNode && jQuery.isEmptyObject(thisCache) ) {
					jQuery.removeData( elem );
				}
			}

		// Otherwise, we want to remove all of the element's data
		} else {
			if ( isNode && jQuery.support.deleteExpando ) {
				delete elem[ jQuery.expando ];

			} else if ( elem.removeAttribute ) {
				elem.removeAttribute( jQuery.expando );

			// Completely remove the data cache
			} else if ( isNode ) {
				delete cache[ id ];

			// Remove all fields from the object
			} else {
				for ( var n in elem ) {
					delete elem[ n ];
				}
			}
		}
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		if ( elem.nodeName ) {
			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

			if ( match ) {
				return !(match === true || elem.getAttribute("classid") !== match);
			}
		}

		return true;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var data = null;

		if ( typeof key === "undefined" ) {
			if ( this.length ) {
				var attr = this[0].attributes, name;
				data = jQuery.data( this[0] );

				for ( var i = 0, l = attr.length; i < l; i++ ) {
					name = attr[i].name;

					if ( name.indexOf( "data-" ) === 0 ) {
						name = name.substr( 5 );
						dataAttr( this[0], name, data[ name ] );
					}
				}
			}

			return data;

		} else if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		var parts = key.split(".");
		parts[1] = parts[1] ? "." + parts[1] : "";

		if ( value === undefined ) {
			data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

			// Try to fetch any internally stored data first
			if ( data === undefined && this.length ) {
				data = jQuery.data( this[0], key );
				data = dataAttr( this[0], key, data );
			}

			return data === undefined && parts[1] ?
				this.data( parts[0] ) :
				data;

		} else {
			return this.each(function() {
				var $this = jQuery( this ),
					args = [ parts[0], value ];

				$this.triggerHandler( "setData" + parts[1] + "!", args );
				jQuery.data( this, key, value );
				$this.triggerHandler( "changeData" + parts[1] + "!", args );
			});
		}
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		data = elem.getAttribute( "data-" + key );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				!jQuery.isNaN( data ) ? parseFloat( data ) :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}




jQuery.extend({
	queue: function( elem, type, data ) {
		if ( !elem ) {
			return;
		}

		type = (type || "fx") + "queue";
		var q = jQuery.data( elem, type );

		// Speed up dequeue by getting out quickly if this is just a lookup
		if ( !data ) {
			return q || [];
		}

		if ( !q || jQuery.isArray(data) ) {
			q = jQuery.data( elem, type, jQuery.makeArray(data) );

		} else {
			q.push( data );
		}

		return q;
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			fn = queue.shift();

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
		}

		if ( fn ) {
			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift("inprogress");
			}

			fn.call(elem, function() {
				jQuery.dequeue(elem, type);
			});
		}
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
		}

		if ( data === undefined ) {
			return jQuery.queue( this[0], type );
		}
		return this.each(function( i ) {
			var queue = jQuery.queue( this, type, data );

			if ( type === "fx" && queue[0] !== "inprogress" ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},

	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
		type = type || "fx";

		return this.queue( type, function() {
			var elem = this;
			setTimeout(function() {
				jQuery.dequeue( elem, type );
			}, time );
		});
	},

	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	}
});




var rclass = /[\n\t]/g,
	rspaces = /\s+/,
	rreturn = /\r/g,
	rspecialurl = /^(?:href|src|style)$/,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rradiocheck = /^(?:radio|checkbox)$/i;

jQuery.props = {
	"for": "htmlFor",
	"class": "className",
	readonly: "readOnly",
	maxlength: "maxLength",
	cellspacing: "cellSpacing",
	rowspan: "rowSpan",
	colspan: "colSpan",
	tabindex: "tabIndex",
	usemap: "useMap",
	frameborder: "frameBorder"
};

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.attr );
	},

	removeAttr: function( name, fn ) {
		return this.each(function(){
			jQuery.attr( this, name, "" );
			if ( this.nodeType === 1 ) {
				this.removeAttribute( name );
			}
		});
	},

	addClass: function( value ) {
		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				self.addClass( value.call(this, i, self.attr("class")) );
			});
		}

		if ( value && typeof value === "string" ) {
			var classNames = (value || "").split( rspaces );

			for ( var i = 0, l = this.length; i < l; i++ ) {
				var elem = this[i];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className ) {
						elem.className = value;

					} else {
						var className = " " + elem.className + " ",
							setClass = elem.className;

						for ( var c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( className.indexOf( " " + classNames[c] + " " ) < 0 ) {
								setClass += " " + classNames[c];
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				self.removeClass( value.call(this, i, self.attr("class")) );
			});
		}

		if ( (value && typeof value === "string") || value === undefined ) {
			var classNames = (value || "").split( rspaces );

			for ( var i = 0, l = this.length; i < l; i++ ) {
				var elem = this[i];

				if ( elem.nodeType === 1 && elem.className ) {
					if ( value ) {
						var className = (" " + elem.className + " ").replace(rclass, " ");
						for ( var c = 0, cl = classNames.length; c < cl; c++ ) {
							className = className.replace(" " + classNames[c] + " ", " ");
						}
						elem.className = jQuery.trim( className );

					} else {
						elem.className = "";
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				self.toggleClass( value.call(this, i, self.attr("class"), stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( rspaces );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space seperated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery.data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery.data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ";
		for ( var i = 0, l = this.length; i < l; i++ ) {
			if ( (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		if ( !arguments.length ) {
			var elem = this[0];

			if ( elem ) {
				if ( jQuery.nodeName( elem, "option" ) ) {
					// attributes.value is undefined in Blackberry 4.7 but
					// uses .value. See #6932
					var val = elem.attributes.value;
					return !val || val.specified ? elem.value : elem.text;
				}

				// We need to handle select boxes special
				if ( jQuery.nodeName( elem, "select" ) ) {
					var index = elem.selectedIndex,
						values = [],
						options = elem.options,
						one = elem.type === "select-one";

					// Nothing was selected
					if ( index < 0 ) {
						return null;
					}

					// Loop through all the selected options
					for ( var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++ ) {
						var option = options[ i ];

						// Don't return options that are disabled or in a disabled optgroup
						if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && 
								(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

							// Get the specific value for the option
							value = jQuery(option).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				}

				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				if ( rradiocheck.test( elem.type ) && !jQuery.support.checkOn ) {
					return elem.getAttribute("value") === null ? "on" : elem.value;
				}
				

				// Everything else, we just grab the value
				return (elem.value || "").replace(rreturn, "");

			}

			return undefined;
		}

		var isFunction = jQuery.isFunction(value);

		return this.each(function(i) {
			var self = jQuery(this), val = value;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call(this, i, self.val());
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray(val) ) {
				val = jQuery.map(val, function (value) {
					return value == null ? "" : value + "";
				});
			}

			if ( jQuery.isArray(val) && rradiocheck.test( this.type ) ) {
				this.checked = jQuery.inArray( self.val(), val ) >= 0;

			} else if ( jQuery.nodeName( this, "select" ) ) {
				var values = jQuery.makeArray(val);

				jQuery( "option", this ).each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					this.selectedIndex = -1;
				}

			} else {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	attrFn: {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true
	},
		
	attr: function( elem, name, value, pass ) {
		// don't set attributes on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 ) {
			return undefined;
		}

		if ( pass && name in jQuery.attrFn ) {
			return jQuery(elem)[name](value);
		}

		var notxml = elem.nodeType !== 1 || !jQuery.isXMLDoc( elem ),
			// Whether we are setting (or getting)
			set = value !== undefined;

		// Try to normalize/fix the name
		name = notxml && jQuery.props[ name ] || name;

		// These attributes require special treatment
		var special = rspecialurl.test( name );

		// Safari mis-reports the default selected property of an option
		// Accessing the parent's selectedIndex property fixes it
		if ( name === "selected" && !jQuery.support.optSelected ) {
			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}

		// If applicable, access the attribute via the DOM 0 way
		// 'in' checks fail in Blackberry 4.7 #6931
		if ( (name in elem || elem[ name ] !== undefined) && notxml && !special ) {
			if ( set ) {
				// We can't allow the type property to be changed (since it causes problems in IE)
				if ( name === "type" && rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				}

				if ( value === null ) {
					if ( elem.nodeType === 1 ) {
						elem.removeAttribute( name );
					}

				} else {
					elem[ name ] = value;
				}
			}

			// browsers index elements by id/name on forms, give priority to attributes.
			if ( jQuery.nodeName( elem, "form" ) && elem.getAttributeNode(name) ) {
				return elem.getAttributeNode( name ).nodeValue;
			}

			// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
			// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
			if ( name === "tabIndex" ) {
				var attributeNode = elem.getAttributeNode( "tabIndex" );

				return attributeNode && attributeNode.specified ?
					attributeNode.value :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}

			return elem[ name ];
		}

		if ( !jQuery.support.style && notxml && name === "style" ) {
			if ( set ) {
				elem.style.cssText = "" + value;
			}

			return elem.style.cssText;
		}

		if ( set ) {
			// convert the value to a string (all browsers do this but IE) see #1070
			elem.setAttribute( name, "" + value );
		}

		// Ensure that missing attributes return undefined
		// Blackberry 4.7 returns "" from getAttribute #6938
		if ( !elem.attributes[ name ] && (elem.hasAttribute && !elem.hasAttribute( name )) ) {
			return undefined;
		}

		var attr = !jQuery.support.hrefNormalized && notxml && special ?
				// Some attributes require a special call on IE
				elem.getAttribute( name, 2 ) :
				elem.getAttribute( name );

		// Non-existent attributes return null, we normalize to undefined
		return attr === null ? undefined : attr;
	}
});




var rnamespaces = /\.(.*)$/,
	rformElems = /^(?:textarea|input|select)$/i,
	rperiod = /\./g,
	rspace = / /g,
	rescape = /[^\w\s.|`]/g,
	fcleanup = function( nm ) {
		return nm.replace(rescape, "\\$&");
	},
	focusCounts = { focusin: 0, focusout: 0 };

/*
 * A number of helper functions used for managing events.
 * Many of the ideas behind this code originated from
 * Dean Edwards' addEvent library.
 */
jQuery.event = {

	// Bind an event to an element
	// Original by Dean Edwards
	add: function( elem, types, handler, data ) {
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// For whatever reason, IE has trouble passing the window object
		// around, causing it to be cloned in the process
		if ( jQuery.isWindow( elem ) && ( elem !== window && !elem.frameElement ) ) {
			elem = window;
		}

		if ( handler === false ) {
			handler = returnFalse;
		} else if ( !handler ) {
			// Fixes bug #7229. Fix recommended by jdalton
		  return;
		}

		var handleObjIn, handleObj;

		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
		}

		// Make sure that the function being executed has a unique ID
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure
		var elemData = jQuery.data( elem );

		// If no elemData is found then we must be trying to bind to one of the
		// banned noData elements
		if ( !elemData ) {
			return;
		}

		// Use a key less likely to result in collisions for plain JS objects.
		// Fixes bug #7150.
		var eventKey = elem.nodeType ? "events" : "__events__",
			events = elemData[ eventKey ],
			eventHandle = elemData.handle;
			
		if ( typeof events === "function" ) {
			// On plain objects events is a fn that holds the the data
			// which prevents this data from being JSON serialized
			// the function does not need to be called, it just contains the data
			eventHandle = events.handle;
			events = events.events;

		} else if ( !events ) {
			if ( !elem.nodeType ) {
				// On plain objects, create a fn that acts as the holder
				// of the values to avoid JSON serialization of event data
				elemData[ eventKey ] = elemData = function(){};
			}

			elemData.events = events = {};
		}

		if ( !eventHandle ) {
			elemData.handle = eventHandle = function() {
				// Handle the second event of a trigger and when
				// an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && !jQuery.event.triggered ?
					jQuery.event.handle.apply( eventHandle.elem, arguments ) :
					undefined;
			};
		}

		// Add elem as a property of the handle function
		// This is to prevent a memory leak with non-native events in IE.
		eventHandle.elem = elem;

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = types.split(" ");

		var type, i = 0, namespaces;

		while ( (type = types[ i++ ]) ) {
			handleObj = handleObjIn ?
				jQuery.extend({}, handleObjIn) :
				{ handler: handler, data: data };

			// Namespaced event handlers
			if ( type.indexOf(".") > -1 ) {
				namespaces = type.split(".");
				type = namespaces.shift();
				handleObj.namespace = namespaces.slice(0).sort().join(".");

			} else {
				namespaces = [];
				handleObj.namespace = "";
			}

			handleObj.type = type;
			if ( !handleObj.guid ) {
				handleObj.guid = handler.guid;
			}

			// Get the current list of functions bound to this event
			var handlers = events[ type ],
				special = jQuery.event.special[ type ] || {};

			// Init the event handler queue
			if ( !handlers ) {
				handlers = events[ type ] = [];

				// Check for a special event handler
				// Only use addEventListener/attachEvent if the special
				// events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}
			
			if ( special.add ) { 
				special.add.call( elem, handleObj ); 

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add the function to the element's handler list
			handlers.push( handleObj );

			// Keep track of which events have been used, for global triggering
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, pos ) {
		// don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		if ( handler === false ) {
			handler = returnFalse;
		}

		var ret, type, fn, j, i = 0, all, namespaces, namespace, special, eventType, handleObj, origType,
			eventKey = elem.nodeType ? "events" : "__events__",
			elemData = jQuery.data( elem ),
			events = elemData && elemData[ eventKey ];

		if ( !elemData || !events ) {
			return;
		}
		
		if ( typeof events === "function" ) {
			elemData = events;
			events = events.events;
		}

		// types is actually an event object here
		if ( types && types.type ) {
			handler = types.handler;
			types = types.type;
		}

		// Unbind all events for the element
		if ( !types || typeof types === "string" && types.charAt(0) === "." ) {
			types = types || "";

			for ( type in events ) {
				jQuery.event.remove( elem, type + types );
			}

			return;
		}

		// Handle multiple events separated by a space
		// jQuery(...).unbind("mouseover mouseout", fn);
		types = types.split(" ");

		while ( (type = types[ i++ ]) ) {
			origType = type;
			handleObj = null;
			all = type.indexOf(".") < 0;
			namespaces = [];

			if ( !all ) {
				// Namespaced event handlers
				namespaces = type.split(".");
				type = namespaces.shift();

				namespace = new RegExp("(^|\\.)" + 
					jQuery.map( namespaces.slice(0).sort(), fcleanup ).join("\\.(?:.*\\.)?") + "(\\.|$)");
			}

			eventType = events[ type ];

			if ( !eventType ) {
				continue;
			}

			if ( !handler ) {
				for ( j = 0; j < eventType.length; j++ ) {
					handleObj = eventType[ j ];

					if ( all || namespace.test( handleObj.namespace ) ) {
						jQuery.event.remove( elem, origType, handleObj.handler, j );
						eventType.splice( j--, 1 );
					}
				}

				continue;
			}

			special = jQuery.event.special[ type ] || {};

			for ( j = pos || 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( handler.guid === handleObj.guid ) {
					// remove the given handler for the given type
					if ( all || namespace.test( handleObj.namespace ) ) {
						if ( pos == null ) {
							eventType.splice( j--, 1 );
						}

						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}

					if ( pos != null ) {
						break;
					}
				}
			}

			// remove generic event handler if no more handlers exist
			if ( eventType.length === 0 || pos != null && eventType.length === 1 ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				ret = null;
				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			var handle = elemData.handle;
			if ( handle ) {
				handle.elem = null;
			}

			delete elemData.events;
			delete elemData.handle;

			if ( typeof elemData === "function" ) {
				jQuery.removeData( elem, eventKey );

			} else if ( jQuery.isEmptyObject( elemData ) ) {
				jQuery.removeData( elem );
			}
		}
	},

	// bubbling is internal
	trigger: function( event, data, elem /*, bubbling */ ) {
		// Event object or event type
		var type = event.type || event,
			bubbling = arguments[3];

		if ( !bubbling ) {
			event = typeof event === "object" ?
				// jQuery.Event object
				event[ jQuery.expando ] ? event :
				// Object literal
				jQuery.extend( jQuery.Event(type), event ) :
				// Just the event type (string)
				jQuery.Event(type);

			if ( type.indexOf("!") >= 0 ) {
				event.type = type = type.slice(0, -1);
				event.exclusive = true;
			}

			// Handle a global trigger
			if ( !elem ) {
				// Don't bubble custom events when global (to avoid too much overhead)
				event.stopPropagation();

				// Only trigger if we've ever bound an event for it
				if ( jQuery.event.global[ type ] ) {
					jQuery.each( jQuery.cache, function() {
						if ( this.events && this.events[type] ) {
							jQuery.event.trigger( event, data, this.handle.elem );
						}
					});
				}
			}

			// Handle triggering a single element

			// don't do events on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 ) {
				return undefined;
			}

			// Clean up in case it is reused
			event.result = undefined;
			event.target = elem;

			// Clone the incoming data, if any
			data = jQuery.makeArray( data );
			data.unshift( event );
		}

		event.currentTarget = elem;

		// Trigger the event, it is assumed that "handle" is a function
		var handle = elem.nodeType ?
			jQuery.data( elem, "handle" ) :
			(jQuery.data( elem, "__events__" ) || {}).handle;

		if ( handle ) {
			handle.apply( elem, data );
		}

		var parent = elem.parentNode || elem.ownerDocument;

		// Trigger an inline bound script
		try {
			if ( !(elem && elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]) ) {
				if ( elem[ "on" + type ] && elem[ "on" + type ].apply( elem, data ) === false ) {
					event.result = false;
					event.preventDefault();
				}
			}

		// prevent IE from throwing an error for some elements with some event types, see #3533
		} catch (inlineError) {}

		if ( !event.isPropagationStopped() && parent ) {
			jQuery.event.trigger( event, data, parent, true );

		} else if ( !event.isDefaultPrevented() ) {
			var old,
				target = event.target,
				targetType = type.replace( rnamespaces, "" ),
				isClick = jQuery.nodeName( target, "a" ) && targetType === "click",
				special = jQuery.event.special[ targetType ] || {};

			if ( (!special._default || special._default.call( elem, event ) === false) && 
				!isClick && !(target && target.nodeName && jQuery.noData[target.nodeName.toLowerCase()]) ) {

				try {
					if ( target[ targetType ] ) {
						// Make sure that we don't accidentally re-trigger the onFOO events
						old = target[ "on" + targetType ];

						if ( old ) {
							target[ "on" + targetType ] = null;
						}

						jQuery.event.triggered = true;
						target[ targetType ]();
					}

				// prevent IE from throwing an error for some elements with some event types, see #3533
				} catch (triggerError) {}

				if ( old ) {
					target[ "on" + targetType ] = old;
				}

				jQuery.event.triggered = false;
			}
		}
	},

	handle: function( event ) {
		var all, handlers, namespaces, namespace_re, events,
			namespace_sort = [],
			args = jQuery.makeArray( arguments );

		event = args[0] = jQuery.event.fix( event || window.event );
		event.currentTarget = this;

		// Namespaced event handlers
		all = event.type.indexOf(".") < 0 && !event.exclusive;

		if ( !all ) {
			namespaces = event.type.split(".");
			event.type = namespaces.shift();
			namespace_sort = namespaces.slice(0).sort();
			namespace_re = new RegExp("(^|\\.)" + namespace_sort.join("\\.(?:.*\\.)?") + "(\\.|$)");
		}

		event.namespace = event.namespace || namespace_sort.join(".");

		events = jQuery.data(this, this.nodeType ? "events" : "__events__");

		if ( typeof events === "function" ) {
			events = events.events;
		}

		handlers = (events || {})[ event.type ];

		if ( events && handlers ) {
			// Clone the handlers to prevent manipulation
			handlers = handlers.slice(0);

			for ( var j = 0, l = handlers.length; j < l; j++ ) {
				var handleObj = handlers[ j ];

				// Filter the functions by class
				if ( all || namespace_re.test( handleObj.namespace ) ) {
					// Pass in a reference to the handler function itself
					// So that we can later remove it
					event.handler = handleObj.handler;
					event.data = handleObj.data;
					event.handleObj = handleObj;
	
					var ret = handleObj.handler.apply( this, args );

					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}

					if ( event.isImmediatePropagationStopped() ) {
						break;
					}
				}
			}
		}

		return event.result;
	},

	props: "altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// store a copy of the original event object
		// and "clone" to set read-only properties
		var originalEvent = event;
		event = jQuery.Event( originalEvent );

		for ( var i = this.props.length, prop; i; ) {
			prop = this.props[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary
		if ( !event.target ) {
			// Fixes #1925 where srcElement might not be defined either
			event.target = event.srcElement || document;
		}

		// check if target is a textnode (safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// Add relatedTarget, if necessary
		if ( !event.relatedTarget && event.fromElement ) {
			event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
		}

		// Calculate pageX/Y if missing and clientX/Y available
		if ( event.pageX == null && event.clientX != null ) {
			var doc = document.documentElement,
				body = document.body;

			event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
			event.pageY = event.clientY + (doc && doc.scrollTop  || body && body.scrollTop  || 0) - (doc && doc.clientTop  || body && body.clientTop  || 0);
		}

		// Add which for key events
		if ( event.which == null && (event.charCode != null || event.keyCode != null) ) {
			event.which = event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
		if ( !event.metaKey && event.ctrlKey ) {
			event.metaKey = event.ctrlKey;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		// Note: button is not normalized, so don't use it
		if ( !event.which && event.button !== undefined ) {
			event.which = (event.button & 1 ? 1 : ( event.button & 2 ? 3 : ( event.button & 4 ? 2 : 0 ) ));
		}

		return event;
	},

	// Deprecated, use jQuery.guid instead
	guid: 1E8,

	// Deprecated, use jQuery.proxy instead
	proxy: jQuery.proxy,

	special: {
		ready: {
			// Make sure the ready event is setup
			setup: jQuery.bindReady,
			teardown: jQuery.noop
		},

		live: {
			add: function( handleObj ) {
				jQuery.event.add( this,
					liveConvert( handleObj.origType, handleObj.selector ),
					jQuery.extend({}, handleObj, {handler: liveHandler, guid: handleObj.handler.guid}) ); 
			},

			remove: function( handleObj ) {
				jQuery.event.remove( this, liveConvert( handleObj.origType, handleObj.selector ), handleObj );
			}
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	}
};

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} : 
	function( elem, type, handle ) {
		if ( elem.detachEvent ) {
			elem.detachEvent( "on" + type, handle );
		}
	};

jQuery.Event = function( src ) {
	// Allow instantiation without the 'new' keyword
	if ( !this.preventDefault ) {
		return new jQuery.Event( src );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;
	// Event type
	} else {
		this.type = src;
	}

	// timeStamp is buggy for some events on Firefox(#3843)
	// So we won't rely on the native value
	this.timeStamp = jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		
		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Checks if an event happened on an element within another element
// Used in jQuery.event.special.mouseenter and mouseleave handlers
var withinElement = function( event ) {
	// Check if mouse(over|out) are still within the same parent element
	var parent = event.relatedTarget;

	// Firefox sometimes assigns relatedTarget a XUL element
	// which we cannot access the parentNode property of
	try {
		// Traverse up the tree
		while ( parent && parent !== this ) {
			parent = parent.parentNode;
		}

		if ( parent !== this ) {
			// set the correct event type
			event.type = event.data;

			// handle event if we actually just moused on to a non sub-element
			jQuery.event.handle.apply( this, arguments );
		}

	// assuming we've left the element since we most likely mousedover a xul element
	} catch(e) { }
},

// In case of event delegation, we only need to rename the event.type,
// liveHandler will take care of the rest.
delegate = function( event ) {
	event.type = event.data;
	jQuery.event.handle.apply( this, arguments );
};

// Create mouseenter and mouseleave events
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		setup: function( data ) {
			jQuery.event.add( this, fix, data && data.selector ? delegate : withinElement, orig );
		},
		teardown: function( data ) {
			jQuery.event.remove( this, fix, data && data.selector ? delegate : withinElement );
		}
	};
});

// submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function( data, namespaces ) {
			if ( this.nodeName.toLowerCase() !== "form" ) {
				jQuery.event.add(this, "click.specialSubmit", function( e ) {
					var elem = e.target,
						type = elem.type;

					if ( (type === "submit" || type === "image") && jQuery( elem ).closest("form").length ) {
						e.liveFired = undefined;
						return trigger( "submit", this, arguments );
					}
				});
	 
				jQuery.event.add(this, "keypress.specialSubmit", function( e ) {
					var elem = e.target,
						type = elem.type;

					if ( (type === "text" || type === "password") && jQuery( elem ).closest("form").length && e.keyCode === 13 ) {
						e.liveFired = undefined;
						return trigger( "submit", this, arguments );
					}
				});

			} else {
				return false;
			}
		},

		teardown: function( namespaces ) {
			jQuery.event.remove( this, ".specialSubmit" );
		}
	};

}

// change delegation, happens here so we have bind.
if ( !jQuery.support.changeBubbles ) {

	var changeFilters,

	getVal = function( elem ) {
		var type = elem.type, val = elem.value;

		if ( type === "radio" || type === "checkbox" ) {
			val = elem.checked;

		} else if ( type === "select-multiple" ) {
			val = elem.selectedIndex > -1 ?
				jQuery.map( elem.options, function( elem ) {
					return elem.selected;
				}).join("-") :
				"";

		} else if ( elem.nodeName.toLowerCase() === "select" ) {
			val = elem.selectedIndex;
		}

		return val;
	},

	testChange = function testChange( e ) {
		var elem = e.target, data, val;

		if ( !rformElems.test( elem.nodeName ) || elem.readOnly ) {
			return;
		}

		data = jQuery.data( elem, "_change_data" );
		val = getVal(elem);

		// the current data will be also retrieved by beforeactivate
		if ( e.type !== "focusout" || elem.type !== "radio" ) {
			jQuery.data( elem, "_change_data", val );
		}
		
		if ( data === undefined || val === data ) {
			return;
		}

		if ( data != null || val ) {
			e.type = "change";
			e.liveFired = undefined;
			return jQuery.event.trigger( e, arguments[1], elem );
		}
	};

	jQuery.event.special.change = {
		filters: {
			focusout: testChange, 

			beforedeactivate: testChange,

			click: function( e ) {
				var elem = e.target, type = elem.type;

				if ( type === "radio" || type === "checkbox" || elem.nodeName.toLowerCase() === "select" ) {
					return testChange.call( this, e );
				}
			},

			// Change has to be called before submit
			// Keydown will be called before keypress, which is used in submit-event delegation
			keydown: function( e ) {
				var elem = e.target, type = elem.type;

				if ( (e.keyCode === 13 && elem.nodeName.toLowerCase() !== "textarea") ||
					(e.keyCode === 32 && (type === "checkbox" || type === "radio")) ||
					type === "select-multiple" ) {
					return testChange.call( this, e );
				}
			},

			// Beforeactivate happens also before the previous element is blurred
			// with this event you can't trigger a change event, but you can store
			// information
			beforeactivate: function( e ) {
				var elem = e.target;
				jQuery.data( elem, "_change_data", getVal(elem) );
			}
		},

		setup: function( data, namespaces ) {
			if ( this.type === "file" ) {
				return false;
			}

			for ( var type in changeFilters ) {
				jQuery.event.add( this, type + ".specialChange", changeFilters[type] );
			}

			return rformElems.test( this.nodeName );
		},

		teardown: function( namespaces ) {
			jQuery.event.remove( this, ".specialChange" );

			return rformElems.test( this.nodeName );
		}
	};

	changeFilters = jQuery.event.special.change.filters;

	// Handle when the input is .focus()'d
	changeFilters.focus = changeFilters.beforeactivate;
}

function trigger( type, elem, args ) {
	args[0].type = type;
	return jQuery.event.handle.apply( elem, args );
}

// Create "bubbling" focus and blur events
if ( document.addEventListener ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {
		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( focusCounts[fix]++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			}, 
			teardown: function() { 
				if ( --focusCounts[fix] === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};

		function handler( e ) { 
			e = jQuery.event.fix( e );
			e.type = fix;
			return jQuery.event.trigger( e, null, e.target );
		}
	});
}

jQuery.each(["bind", "one"], function( i, name ) {
	jQuery.fn[ name ] = function( type, data, fn ) {
		// Handle object literals
		if ( typeof type === "object" ) {
			for ( var key in type ) {
				this[ name ](key, data, type[key], fn);
			}
			return this;
		}
		
		if ( jQuery.isFunction( data ) || data === false ) {
			fn = data;
			data = undefined;
		}

		var handler = name === "one" ? jQuery.proxy( fn, function( event ) {
			jQuery( this ).unbind( event, handler );
			return fn.apply( this, arguments );
		}) : fn;

		if ( type === "unload" && name !== "one" ) {
			this.one( type, data, fn );

		} else {
			for ( var i = 0, l = this.length; i < l; i++ ) {
				jQuery.event.add( this[i], type, handler, data );
			}
		}

		return this;
	};
});

jQuery.fn.extend({
	unbind: function( type, fn ) {
		// Handle object literals
		if ( typeof type === "object" && !type.preventDefault ) {
			for ( var key in type ) {
				this.unbind(key, type[key]);
			}

		} else {
			for ( var i = 0, l = this.length; i < l; i++ ) {
				jQuery.event.remove( this[i], type, fn );
			}
		}

		return this;
	},
	
	delegate: function( selector, types, data, fn ) {
		return this.live( types, data, fn, selector );
	},
	
	undelegate: function( selector, types, fn ) {
		if ( arguments.length === 0 ) {
				return this.unbind( "live" );
		
		} else {
			return this.die( types, null, fn, selector );
		}
	},
	
	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},

	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			var event = jQuery.Event( type );
			event.preventDefault();
			event.stopPropagation();
			jQuery.event.trigger( event, data, this[0] );
			return event.result;
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			i = 1;

		// link all the functions, so any of them can unbind this click handler
		while ( i < args.length ) {
			jQuery.proxy( fn, args[ i++ ] );
		}

		return this.click( jQuery.proxy( fn, function( event ) {
			// Figure out which function to execute
			var lastToggle = ( jQuery.data( this, "lastToggle" + fn.guid ) || 0 ) % i;
			jQuery.data( this, "lastToggle" + fn.guid, lastToggle + 1 );

			// Make sure that clicks stop
			event.preventDefault();

			// and execute the function
			return args[ lastToggle ].apply( this, arguments ) || false;
		}));
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

var liveMap = {
	focus: "focusin",
	blur: "focusout",
	mouseenter: "mouseover",
	mouseleave: "mouseout"
};

jQuery.each(["live", "die"], function( i, name ) {
	jQuery.fn[ name ] = function( types, data, fn, origSelector /* Internal Use Only */ ) {
		var type, i = 0, match, namespaces, preType,
			selector = origSelector || this.selector,
			context = origSelector ? this : jQuery( this.context );
		
		if ( typeof types === "object" && !types.preventDefault ) {
			for ( var key in types ) {
				context[ name ]( key, data, types[key], selector );
			}
			
			return this;
		}

		if ( jQuery.isFunction( data ) ) {
			fn = data;
			data = undefined;
		}

		types = (types || "").split(" ");

		while ( (type = types[ i++ ]) != null ) {
			match = rnamespaces.exec( type );
			namespaces = "";

			if ( match )  {
				namespaces = match[0];
				type = type.replace( rnamespaces, "" );
			}

			if ( type === "hover" ) {
				types.push( "mouseenter" + namespaces, "mouseleave" + namespaces );
				continue;
			}

			preType = type;

			if ( type === "focus" || type === "blur" ) {
				types.push( liveMap[ type ] + namespaces );
				type = type + namespaces;

			} else {
				type = (liveMap[ type ] || type) + namespaces;
			}

			if ( name === "live" ) {
				// bind live handler
				for ( var j = 0, l = context.length; j < l; j++ ) {
					jQuery.event.add( context[j], "live." + liveConvert( type, selector ),
						{ data: data, selector: selector, handler: fn, origType: type, origHandler: fn, preType: preType } );
				}

			} else {
				// unbind live handler
				context.unbind( "live." + liveConvert( type, selector ), fn );
			}
		}
		
		return this;
	};
});

function liveHandler( event ) {
	var stop, maxLevel, related, match, handleObj, elem, j, i, l, data, close, namespace, ret,
		elems = [],
		selectors = [],
		events = jQuery.data( this, this.nodeType ? "events" : "__events__" );

	if ( typeof events === "function" ) {
		events = events.events;
	}

	// Make sure we avoid non-left-click bubbling in Firefox (#3861)
	if ( event.liveFired === this || !events || !events.live || event.button && event.type === "click" ) {
		return;
	}
	
	if ( event.namespace ) {
		namespace = new RegExp("(^|\\.)" + event.namespace.split(".").join("\\.(?:.*\\.)?") + "(\\.|$)");
	}

	event.liveFired = this;

	var live = events.live.slice(0);

	for ( j = 0; j < live.length; j++ ) {
		handleObj = live[j];

		if ( handleObj.origType.replace( rnamespaces, "" ) === event.type ) {
			selectors.push( handleObj.selector );

		} else {
			live.splice( j--, 1 );
		}
	}

	match = jQuery( event.target ).closest( selectors, event.currentTarget );

	for ( i = 0, l = match.length; i < l; i++ ) {
		close = match[i];

		for ( j = 0; j < live.length; j++ ) {
			handleObj = live[j];

			if ( close.selector === handleObj.selector && (!namespace || namespace.test( handleObj.namespace )) ) {
				elem = close.elem;
				related = null;

				// Those two events require additional checking
				if ( handleObj.preType === "mouseenter" || handleObj.preType === "mouseleave" ) {
					event.type = handleObj.preType;
					related = jQuery( event.relatedTarget ).closest( handleObj.selector )[0];
				}

				if ( !related || related !== elem ) {
					elems.push({ elem: elem, handleObj: handleObj, level: close.level });
				}
			}
		}
	}

	for ( i = 0, l = elems.length; i < l; i++ ) {
		match = elems[i];

		if ( maxLevel && match.level > maxLevel ) {
			break;
		}

		event.currentTarget = match.elem;
		event.data = match.handleObj.data;
		event.handleObj = match.handleObj;

		ret = match.handleObj.origHandler.apply( match.elem, arguments );

		if ( ret === false || event.isPropagationStopped() ) {
			maxLevel = match.level;

			if ( ret === false ) {
				stop = false;
			}
			if ( event.isImmediatePropagationStopped() ) {
				break;
			}
		}
	}

	return stop;
}

function liveConvert( type, selector ) {
	return (type && type !== "*" ? type + "." : "") + selector.replace(rperiod, "`").replace(rspace, "&");
}

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.bind( name, data, fn ) :
			this.trigger( name );
	};

	if ( jQuery.attrFn ) {
		jQuery.attrFn[ name ] = true;
	}
});

// Prevent memory leaks in IE
// Window isn't included so as not to unbind existing unload events
// More info:
//  - http://isaacschlueter.com/2006/10/msie-memory-leaks/
if ( window.attachEvent && !window.addEventListener ) {
	jQuery(window).bind("unload", function() {
		for ( var id in jQuery.cache ) {
			if ( jQuery.cache[ id ].handle ) {
				// Try/Catch is to handle iframes being unloaded, see #4280
				try {
					jQuery.event.remove( jQuery.cache[ id ].handle.elem );
				} catch(e) {}
			}
		}
	});
}


/*!
 * Sizzle CSS Selector Engine - v1.0
 *  Copyright 2009, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function() {
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}
	
	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML( context ),
		parts = [],
		soFar = selector;
	
	// Reset the position of the chunker regexp (start from head)
	do {
		chunker.exec( "" );
		m = chunker.exec( soFar );

		if ( m ) {
			soFar = m[3];
		
			parts.push( m[1] );
		
			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );

	if ( parts.length > 1 && origPOS.exec( selector ) ) {

		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context );

		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}
				
				set = posProcess( selector, set );
			}
		}

	} else {
		// Take a shortcut and set the context if the root selector is an ID
		// (but not if it'll be faster if the inner selector is an ID)
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ?
				Sizzle.filter( ret.expr, ret.set )[0] :
				ret.set[0];
		}

		if ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

			set = ret.expr ?
				Sizzle.filter( ret.expr, ret.set ) :
				ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray( set );

			} else {
				prune = false;
			}

			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}

		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		Sizzle.error( cur || selector );
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );

		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}

		} else {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}

	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function( results ) {
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function( expr, set ) {
	return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
	return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
	var set;

	if ( !expr ) {
		return [];
	}

	for ( var i = 0, l = Expr.order.length; i < l; i++ ) {
		var match,
			type = Expr.order[i];
		
		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			var left = match[1];
			match.splice( 1, 1 );

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace(/\\/g, "");
				set = Expr.find[ type ]( match, context, isXML );

				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = context.getElementsByTagName( "*" );
	}

	return { set: set, expr: expr };
};

Sizzle.filter = function( expr, set, inplace, not ) {
	var match, anyFound,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

	while ( expr && set.length ) {
		for ( var type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
				var found, item,
					filter = Expr.filter[ type ],
					left = match[1];

				anyFound = false;

				match.splice(1,1);

				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}

				if ( curLoop === result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;

					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( var i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							var pass = not ^ !!found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;

								} else {
									curLoop[i] = false;
								}

							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		// Improper expression
		if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );

			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

Sizzle.error = function( msg ) {
	throw "Syntax error, unrecognized expression: " + msg;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],

	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\((even|odd|[\dn+\-]*)\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},

	leftMatch: {},

	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},

	attrHandle: {
		href: function( elem ) {
			return elem.getAttribute( "href" );
		}
	},

	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !/\W/.test( part ),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},

		">": function( checkSet, part ) {
			var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

			if ( isPartStr && !/\W/.test( part ) ) {
				part = part.toLowerCase();

				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
					}
				}

			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},

		"": function(checkSet, part, isXML){
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !/\W/.test(part) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
		},

		"~": function( checkSet, part, isXML ) {
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !/\W/.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
		}
	},

	find: {
		ID: function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		},

		NAME: function( match, context ) {
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [],
					results = context.getElementsByName( match[1] );

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},

		TAG: function( match, context ) {
			return context.getElementsByTagName( match[1] );
		}
	},
	preFilter: {
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
			match = " " + match[1].replace(/\\/g, "") + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n]/g, " ").indexOf(match) >= 0) ) {
						if ( !inplace ) {
							result.push( elem );
						}

					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},

		ID: function( match ) {
			return match[1].replace(/\\/g, "");
		},

		TAG: function( match, curLoop ) {
			return match[1].toLowerCase();
		},

		CHILD: function( match ) {
			if ( match[1] === "nth" ) {
				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
				var test = /(-?)(\d*)n((?:\+|-)?\d*)/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				// calculate the numbers (first)n+(last) including if they are negative
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}

			// TODO: Move to normal caching system
			match[0] = done++;

			return match;
		},

		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
			var name = match[1].replace(/\\/g, "");
			
			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},

		PSEUDO: function( match, curLoop, inplace, result, not ) {
			if ( match[1] === "not" ) {
				// If we're dealing with a complex expression, or a simple one
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);

				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

					if ( !inplace ) {
						result.push.apply( result, ret );
					}

					return false;
				}

			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}
			
			return match;
		},

		POS: function( match ) {
			match.unshift( true );

			return match;
		}
	},
	
	filters: {
		enabled: function( elem ) {
			return elem.disabled === false && elem.type !== "hidden";
		},

		disabled: function( elem ) {
			return elem.disabled === true;
		},

		checked: function( elem ) {
			return elem.checked === true;
		},
		
		selected: function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			elem.parentNode.selectedIndex;
			
			return elem.selected === true;
		},

		parent: function( elem ) {
			return !!elem.firstChild;
		},

		empty: function( elem ) {
			return !elem.firstChild;
		},

		has: function( elem, i, match ) {
			return !!Sizzle( match[3], elem ).length;
		},

		header: function( elem ) {
			return (/h\d/i).test( elem.nodeName );
		},

		text: function( elem ) {
			return "text" === elem.type;
		},
		radio: function( elem ) {
			return "radio" === elem.type;
		},

		checkbox: function( elem ) {
			return "checkbox" === elem.type;
		},

		file: function( elem ) {
			return "file" === elem.type;
		},
		password: function( elem ) {
			return "password" === elem.type;
		},

		submit: function( elem ) {
			return "submit" === elem.type;
		},

		image: function( elem ) {
			return "image" === elem.type;
		},

		reset: function( elem ) {
			return "reset" === elem.type;
		},

		button: function( elem ) {
			return "button" === elem.type || elem.nodeName.toLowerCase() === "button";
		},

		input: function( elem ) {
			return (/input|select|textarea|button/i).test( elem.nodeName );
		}
	},
	setFilters: {
		first: function( elem, i ) {
			return i === 0;
		},

		last: function( elem, i, match, array ) {
			return i === array.length - 1;
		},

		even: function( elem, i ) {
			return i % 2 === 0;
		},

		odd: function( elem, i ) {
			return i % 2 === 1;
		},

		lt: function( elem, i, match ) {
			return i < match[3] - 0;
		},

		gt: function( elem, i, match ) {
			return i > match[3] - 0;
		},

		nth: function( elem, i, match ) {
			return match[3] - 0 === i;
		},

		eq: function( elem, i, match ) {
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function( elem, match, i, array ) {
			var name = match[1],
				filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );

			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || Sizzle.getText([ elem ]) || "").indexOf(match[3]) >= 0;

			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;

			} else {
				Sizzle.error( "Syntax error, unrecognized expression: " + name );
			}
		},

		CHILD: function( elem, match ) {
			var type = match[1],
				node = elem;

			switch ( type ) {
				case "only":
				case "first":
					while ( (node = node.previousSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					if ( type === "first" ) { 
						return true; 
					}

					node = elem;

				case "last":
					while ( (node = node.nextSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					return true;

				case "nth":
					var first = match[2],
						last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}
					
					var doneName = match[0],
						parent = elem.parentNode;
	
					if ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {
						var count = 0;
						
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						} 

						parent.sizcache = doneName;
					}
					
					var diff = elem.nodeIndex - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},

		ID: function( elem, match ) {
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},

		TAG: function( elem, match ) {
			return (match === "*" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;
		},
		
		CLASS: function( elem, match ) {
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},

		ATTR: function( elem, match ) {
			var name = match[1],
				result = Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},

		POS: function( elem, match, i, array ) {
			var name = match[2],
				filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}

var makeArray = function( array, results ) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}
	
	return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch( e ) {
	makeArray = function( array, results ) {
		var i = 0,
			ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );

		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}

			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder, siblingCheck;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			return a.compareDocumentPosition ? -1 : 1;
		}

		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
	};

} else {
	sortOrder = function( a, b ) {
		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// If the nodes are siblings (or identical) we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

	siblingCheck = function( a, b, ret ) {
		if ( a === b ) {
			return ret;
		}

		var cur = a.nextSibling;

		while ( cur ) {
			if ( cur === b ) {
				return -1;
			}

			cur = cur.nextSibling;
		}

		return 1;
	};
}

// Utility function for retreiving the text value of an array of DOM nodes
Sizzle.getText = function( elems ) {
	var ret = "", elem;

	for ( var i = 0; elems[i]; i++ ) {
		elem = elems[i];

		// Get the text from text nodes and CDATA nodes
		if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
			ret += elem.nodeValue;

		// Traverse everything else, except comment nodes
		} else if ( elem.nodeType !== 8 ) {
			ret += Sizzle.getText( elem.childNodes );
		}
	}

	return ret;
};

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
	// We're going to inject a fake input element with a specified name
	var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

	form.innerHTML = "<a name='" + id + "'/>";

	// Inject it into the root element, check its status, and remove it quickly
	root.insertBefore( form, root.firstChild );

	// The workaround has to do additional checks after a getElementById
	// Which slows things down for other browsers (hence the branching)
	if ( document.getElementById( id ) ) {
		Expr.find.ID = function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);

				return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
			}
		};

		Expr.filter.ID = function( elem, match ) {
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );

	// release memory in IE
	root = form = null;
})();

(function(){
	// Check to see if the browser returns only elements
	// when doing getElementsByTagName("*")

	// Create a fake element
	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	// Make sure no comments are found
	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function( match, context ) {
			var results = context.getElementsByTagName( match[1] );

			// Filter out possible comments
			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	// Check to see if an attribute returns normalized href attributes
	div.innerHTML = "<a href='#'></a>";

	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {

		Expr.attrHandle.href = function( elem ) {
			return elem.getAttribute( "href", 2 );
		};
	}

	// release memory in IE
	div = null;
})();

if ( document.querySelectorAll ) {
	(function(){
		var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

		div.innerHTML = "<p class='TEST'></p>";

		// Safari can't handle uppercase or unicode characters when
		// in quirks mode.
		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}
	
		Sizzle = function( query, context, extra, seed ) {
			context = context || document;

			// Make sure that attribute selectors are quoted
			query = query.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

			// Only use querySelectorAll on non-XML documents
			// (ID selectors don't work in non-HTML documents)
			if ( !seed && !Sizzle.isXML(context) ) {
				if ( context.nodeType === 9 ) {
					try {
						return makeArray( context.querySelectorAll(query), extra );
					} catch(qsaError) {}

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					var old = context.getAttribute( "id" ),
						nid = old || id;

					if ( !old ) {
						context.setAttribute( "id", nid );
					}

					try {
						return makeArray( context.querySelectorAll( "#" + nid + " " + query ), extra );

					} catch(pseudoError) {
					} finally {
						if ( !old ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		
			return oldSizzle(query, context, extra, seed);
		};

		for ( var prop in oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}

		// release memory in IE
		div = null;
	})();
}

(function(){
	var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector,
		pseudoWorks = false;

	try {
		// This should fail with an exception
		// Gecko does not error, returns false instead
		matches.call( document.documentElement, "[test!='']:sizzle" );
	
	} catch( pseudoError ) {
		pseudoWorks = true;
	}

	if ( matches ) {
		Sizzle.matchesSelector = function( node, expr ) {
			// Make sure that attribute selectors are quoted
			expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

			if ( !Sizzle.isXML( node ) ) {
				try { 
					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
						return matches.call( node, expr );
					}
				} catch(e) {}
			}

			return Sizzle(expr, null, null, [node]).length > 0;
		};
	}
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	// Opera can't find a second classname (in 9.6)
	// Also, make sure that getElementsByClassName actually exists
	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
		return;
	}

	// Safari caches class attributes, doesn't catch changes (in 3.2)
	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 ) {
		return;
	}
	
	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function( match, context, isXML ) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

	// release memory in IE
	div = null;
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem.sizcache = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;
			
			elem = elem[dir];

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem.sizcache = doneName;
						elem.sizset = i;
					}

					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

if ( document.documentElement.contains ) {
	Sizzle.contains = function( a, b ) {
		return a !== b && (a.contains ? a.contains(b) : true);
	};

} else if ( document.documentElement.compareDocumentPosition ) {
	Sizzle.contains = function( a, b ) {
		return !!(a.compareDocumentPosition(b) & 16);
	};

} else {
	Sizzle.contains = function() {
		return false;
	};
}

Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833) 
	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function( selector, context ) {
	var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

	// Position selectors must be done after the filter
	// And so must :not(positional) so we move all PSEUDOs to the end
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet );
	}

	return Sizzle.filter( later, tmpSet );
};

// EXPOSE
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})();


var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
	// Note: This RegExp should be improved, or likely pulled from Sizzle
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.POS;

jQuery.fn.extend({
	find: function( selector ) {
		var ret = this.pushStack( "", "find", selector ),
			length = 0;

		for ( var i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( var n = length; n < ret.length; n++ ) {
					for ( var r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var targets = jQuery( target );
		return this.filter(function() {
			for ( var i = 0, l = targets.length; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},
	
	is: function( selector ) {
		return !!selector && jQuery.filter( selector, this ).length > 0;
	},

	closest: function( selectors, context ) {
		var ret = [], i, l, cur = this[0];

		if ( jQuery.isArray( selectors ) ) {
			var match, selector,
				matches = {},
				level = 1;

			if ( cur && selectors.length ) {
				for ( i = 0, l = selectors.length; i < l; i++ ) {
					selector = selectors[i];

					if ( !matches[selector] ) {
						matches[selector] = jQuery.expr.match.POS.test( selector ) ? 
							jQuery( selector, context || this.context ) :
							selector;
					}
				}

				while ( cur && cur.ownerDocument && cur !== context ) {
					for ( selector in matches ) {
						match = matches[selector];

						if ( match.jquery ? match.index(cur) > -1 : jQuery(cur).is(match) ) {
							ret.push({ selector: selector, elem: cur, level: level });
						}
					}

					cur = cur.parentNode;
					level++;
				}
			}

			return ret;
		}

		var pos = POS.test( selectors ) ? 
			jQuery( selectors, context || this.context ) : null;

		for ( i = 0, l = this.length; i < l; i++ ) {
			cur = this[i];

			while ( cur ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;

				} else {
					cur = cur.parentNode;
					if ( !cur || !cur.ownerDocument || cur === context ) {
						break;
					}
				}
			}
		}

		ret = ret.length > 1 ? jQuery.unique(ret) : ret;
		
		return this.pushStack( ret, "closest", selectors );
	},
	
	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {
		if ( !elem || typeof elem === "string" ) {
			return jQuery.inArray( this[0],
				// If it receives a string, the selector is used
				// If it receives nothing, the siblings are used
				elem ? jQuery( elem ) : this.parent().children() );
		}
		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context || this.context ) :
				jQuery.makeArray( selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	andSelf: function() {
		return this.add( this.prevObject );
	}
});

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return jQuery.nth( elem, 2, "nextSibling" );
	},
	prev: function( elem ) {
		return jQuery.nth( elem, 2, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( elem.parentNode.firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray( elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );
		
		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 ? jQuery.unique( ret ) : ret;

		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, slice.call(arguments).join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},
	
	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	nth: function( cur, result, dir, elem ) {
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] ) {
			if ( cur.nodeType === 1 && ++num === result ) {
				break;
			}
		}

		return cur;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return (elem === qualifier) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return (jQuery.inArray( elem, qualifier ) >= 0) === keep;
	});
}




var rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnocache = /<(?:script|object|embed|option|style)/i,
	// checked="checked" or checked (html5)
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	raction = /\=([^="'>\s]+\/)>/g,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	};

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "div<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( text ) {
		if ( jQuery.isFunction(text) ) {
			return this.each(function(i) {
				var self = jQuery( this );

				self.text( text.call(this, i, self.text()) );
			});
		}

		if ( typeof text !== "object" && text !== undefined ) {
			return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );
		}

		return jQuery.text( this );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append(this);
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		return this.each(function() {
			jQuery( this ).wrapAll( html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		} else if ( arguments.length ) {
			var set = jQuery(arguments[0]);
			set.push.apply( set, this.toArray() );
			return this.pushStack( set, "before", arguments );
		}
	},

	after: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		} else if ( arguments.length ) {
			var set = this.pushStack( this, "after", arguments );
			set.push.apply( set, jQuery(arguments[0]).toArray() );
			return set;
		}
	},
	
	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					 elem.parentNode.removeChild( elem );
				}
			}
		}
		
		return this;
	},

	empty: function() {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}
		
		return this;
	},

	clone: function( events ) {
		// Do the clone
		var ret = this.map(function() {
			if ( !jQuery.support.noCloneEvent && !jQuery.isXMLDoc(this) ) {
				// IE copies events bound via attachEvent when
				// using cloneNode. Calling detachEvent on the
				// clone will also remove the events from the orignal
				// In order to get around this, we use innerHTML.
				// Unfortunately, this means some modifications to
				// attributes in IE that are actually only stored
				// as properties will not be copied (such as the
				// the name attribute on an input).
				var html = this.outerHTML,
					ownerDocument = this.ownerDocument;

				if ( !html ) {
					var div = ownerDocument.createElement("div");
					div.appendChild( this.cloneNode(true) );
					html = div.innerHTML;
				}

				return jQuery.clean([html.replace(rinlinejQuery, "")
					// Handle the case in IE 8 where action=/test/> self-closes a tag
					.replace(raction, '="$1">')
					.replace(rleadingWhitespace, "")], ownerDocument)[0];
			} else {
				return this.cloneNode(true);
			}
		});

		// Copy the events from the original to the clone
		if ( events === true ) {
			cloneCopyEvent( this, ret );
			cloneCopyEvent( this.find("*"), ret.find("*") );
		}

		// Return the cloned set
		return ret;
	},

	html: function( value ) {
		if ( value === undefined ) {
			return this[0] && this[0].nodeType === 1 ?
				this[0].innerHTML.replace(rinlinejQuery, "") :
				null;

		// See if we can take a shortcut and just use innerHTML
		} else if ( typeof value === "string" && !rnocache.test( value ) &&
			(jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&
			!wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {

			value = value.replace(rxhtmlTag, "<$1></$2>");

			try {
				for ( var i = 0, l = this.length; i < l; i++ ) {
					// Remove element nodes and prevent memory leaks
					if ( this[i].nodeType === 1 ) {
						jQuery.cleanData( this[i].getElementsByTagName("*") );
						this[i].innerHTML = value;
					}
				}

			// If using innerHTML throws an exception, use the fallback method
			} catch(e) {
				this.empty().append( value );
			}

		} else if ( jQuery.isFunction( value ) ) {
			this.each(function(i){
				var self = jQuery( this );

				self.html( value.call(this, i, self.html()) );
			});

		} else {
			this.empty().append( value );
		}

		return this;
	},

	replaceWith: function( value ) {
		if ( this[0] && this[0].parentNode ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		} else {
			return this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value );
		}
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {
		var results, first, fragment, parent,
			value = args[0],
			scripts = [];

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback, true );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call(this, i, table ? self.html() : undefined);
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			parent = value && value.parentNode;

			// If we're in a fragment, just use that instead of building a new one
			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
				results = { fragment: parent };

			} else {
				results = jQuery.buildFragment( args, this, scripts );
			}
			
			fragment = results.fragment;
			
			if ( fragment.childNodes.length === 1 ) {
				first = fragment = fragment.firstChild;
			} else {
				first = fragment.firstChild;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				for ( var i = 0, l = this.length; i < l; i++ ) {
					callback.call(
						table ?
							root(this[i], first) :
							this[i],
						i > 0 || results.cacheable || this.length > 1  ?
							fragment.cloneNode(true) :
							fragment
					);
				}
			}

			if ( scripts.length ) {
				jQuery.each( scripts, evalScript );
			}
		}

		return this;
	}
});

function root( elem, cur ) {
	return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
}

function cloneCopyEvent(orig, ret) {
	var i = 0;

	ret.each(function() {
		if ( this.nodeName !== (orig[i] && orig[i].nodeName) ) {
			return;
		}

		var oldData = jQuery.data( orig[i++] ),
			curData = jQuery.data( this, oldData ),
			events = oldData && oldData.events;

		if ( events ) {
			delete curData.handle;
			curData.events = {};

			for ( var type in events ) {
				for ( var handler in events[ type ] ) {
					jQuery.event.add( this, type, events[ type ][ handler ], events[ type ][ handler ].data );
				}
			}
		}
	});
}

jQuery.buildFragment = function( args, nodes, scripts ) {
	var fragment, cacheable, cacheresults,
		doc = (nodes && nodes[0] ? nodes[0].ownerDocument || nodes[0] : document);

	// Only cache "small" (1/2 KB) strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	if ( args.length === 1 && typeof args[0] === "string" && args[0].length < 512 && doc === document &&
		!rnocache.test( args[0] ) && (jQuery.support.checkClone || !rchecked.test( args[0] )) ) {

		cacheable = true;
		cacheresults = jQuery.fragments[ args[0] ];
		if ( cacheresults ) {
			if ( cacheresults !== 1 ) {
				fragment = cacheresults;
			}
		}
	}

	if ( !fragment ) {
		fragment = doc.createDocumentFragment();
		jQuery.clean( args, doc, fragment, scripts );
	}

	if ( cacheable ) {
		jQuery.fragments[ args[0] ] = cacheresults ? fragment : 1;
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var ret = [],
			insert = jQuery( selector ),
			parent = this.length === 1 && this[0].parentNode;
		
		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
			insert[ original ]( this[0] );
			return this;
			
		} else {
			for ( var i = 0, l = insert.length; i < l; i++ ) {
				var elems = (i > 0 ? this.clone(true) : this).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}
		
			return this.pushStack( ret, name, insert.selector );
		}
	};
});

jQuery.extend({
	clean: function( elems, context, fragment, scripts ) {
		context = context || document;

		// !context.createElement fails in IE with an error but returns typeof 'object'
		if ( typeof context.createElement === "undefined" ) {
			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
		}

		var ret = [];

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" && !rhtml.test( elem ) ) {
				elem = context.createTextNode( elem );

			} else if ( typeof elem === "string" ) {
				// Fix "XHTML"-style tags in all browsers
				elem = elem.replace(rxhtmlTag, "<$1></$2>");

				// Trim whitespace, otherwise indexOf won't work as expected
				var tag = (rtagName.exec( elem ) || ["", ""])[1].toLowerCase(),
					wrap = wrapMap[ tag ] || wrapMap._default,
					depth = wrap[0],
					div = context.createElement("div");

				// Go to html and back, then peel off extra wrappers
				div.innerHTML = wrap[1] + elem + wrap[2];

				// Move to the right depth
				while ( depth-- ) {
					div = div.lastChild;
				}

				// Remove IE's autoinserted <tbody> from table fragments
				if ( !jQuery.support.tbody ) {

					// String was a <table>, *may* have spurious <tbody>
					var hasBody = rtbody.test(elem),
						tbody = tag === "table" && !hasBody ?
							div.firstChild && div.firstChild.childNodes :

							// String was a bare <thead> or <tfoot>
							wrap[1] === "<table>" && !hasBody ?
								div.childNodes :
								[];

					for ( var j = tbody.length - 1; j >= 0 ; --j ) {
						if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
							tbody[ j ].parentNode.removeChild( tbody[ j ] );
						}
					}

				}

				// IE completely kills leading whitespace when innerHTML is used
				if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
					div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
				}

				elem = div.childNodes;
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				ret = jQuery.merge( ret, elem );
			}
		}

		if ( fragment ) {
			for ( i = 0; ret[i]; i++ ) {
				if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
					scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );
				
				} else {
					if ( ret[i].nodeType === 1 ) {
						ret.splice.apply( ret, [i + 1, 0].concat(jQuery.makeArray(ret[i].getElementsByTagName("script"))) );
					}
					fragment.appendChild( ret[i] );
				}
			}
		}

		return ret;
	},
	
	cleanData: function( elems ) {
		var data, id, cache = jQuery.cache,
			special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;
		
		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
				continue;
			}

			id = elem[ jQuery.expando ];
			
			if ( id ) {
				data = cache[ id ];
				
				if ( data && data.events ) {
					for ( var type in data.events ) {
						if ( special[ type ] ) {
							jQuery.event.remove( elem, type );

						} else {
							jQuery.removeEvent( elem, type, data.handle );
						}
					}
				}
				
				if ( deleteExpando ) {
					delete elem[ jQuery.expando ];

				} else if ( elem.removeAttribute ) {
					elem.removeAttribute( jQuery.expando );
				}
				
				delete cache[ id ];
			}
		}
	}
});

function evalScript( i, elem ) {
	if ( elem.src ) {
		jQuery.ajax({
			url: elem.src,
			async: false,
			dataType: "script"
		});
	} else {
		jQuery.globalEval( elem.text || elem.textContent || elem.innerHTML || "" );
	}

	if ( elem.parentNode ) {
		elem.parentNode.removeChild( elem );
	}
}




var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	rdashAlpha = /-([a-z])/ig,
	rupper = /([A-Z])/g,
	rnumpx = /^-?\d+(?:px)?$/i,
	rnum = /^-?\d/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssWidth = [ "Left", "Right" ],
	cssHeight = [ "Top", "Bottom" ],
	curCSS,

	getComputedStyle,
	currentStyle,

	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn.css = function( name, value ) {
	// Setting 'undefined' is a no-op
	if ( arguments.length === 2 && value === undefined ) {
		return this;
	}

	return jQuery.access( this, name, value, true, function( elem, name, value ) {
		return value !== undefined ?
			jQuery.style( elem, name, value ) :
			jQuery.css( elem, name );
	});
};

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity", "opacity" );
					return ret === "" ? "1" : ret;

				} else {
					return elem.style.opacity;
				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"zIndex": true,
		"fontWeight": true,
		"opacity": true,
		"zoom": true,
		"lineHeight": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, origName = jQuery.camelCase( name ),
			style = elem.style, hooks = jQuery.cssHooks[ origName ];

		name = jQuery.cssProps[ origName ] || origName;

		// Check if we're setting a value
		if ( value !== undefined ) {
			// Make sure that NaN and null values aren't set. See: #7116
			if ( typeof value === "number" && isNaN( value ) || value == null ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( typeof value === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra ) {
		// Make sure that we're working with the right name
		var ret, origName = jQuery.camelCase( name ),
			hooks = jQuery.cssHooks[ origName ];

		name = jQuery.cssProps[ origName ] || origName;

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
			return ret;

		// Otherwise, if a way to get the computed value exists, use that
		} else if ( curCSS ) {
			return curCSS( elem, name, origName );
		}
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var old = {};

		// Remember the old values, and insert the new ones
		for ( var name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	},

	camelCase: function( string ) {
		return string.replace( rdashAlpha, fcamelCase );
	}
});

// DEPRECATED, Use jQuery.css() instead
jQuery.curCSS = jQuery.css;

jQuery.each(["height", "width"], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			var val;

			if ( computed ) {
				if ( elem.offsetWidth !== 0 ) {
					val = getWH( elem, name, extra );

				} else {
					jQuery.swap( elem, cssShow, function() {
						val = getWH( elem, name, extra );
					});
				}

				if ( val <= 0 ) {
					val = curCSS( elem, name, name );

					if ( val === "0px" && currentStyle ) {
						val = currentStyle( elem, name, name );
					}

					if ( val != null ) {
						// Should return "auto" instead of 0, use 0 for
						// temporary backwards-compat
						return val === "" || val === "auto" ? "0px" : val;
					}
				}

				if ( val < 0 || val == null ) {
					val = elem.style[ name ];

					// Should return "auto" instead of 0, use 0 for
					// temporary backwards-compat
					return val === "" || val === "auto" ? "0px" : val;
				}

				return typeof val === "string" ? val : val + "px";
			}
		},

		set: function( elem, value ) {
			if ( rnumpx.test( value ) ) {
				// ignore negative width and height values #1599
				value = parseFloat(value);

				if ( value >= 0 ) {
					return value + "px";
				}

			} else {
				return value;
			}
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ?
				(parseFloat(RegExp.$1) / 100) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style;

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// Set the alpha filter to set the opacity
			var opacity = jQuery.isNaN(value) ?
				"" :
				"alpha(opacity=" + value * 100 + ")",
				filter = style.filter || "";

			style.filter = ralpha.test(filter) ?
				filter.replace(ralpha, opacity) :
				style.filter + ' ' + opacity;
		}
	};
}

if ( document.defaultView && document.defaultView.getComputedStyle ) {
	getComputedStyle = function( elem, newName, name ) {
		var ret, defaultView, computedStyle;

		name = name.replace( rupper, "-$1" ).toLowerCase();

		if ( !(defaultView = elem.ownerDocument.defaultView) ) {
			return undefined;
		}

		if ( (computedStyle = defaultView.getComputedStyle( elem, null )) ) {
			ret = computedStyle.getPropertyValue( name );
			if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
				ret = jQuery.style( elem, name );
			}
		}

		return ret;
	};
}

if ( document.documentElement.currentStyle ) {
	currentStyle = function( elem, name ) {
		var left, rsLeft,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			style = elem.style;

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		if ( !rnumpx.test( ret ) && rnum.test( ret ) ) {
			// Remember the original values
			left = style.left;
			rsLeft = elem.runtimeStyle.left;

			// Put in the new values to get a computed value out
			elem.runtimeStyle.left = elem.currentStyle.left;
			style.left = name === "fontSize" ? "1em" : (ret || 0);
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			elem.runtimeStyle.left = rsLeft;
		}

		return ret === "" ? "auto" : ret;
	};
}

curCSS = getComputedStyle || currentStyle;

function getWH( elem, name, extra ) {
	var which = name === "width" ? cssWidth : cssHeight,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight;

	if ( extra === "border" ) {
		return val;
	}

	jQuery.each( which, function() {
		if ( !extra ) {
			val -= parseFloat(jQuery.css( elem, "padding" + this )) || 0;
		}

		if ( extra === "margin" ) {
			val += parseFloat(jQuery.css( elem, "margin" + this )) || 0;

		} else {
			val -= parseFloat(jQuery.css( elem, "border" + this + "Width" )) || 0;
		}
	});

	return val;
}

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		var width = elem.offsetWidth,
			height = elem.offsetHeight;

		return (width === 0 && height === 0) || (!jQuery.support.reliableHiddenOffsets && (elem.style.display || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}




var jsc = jQuery.now(),
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rinput = /^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	rnoContent = /^(?:GET|HEAD)$/,
	rbracket = /\[\]$/,
	jsre = /\=\?(&|$)/,
	rquery = /\?/,
	rts = /([?&])_=[^&]*/,
	rurl = /^(\w+:)?\/\/([^\/?#]+)/,
	r20 = /%20/g,
	rhash = /#.*$/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load;

jQuery.fn.extend({
	load: function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );

		// Don't do a request if no elements are being requested
		} else if ( !this.length ) {
			return this;
		}

		var off = url.indexOf(" ");
		if ( off >= 0 ) {
			var selector = url.slice(off, url.length);
			url = url.slice(0, off);
		}

		// Default to a GET request
		var type = "GET";

		// If the second parameter was provided
		if ( params ) {
			// If it's a function
			if ( jQuery.isFunction( params ) ) {
				// We assume that it's the callback
				callback = params;
				params = null;

			// Otherwise, build a param string
			} else if ( typeof params === "object" ) {
				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
				type = "POST";
			}
		}

		var self = this;

		// Request the remote document
		jQuery.ajax({
			url: url,
			type: type,
			dataType: "html",
			data: params,
			complete: function( res, status ) {
				// If successful, inject the HTML into all the matched elements
				if ( status === "success" || status === "notmodified" ) {
					// See if a selector was specified
					self.html( selector ?
						// Create a dummy div to hold the results
						jQuery("<div>")
							// inject the contents of the document in, removing the scripts
							// to avoid any 'Permission Denied' errors in IE
							.append(res.responseText.replace(rscript, ""))

							// Locate the specified elements
							.find(selector) :

						// If not, just inject the full result
						res.responseText );
				}

				if ( callback ) {
					self.each( callback, [res.responseText, status, res] );
				}
			}
		});

		return this;
	},

	serialize: function() {
		return jQuery.param(this.serializeArray());
	},

	serializeArray: function() {
		return this.map(function() {
			return this.elements ? jQuery.makeArray(this.elements) : this;
		})
		.filter(function() {
			return this.name && !this.disabled &&
				(this.checked || rselectTextarea.test(this.nodeName) ||
					rinput.test(this.type));
		})
		.map(function( i, elem ) {
			var val = jQuery(this).val();

			return val == null ?
				null :
				jQuery.isArray(val) ?
					jQuery.map( val, function( val, i ) {
						return { name: elem.name, value: val };
					}) :
					{ name: elem.name, value: val };
		}).get();
	}
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "), function( i, o ) {
	jQuery.fn[o] = function( f ) {
		return this.bind(o, f);
	};
});

jQuery.extend({
	get: function( url, data, callback, type ) {
		// shift arguments if data argument was omited
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = null;
		}

		return jQuery.ajax({
			type: "GET",
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	},

	getScript: function( url, callback ) {
		return jQuery.get(url, null, callback, "script");
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get(url, data, callback, "json");
	},

	post: function( url, data, callback, type ) {
		// shift arguments if data argument was omited
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = {};
		}

		return jQuery.ajax({
			type: "POST",
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	},

	ajaxSetup: function( settings ) {
		jQuery.extend( jQuery.ajaxSettings, settings );
	},

	ajaxSettings: {
		url: location.href,
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		username: null,
		password: null,
		traditional: false,
		*/
		// This function can be overriden by calling jQuery.ajaxSetup
		xhr: function() {
			return new window.XMLHttpRequest();
		},
		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			script: "text/javascript, application/javascript",
			json: "application/json, text/javascript",
			text: "text/plain",
			_default: "*/*"
		}
	},

	ajax: function( origSettings ) {
		var s = jQuery.extend(true, {}, jQuery.ajaxSettings, origSettings),
			jsonp, status, data, type = s.type.toUpperCase(), noContent = rnoContent.test(type);

		s.url = s.url.replace( rhash, "" );

		// Use original (not extended) context object if it was provided
		s.context = origSettings && origSettings.context != null ? origSettings.context : s;

		// convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Handle JSONP Parameter Callbacks
		if ( s.dataType === "jsonp" ) {
			if ( type === "GET" ) {
				if ( !jsre.test( s.url ) ) {
					s.url += (rquery.test( s.url ) ? "&" : "?") + (s.jsonp || "callback") + "=?";
				}
			} else if ( !s.data || !jsre.test(s.data) ) {
				s.data = (s.data ? s.data + "&" : "") + (s.jsonp || "callback") + "=?";
			}
			s.dataType = "json";
		}

		// Build temporary JSONP function
		if ( s.dataType === "json" && (s.data && jsre.test(s.data) || jsre.test(s.url)) ) {
			jsonp = s.jsonpCallback || ("jsonp" + jsc++);

			// Replace the =? sequence both in the query string and the data
			if ( s.data ) {
				s.data = (s.data + "").replace(jsre, "=" + jsonp + "$1");
			}

			s.url = s.url.replace(jsre, "=" + jsonp + "$1");

			// We need to make sure
			// that a JSONP style response is executed properly
			s.dataType = "script";

			// Handle JSONP-style loading
			var customJsonp = window[ jsonp ];

			window[ jsonp ] = function( tmp ) {
				if ( jQuery.isFunction( customJsonp ) ) {
					customJsonp( tmp );

				} else {
					// Garbage collect
					window[ jsonp ] = undefined;

					try {
						delete window[ jsonp ];
					} catch( jsonpError ) {}
				}

				data = tmp;
				jQuery.handleSuccess( s, xhr, status, data );
				jQuery.handleComplete( s, xhr, status, data );
				
				if ( head ) {
					head.removeChild( script );
				}
			};
		}

		if ( s.dataType === "script" && s.cache === null ) {
			s.cache = false;
		}

		if ( s.cache === false && noContent ) {
			var ts = jQuery.now();

			// try replacing _= if it is there
			var ret = s.url.replace(rts, "$1_=" + ts);

			// if nothing was replaced, add timestamp to the end
			s.url = ret + ((ret === s.url) ? (rquery.test(s.url) ? "&" : "?") + "_=" + ts : "");
		}

		// If data is available, append data to url for GET/HEAD requests
		if ( s.data && noContent ) {
			s.url += (rquery.test(s.url) ? "&" : "?") + s.data;
		}

		// Watch for a new set of requests
		if ( s.global && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Matches an absolute URL, and saves the domain
		var parts = rurl.exec( s.url ),
			remote = parts && (parts[1] && parts[1].toLowerCase() !== location.protocol || parts[2].toLowerCase() !== location.host);

		// If we're requesting a remote document
		// and trying to load JSON or Script with a GET
		if ( s.dataType === "script" && type === "GET" && remote ) {
			var head = document.getElementsByTagName("head")[0] || document.documentElement;
			var script = document.createElement("script");
			if ( s.scriptCharset ) {
				script.charset = s.scriptCharset;
			}
			script.src = s.url;

			// Handle Script loading
			if ( !jsonp ) {
				var done = false;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function() {
					if ( !done && (!this.readyState ||
							this.readyState === "loaded" || this.readyState === "complete") ) {
						done = true;
						jQuery.handleSuccess( s, xhr, status, data );
						jQuery.handleComplete( s, xhr, status, data );

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}
					}
				};
			}

			// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
			// This arises when a base node is used (#2709 and #4378).
			head.insertBefore( script, head.firstChild );

			// We handle everything using the script element injection
			return undefined;
		}

		var requestDone = false;

		// Create the request object
		var xhr = s.xhr();

		if ( !xhr ) {
			return;
		}

		// Open the socket
		// Passing null username, generates a login popup on Opera (#2865)
		if ( s.username ) {
			xhr.open(type, s.url, s.async, s.username, s.password);
		} else {
			xhr.open(type, s.url, s.async);
		}

		// Need an extra try/catch for cross domain requests in Firefox 3
		try {
			// Set content-type if data specified and content-body is valid for this type
			if ( (s.data != null && !noContent) || (origSettings && origSettings.contentType) ) {
				xhr.setRequestHeader("Content-Type", s.contentType);
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[s.url] ) {
					xhr.setRequestHeader("If-Modified-Since", jQuery.lastModified[s.url]);
				}

				if ( jQuery.etag[s.url] ) {
					xhr.setRequestHeader("If-None-Match", jQuery.etag[s.url]);
				}
			}

			// Set header so the called script knows that it's an XMLHttpRequest
			// Only send the header if it's not a remote XHR
			if ( !remote ) {
				xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
			}

			// Set the Accepts header for the server, depending on the dataType
			xhr.setRequestHeader("Accept", s.dataType && s.accepts[ s.dataType ] ?
				s.accepts[ s.dataType ] + ", */*; q=0.01" :
				s.accepts._default );
		} catch( headerError ) {}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false ) {
			// Handle the global AJAX counter
			if ( s.global && jQuery.active-- === 1 ) {
				jQuery.event.trigger( "ajaxStop" );
			}

			// close opended socket
			xhr.abort();
			return false;
		}

		if ( s.global ) {
			jQuery.triggerGlobal( s, "ajaxSend", [xhr, s] );
		}

		// Wait for a response to come back
		var onreadystatechange = xhr.onreadystatechange = function( isTimeout ) {
			// The request was aborted
			if ( !xhr || xhr.readyState === 0 || isTimeout === "abort" ) {
				// Opera doesn't call onreadystatechange before this point
				// so we simulate the call
				if ( !requestDone ) {
					jQuery.handleComplete( s, xhr, status, data );
				}

				requestDone = true;
				if ( xhr ) {
					xhr.onreadystatechange = jQuery.noop;
				}

			// The transfer is complete and the data is available, or the request timed out
			} else if ( !requestDone && xhr && (xhr.readyState === 4 || isTimeout === "timeout") ) {
				requestDone = true;
				xhr.onreadystatechange = jQuery.noop;

				status = isTimeout === "timeout" ?
					"timeout" :
					!jQuery.httpSuccess( xhr ) ?
						"error" :
						s.ifModified && jQuery.httpNotModified( xhr, s.url ) ?
							"notmodified" :
							"success";

				var errMsg;

				if ( status === "success" ) {
					// Watch for, and catch, XML document parse errors
					try {
						// process the data (runs the xml through httpData regardless of callback)
						data = jQuery.httpData( xhr, s.dataType, s );
					} catch( parserError ) {
						status = "parsererror";
						errMsg = parserError;
					}
				}

				// Make sure that the request was successful or notmodified
				if ( status === "success" || status === "notmodified" ) {
					// JSONP handles its own success callback
					if ( !jsonp ) {
						jQuery.handleSuccess( s, xhr, status, data );
					}
				} else {
					jQuery.handleError( s, xhr, status, errMsg );
				}

				// Fire the complete handlers
				if ( !jsonp ) {
					jQuery.handleComplete( s, xhr, status, data );
				}

				if ( isTimeout === "timeout" ) {
					xhr.abort();
				}

				// Stop memory leaks
				if ( s.async ) {
					xhr = null;
				}
			}
		};

		// Override the abort handler, if we can (IE 6 doesn't allow it, but that's OK)
		// Opera doesn't fire onreadystatechange at all on abort
		try {
			var oldAbort = xhr.abort;
			xhr.abort = function() {
				if ( xhr ) {
					// oldAbort has no call property in IE7 so
					// just do it this way, which works in all
					// browsers
					Function.prototype.call.call( oldAbort, xhr );
				}

				onreadystatechange( "abort" );
			};
		} catch( abortError ) {}

		// Timeout checker
		if ( s.async && s.timeout > 0 ) {
			setTimeout(function() {
				// Check to see if the request is still happening
				if ( xhr && !requestDone ) {
					onreadystatechange( "timeout" );
				}
			}, s.timeout);
		}

		// Send the data
		try {
			xhr.send( noContent || s.data == null ? null : s.data );

		} catch( sendError ) {
			jQuery.handleError( s, xhr, null, sendError );

			// Fire the complete handlers
			jQuery.handleComplete( s, xhr, status, data );
		}

		// firefox 1.5 doesn't fire statechange for sync requests
		if ( !s.async ) {
			onreadystatechange();
		}

		// return XMLHttpRequest to allow aborting the request etc.
		return xhr;
	},

	// Serialize an array of form elements or a set of
	// key/values into a query string
	param: function( a, traditional ) {
		var s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction(value) ? value() : value;
				s[ s.length ] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
			};
		
		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings.traditional;
		}
		
		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray(a) || a.jquery ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});
			
		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( var prefix in a ) {
				buildParams( prefix, a[prefix], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join("&").replace(r20, "+");
	}
});

function buildParams( prefix, obj, traditional, add ) {
	if ( jQuery.isArray(obj) && obj.length ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can't currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack's
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + "[" + ( typeof v === "object" || jQuery.isArray(v) ? i : "" ) + "]", v, traditional, add );
			}
		});
			
	} else if ( !traditional && obj != null && typeof obj === "object" ) {
		if ( jQuery.isEmptyObject( obj ) ) {
			add( prefix, "" );

		// Serialize object item.
		} else {
			jQuery.each( obj, function( k, v ) {
				buildParams( prefix + "[" + k + "]", v, traditional, add );
			});
		}
					
	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// This is still on the jQuery object... for now
// Want to move this to jQuery.ajax some day
jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	handleError: function( s, xhr, status, e ) {
		// If a local callback was specified, fire it
		if ( s.error ) {
			s.error.call( s.context, xhr, status, e );
		}

		// Fire the global callback
		if ( s.global ) {
			jQuery.triggerGlobal( s, "ajaxError", [xhr, s, e] );
		}
	},

	handleSuccess: function( s, xhr, status, data ) {
		// If a local callback was specified, fire it and pass it the data
		if ( s.success ) {
			s.success.call( s.context, data, status, xhr );
		}

		// Fire the global callback
		if ( s.global ) {
			jQuery.triggerGlobal( s, "ajaxSuccess", [xhr, s] );
		}
	},

	handleComplete: function( s, xhr, status ) {
		// Process result
		if ( s.complete ) {
			s.complete.call( s.context, xhr, status );
		}

		// The request was completed
		if ( s.global ) {
			jQuery.triggerGlobal( s, "ajaxComplete", [xhr, s] );
		}

		// Handle the global AJAX counter
		if ( s.global && jQuery.active-- === 1 ) {
			jQuery.event.trigger( "ajaxStop" );
		}
	},
		
	triggerGlobal: function( s, type, args ) {
		(s.context && s.context.url == null ? jQuery(s.context) : jQuery.event).trigger(type, args);
	},

	// Determines if an XMLHttpRequest was successful or not
	httpSuccess: function( xhr ) {
		try {
			// IE error sometimes returns 1223 when it should be 204 so treat it as success, see #1450
			return !xhr.status && location.protocol === "file:" ||
				xhr.status >= 200 && xhr.status < 300 ||
				xhr.status === 304 || xhr.status === 1223;
		} catch(e) {}

		return false;
	},

	// Determines if an XMLHttpRequest returns NotModified
	httpNotModified: function( xhr, url ) {
		var lastModified = xhr.getResponseHeader("Last-Modified"),
			etag = xhr.getResponseHeader("Etag");

		if ( lastModified ) {
			jQuery.lastModified[url] = lastModified;
		}

		if ( etag ) {
			jQuery.etag[url] = etag;
		}

		return xhr.status === 304;
	},

	httpData: function( xhr, type, s ) {
		var ct = xhr.getResponseHeader("content-type") || "",
			xml = type === "xml" || !type && ct.indexOf("xml") >= 0,
			data = xml ? xhr.responseXML : xhr.responseText;

		if ( xml && data.documentElement.nodeName === "parsererror" ) {
			jQuery.error( "parsererror" );
		}

		// Allow a pre-filtering function to sanitize the response
		// s is checked to keep backwards compatibility
		if ( s && s.dataFilter ) {
			data = s.dataFilter( data, type );
		}

		// The filter can actually parse the response
		if ( typeof data === "string" ) {
			// Get the JavaScript object, if JSON is used.
			if ( type === "json" || !type && ct.indexOf("json") >= 0 ) {
				data = jQuery.parseJSON( data );

			// If the type is "script", eval it in global context
			} else if ( type === "script" || !type && ct.indexOf("javascript") >= 0 ) {
				jQuery.globalEval( data );
			}
		}

		return data;
	}

});

/*
 * Create the request object; Microsoft failed to properly
 * implement the XMLHttpRequest in IE7 (can't request local files),
 * so we use the ActiveXObject when it is available
 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
 * we need a fallback.
 */
if ( window.ActiveXObject ) {
	jQuery.ajaxSettings.xhr = function() {
		if ( window.location.protocol !== "file:" ) {
			try {
				return new window.XMLHttpRequest();
			} catch(xhrError) {}
		}

		try {
			return new window.ActiveXObject("Microsoft.XMLHTTP");
		} catch(activeError) {}
	};
}

// Does this browser support XHR requests?
jQuery.support.ajax = !!jQuery.ajaxSettings.xhr();




var elemdisplay = {},
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)(.*)$/,
	timerId,
	fxAttrs = [
		// height animations
		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
		// width animations
		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
		// opacity animations
		[ "opacity" ]
	];

jQuery.fn.extend({
	show: function( speed, easing, callback ) {
		var elem, display;

		if ( speed || speed === 0 ) {
			return this.animate( genFx("show", 3), speed, easing, callback);

		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				elem = this[i];
				display = elem.style.display;

				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !jQuery.data(elem, "olddisplay") && display === "none" ) {
					display = elem.style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( display === "" && jQuery.css( elem, "display" ) === "none" ) {
					jQuery.data(elem, "olddisplay", defaultDisplay(elem.nodeName));
				}
			}

			// Set the display of most of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				elem = this[i];
				display = elem.style.display;

				if ( display === "" || display === "none" ) {
					elem.style.display = jQuery.data(elem, "olddisplay") || "";
				}
			}

			return this;
		}
	},

	hide: function( speed, easing, callback ) {
		if ( speed || speed === 0 ) {
			return this.animate( genFx("hide", 3), speed, easing, callback);

		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				var display = jQuery.css( this[i], "display" );

				if ( display !== "none" ) {
					jQuery.data( this[i], "olddisplay", display );
				}
			}

			// Set the display of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				this[i].style.display = "none";
			}

			return this;
		}
	},

	// Save the old toggle function
	_toggle: jQuery.fn.toggle,

	toggle: function( fn, fn2, callback ) {
		var bool = typeof fn === "boolean";

		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
			this._toggle.apply( this, arguments );

		} else if ( fn == null || bool ) {
			this.each(function() {
				var state = bool ? fn : jQuery(this).is(":hidden");
				jQuery(this)[ state ? "show" : "hide" ]();
			});

		} else {
			this.animate(genFx("toggle", 3), fn, fn2, callback);
		}

		return this;
	},

	fadeTo: function( speed, to, easing, callback ) {
		return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({opacity: to}, speed, easing, callback);
	},

	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed(speed, easing, callback);

		if ( jQuery.isEmptyObject( prop ) ) {
			return this.each( optall.complete );
		}

		return this[ optall.queue === false ? "each" : "queue" ](function() {
			// XXX 'this' does not always have a nodeName when running the
			// test suite

			var opt = jQuery.extend({}, optall), p,
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				self = this;

			for ( p in prop ) {
				var name = jQuery.camelCase( p );

				if ( p !== name ) {
					prop[ name ] = prop[ p ];
					delete prop[ p ];
					p = name;
				}

				if ( prop[p] === "hide" && hidden || prop[p] === "show" && !hidden ) {
					return opt.complete.call(this);
				}

				if ( isElement && ( p === "height" || p === "width" ) ) {
					// Make sure that nothing sneaks out
					// Record all 3 overflow attributes because IE does not
					// change the overflow attribute when overflowX and
					// overflowY are set to the same value
					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

					// Set display property to inline-block for height/width
					// animations on inline elements that are having width/height
					// animated
					if ( jQuery.css( this, "display" ) === "inline" &&
							jQuery.css( this, "float" ) === "none" ) {
						if ( !jQuery.support.inlineBlockNeedsLayout ) {
							this.style.display = "inline-block";

						} else {
							var display = defaultDisplay(this.nodeName);

							// inline-level elements accept inline-block;
							// block-level elements need to be inline with layout
							if ( display === "inline" ) {
								this.style.display = "inline-block";

							} else {
								this.style.display = "inline";
								this.style.zoom = 1;
							}
						}
					}
				}

				if ( jQuery.isArray( prop[p] ) ) {
					// Create (if needed) and add to specialEasing
					(opt.specialEasing = opt.specialEasing || {})[p] = prop[p][1];
					prop[p] = prop[p][0];
				}
			}

			if ( opt.overflow != null ) {
				this.style.overflow = "hidden";
			}

			opt.curAnim = jQuery.extend({}, prop);

			jQuery.each( prop, function( name, val ) {
				var e = new jQuery.fx( self, opt, name );

				if ( rfxtypes.test(val) ) {
					e[ val === "toggle" ? hidden ? "show" : "hide" : val ]( prop );

				} else {
					var parts = rfxnum.exec(val),
						start = e.cur() || 0;

					if ( parts ) {
						var end = parseFloat( parts[2] ),
							unit = parts[3] || "px";

						// We need to compute starting value
						if ( unit !== "px" ) {
							jQuery.style( self, name, (end || 1) + unit);
							start = ((end || 1) / e.cur()) * start;
							jQuery.style( self, name, start + unit);
						}

						// If a +=/-= token was provided, we're doing a relative animation
						if ( parts[1] ) {
							end = ((parts[1] === "-=" ? -1 : 1) * end) + start;
						}

						e.custom( start, end, unit );

					} else {
						e.custom( start, val, "" );
					}
				}
			});

			// For JS strict compliance
			return true;
		});
	},

	stop: function( clearQueue, gotoEnd ) {
		var timers = jQuery.timers;

		if ( clearQueue ) {
			this.queue([]);
		}

		this.each(function() {
			// go in reverse order so anything added to the queue during the loop is ignored
			for ( var i = timers.length - 1; i >= 0; i-- ) {
				if ( timers[i].elem === this ) {
					if (gotoEnd) {
						// force the next step to be the last
						timers[i](true);
					}

					timers.splice(i, 1);
				}
			}
		});

		// start the next in the queue if the last step wasn't forced
		if ( !gotoEnd ) {
			this.dequeue();
		}

		return this;
	}

});

function genFx( type, num ) {
	var obj = {};

	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice(0,num)), function() {
		obj[ this ] = type;
	});

	return obj;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show", 1),
	slideUp: genFx("hide", 1),
	slideToggle: genFx("toggle", 1),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.extend({
	speed: function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

		// Queueing
		opt.old = opt.complete;
		opt.complete = function() {
			if ( opt.queue !== false ) {
				jQuery(this).dequeue();
			}
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}
		};

		return opt;
	},

	easing: {
		linear: function( p, n, firstNum, diff ) {
			return firstNum + diff * p;
		},
		swing: function( p, n, firstNum, diff ) {
			return ((-Math.cos(p*Math.PI)/2) + 0.5) * diff + firstNum;
		}
	},

	timers: [],

	fx: function( elem, options, prop ) {
		this.options = options;
		this.elem = elem;
		this.prop = prop;

		if ( !options.orig ) {
			options.orig = {};
		}
	}

});

jQuery.fx.prototype = {
	// Simple function for setting a style value
	update: function() {
		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		(jQuery.fx.step[this.prop] || jQuery.fx.step._default)( this );
	},

	// Get the current size
	cur: function() {
		if ( this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null) ) {
			return this.elem[ this.prop ];
		}

		var r = parseFloat( jQuery.css( this.elem, this.prop ) );
		return r && r > -10000 ? r : 0;
	},

	// Start an animation from one number to another
	custom: function( from, to, unit ) {
		var self = this,
			fx = jQuery.fx;

		this.startTime = jQuery.now();
		this.start = from;
		this.end = to;
		this.unit = unit || this.unit || "px";
		this.now = this.start;
		this.pos = this.state = 0;

		function t( gotoEnd ) {
			return self.step(gotoEnd);
		}

		t.elem = this.elem;

		if ( t() && jQuery.timers.push(t) && !timerId ) {
			timerId = setInterval(fx.tick, fx.interval);
		}
	},

	// Simple 'show' function
	show: function() {
		// Remember where we started, so that we can go back to it later
		this.options.orig[this.prop] = jQuery.style( this.elem, this.prop );
		this.options.show = true;

		// Begin the animation
		// Make sure that we start at a small width/height to avoid any
		// flash of content
		this.custom(this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur());

		// Start by showing the element
		jQuery( this.elem ).show();
	},

	// Simple 'hide' function
	hide: function() {
		// Remember where we started, so that we can go back to it later
		this.options.orig[this.prop] = jQuery.style( this.elem, this.prop );
		this.options.hide = true;

		// Begin the animation
		this.custom(this.cur(), 0);
	},

	// Each step of an animation
	step: function( gotoEnd ) {
		var t = jQuery.now(), done = true;

		if ( gotoEnd || t >= this.options.duration + this.startTime ) {
			this.now = this.end;
			this.pos = this.state = 1;
			this.update();

			this.options.curAnim[ this.prop ] = true;

			for ( var i in this.options.curAnim ) {
				if ( this.options.curAnim[i] !== true ) {
					done = false;
				}
			}

			if ( done ) {
				// Reset the overflow
				if ( this.options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {
					var elem = this.elem,
						options = this.options;

					jQuery.each( [ "", "X", "Y" ], function (index, value) {
						elem.style[ "overflow" + value ] = options.overflow[index];
					} );
				}

				// Hide the element if the "hide" operation was done
				if ( this.options.hide ) {
					jQuery(this.elem).hide();
				}

				// Reset the properties, if the item has been hidden or shown
				if ( this.options.hide || this.options.show ) {
					for ( var p in this.options.curAnim ) {
						jQuery.style( this.elem, p, this.options.orig[p] );
					}
				}

				// Execute the complete function
				this.options.complete.call( this.elem );
			}

			return false;

		} else {
			var n = t - this.startTime;
			this.state = n / this.options.duration;

			// Perform the easing function, defaults to swing
			var specialEasing = this.options.specialEasing && this.options.specialEasing[this.prop];
			var defaultEasing = this.options.easing || (jQuery.easing.swing ? "swing" : "linear");
			this.pos = jQuery.easing[specialEasing || defaultEasing](this.state, n, 0, 1, this.options.duration);
			this.now = this.start + ((this.end - this.start) * this.pos);

			// Perform the next step of the animation
			this.update();
		}

		return true;
	}
};

jQuery.extend( jQuery.fx, {
	tick: function() {
		var timers = jQuery.timers;

		for ( var i = 0; i < timers.length; i++ ) {
			if ( !timers[i]() ) {
				timers.splice(i--, 1);
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
	},

	interval: 13,

	stop: function() {
		clearInterval( timerId );
		timerId = null;
	},

	speeds: {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	},

	step: {
		opacity: function( fx ) {
			jQuery.style( fx.elem, "opacity", fx.now );
		},

		_default: function( fx ) {
			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
				fx.elem.style[ fx.prop ] = (fx.prop === "width" || fx.prop === "height" ? Math.max(0, fx.now) : fx.now) + fx.unit;
			} else {
				fx.elem[ fx.prop ] = fx.now;
			}
		}
	}
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}

function defaultDisplay( nodeName ) {
	if ( !elemdisplay[ nodeName ] ) {
		var elem = jQuery("<" + nodeName + ">").appendTo("body"),
			display = elem.css("display");

		elem.remove();

		if ( display === "none" || display === "" ) {
			display = "block";
		}

		elemdisplay[ nodeName ] = display;
	}

	return elemdisplay[ nodeName ];
}




var rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;

if ( "getBoundingClientRect" in document.documentElement ) {
	jQuery.fn.offset = function( options ) {
		var elem = this[0], box;

		if ( options ) { 
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		try {
			box = elem.getBoundingClientRect();
		} catch(e) {}

		var doc = elem.ownerDocument,
			docElem = doc.documentElement;

		// Make sure we're not dealing with a disconnected DOM node
		if ( !box || !jQuery.contains( docElem, elem ) ) {
			return box || { top: 0, left: 0 };
		}

		var body = doc.body,
			win = getWindow(doc),
			clientTop  = docElem.clientTop  || body.clientTop  || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop  = (win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop ),
			scrollLeft = (win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft),
			top  = box.top  + scrollTop  - clientTop,
			left = box.left + scrollLeft - clientLeft;

		return { top: top, left: left };
	};

} else {
	jQuery.fn.offset = function( options ) {
		var elem = this[0];

		if ( options ) { 
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		jQuery.offset.initialize();

		var computedStyle,
			offsetParent = elem.offsetParent,
			prevOffsetParent = elem,
			doc = elem.ownerDocument,
			docElem = doc.documentElement,
			body = doc.body,
			defaultView = doc.defaultView,
			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
			top = elem.offsetTop,
			left = elem.offsetLeft;

		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
			if ( jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed" ) {
				break;
			}

			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
			top  -= elem.scrollTop;
			left -= elem.scrollLeft;

			if ( elem === offsetParent ) {
				top  += elem.offsetTop;
				left += elem.offsetLeft;

				if ( jQuery.offset.doesNotAddBorder && !(jQuery.offset.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
				}

				prevOffsetParent = offsetParent;
				offsetParent = elem.offsetParent;
			}

			if ( jQuery.offset.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
			}

			prevComputedStyle = computedStyle;
		}

		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
			top  += body.offsetTop;
			left += body.offsetLeft;
		}

		if ( jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed" ) {
			top  += Math.max( docElem.scrollTop, body.scrollTop );
			left += Math.max( docElem.scrollLeft, body.scrollLeft );
		}

		return { top: top, left: left };
	};
}

jQuery.offset = {
	initialize: function() {
		var body = document.body, container = document.createElement("div"), innerDiv, checkDiv, table, td, bodyMarginTop = parseFloat( jQuery.css(body, "marginTop") ) || 0,
			html = "<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";

		jQuery.extend( container.style, { position: "absolute", top: 0, left: 0, margin: 0, border: 0, width: "1px", height: "1px", visibility: "hidden" } );

		container.innerHTML = html;
		body.insertBefore( container, body.firstChild );
		innerDiv = container.firstChild;
		checkDiv = innerDiv.firstChild;
		td = innerDiv.nextSibling.firstChild.firstChild;

		this.doesNotAddBorder = (checkDiv.offsetTop !== 5);
		this.doesAddBorderForTableAndCells = (td.offsetTop === 5);

		checkDiv.style.position = "fixed";
		checkDiv.style.top = "20px";

		// safari subtracts parent border width here which is 5px
		this.supportsFixedPosition = (checkDiv.offsetTop === 20 || checkDiv.offsetTop === 15);
		checkDiv.style.position = checkDiv.style.top = "";

		innerDiv.style.overflow = "hidden";
		innerDiv.style.position = "relative";

		this.subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5);

		this.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== bodyMarginTop);

		body.removeChild( container );
		body = container = innerDiv = checkDiv = table = td = null;
		jQuery.offset.initialize = jQuery.noop;
	},

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		jQuery.offset.initialize();

		if ( jQuery.offset.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},
	
	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = (position === "absolute" && jQuery.inArray('auto', [curCSSTop, curCSSLeft]) > -1),
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is absolute
		if ( calculatePosition ) {
			curPosition = curElem.position();
		}

		curTop  = calculatePosition ? curPosition.top  : parseInt( curCSSTop,  10 ) || 0;
		curLeft = calculatePosition ? curPosition.left : parseInt( curCSSLeft, 10 ) || 0;

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if (options.top != null) {
			props.top = (options.top - curOffset.top) + curTop;
		}
		if (options.left != null) {
			props.left = (options.left - curOffset.left) + curLeft;
		}
		
		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({
	position: function() {
		if ( !this[0] ) {
			return null;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( ["Left", "Top"], function( i, name ) {
	var method = "scroll" + name;

	jQuery.fn[ method ] = function(val) {
		var elem = this[0], win;
		
		if ( !elem ) {
			return null;
		}

		if ( val !== undefined ) {
			// Set the scroll offset
			return this.each(function() {
				win = getWindow( this );

				if ( win ) {
					win.scrollTo(
						!i ? val : jQuery(win).scrollLeft(),
						 i ? val : jQuery(win).scrollTop()
					);

				} else {
					this[ method ] = val;
				}
			});
		} else {
			win = getWindow( elem );

			// Return the scroll offset
			return win ? ("pageXOffset" in win) ? win[ i ? "pageYOffset" : "pageXOffset" ] :
				jQuery.support.boxModel && win.document.documentElement[ method ] ||
					win.document.body[ method ] :
				elem[ method ];
		}
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}




// Create innerHeight, innerWidth, outerHeight and outerWidth methods
jQuery.each([ "Height", "Width" ], function( i, name ) {

	var type = name.toLowerCase();

	// innerHeight and innerWidth
	jQuery.fn["inner" + name] = function() {
		return this[0] ?
			parseFloat( jQuery.css( this[0], type, "padding" ) ) :
			null;
	};

	// outerHeight and outerWidth
	jQuery.fn["outer" + name] = function( margin ) {
		return this[0] ?
			parseFloat( jQuery.css( this[0], type, margin ? "margin" : "border" ) ) :
			null;
	};

	jQuery.fn[ type ] = function( size ) {
		// Get window width or height
		var elem = this[0];
		if ( !elem ) {
			return size == null ? null : this;
		}
		
		if ( jQuery.isFunction( size ) ) {
			return this.each(function( i ) {
				var self = jQuery( this );
				self[ type ]( size.call( this, i, self[ type ]() ) );
			});
		}

		if ( jQuery.isWindow( elem ) ) {
			// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
			return elem.document.compatMode === "CSS1Compat" && elem.document.documentElement[ "client" + name ] ||
				elem.document.body[ "client" + name ];

		// Get document width or height
		} else if ( elem.nodeType === 9 ) {
			// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
			return Math.max(
				elem.documentElement["client" + name],
				elem.body["scroll" + name], elem.documentElement["scroll" + name],
				elem.body["offset" + name], elem.documentElement["offset" + name]
			);

		// Get or set width or height on the element
		} else if ( size === undefined ) {
			var orig = jQuery.css( elem, type ),
				ret = parseFloat( orig );

			return jQuery.isNaN( ret ) ? orig : ret;

		// Set the width or height on the element (default to pixels if value is unitless)
		} else {
			return this.css( type, typeof size === "string" ? size : size + "px" );
		}
	};

});

return jQuery;

})(window);

var $ = jQuery;
// jquery/class/class.js

(function($){


	// if we are initializing a new class
var initializing = false, 
	
	// tests if we can get super in .toString()
	fnTest = /xyz/.test(function(){xyz;}) ? /\b_super\b/ : /.*/,
  	
	// overwrites an object with methods, sets up _super
	inheritProps = function(newProps, oldProps, addTo){
		addTo = addTo || newProps
		for(var name in newProps) {
		  // Check if we're overwriting an existing function
		  addTo[name] = typeof newProps[name] == "function" &&
			typeof oldProps[name] == "function" && fnTest.test(newProps[name]) ?
			(function(name, fn){
			  return function() {
				var tmp = this._super, ret;
			   
				// Add a new ._super() method that is the same method
				// but on the super-class
				this._super = oldProps[name];
			   
				// The method only need to be bound temporarily, so we
				// remove it when we're done executing
				ret = fn.apply(this, arguments);       
				this._super = tmp;
				return ret;
			  };
			})(name, newProps[name]) :
			newProps[name];
		}
	};


/**
* @constructor jQuery.Class
* @plugin jquery/class
* @tag core
* @download dist/jquery/jquery.class.js
* @test jquery/class/qunit.html
* Class provides simulated inheritance in JavaScript. Use $.Class to bridge the gap between
* jQuery's functional programming style and Object Oriented Programming.
* It is based off John Resig's [http://ejohn.org/blog/simple-javascript-inheritance/|Simple Class] 
* Inheritance library.  Besides prototypal inheritance, it includes a few important features:
* <ul>
*     <li>Static inheritance</li>
*     <li>Introspection</li>
*     <li>Namespaces</li>
*     <li>Setup and initialization methods</li>
*     <li>Easy callback function creation</li>
* </ul>
* <h2>Static v. Prototype</h2>
* <p>Before learning about Class, it's important to
* understand the difference between 
* a class's <b>static</b> and <b>prototype</b> properties.
* </p>
* @codestart
* //STATIC
* MyClass.staticProperty  //shared property
* 
* //PROTOTYPE
* myclass = new MyClass()
* myclass.prototypeMethod() //instance method
* @codeend
* <p>A static (or class) property is on the Class constructor
* function itself
* and can be thought of being shared by all instances of the Class.
* Prototype propertes are available only on instances of the Class. 
* </p>
* <h2>A Basic Class</h2>
* <p>The following creates a Monster class with a 
* name (for introspection), static, and prototype members.
* Every time a monster instance is created, the static 
* count is incremented.
* 
* </p>
* @codestart
* $.Class.extend('Monster',
* /* @static *|
* {
*   count: 0
* },
* /* @prototype *|
* {
*   init: function(name){
*     
*     // saves name on the monster instance
*     this.name = name;
*     
*     // sets the health
*     this.health = 10;
*     
*     // increments count
*     this.Class.count++;
*   },
*   eat : function( smallChildren ){
*     this.health += smallChildren;
*   },
*   fight : function(){
*     this.health -= 2;
*   }
* });
* 
* hydra = new Monster('hydra');
* 
* dragon = new Monster('dragon');
* 
* hydra.name        // -> hydra
* Monster.count     // -> 2
* Monster.shortName // -> 'Monster'
* 
* hydra.eat(2);     // health = 12
* 
* dragon.fight();   // health = 8
* 
* @codeend
* 
* <p>
* Notice that the prototype <b>init</b> function is called when a new instance of Monster is created.
* </p>
* <h2>Inheritance</h2>
* <p>When a class is extended, all static and prototype properties are available on the new class.
* If you overwrite a function, you can call the base class's function by calling 
* <code>this._super</code>.  Lets create a SeaMonster class.  SeaMonsters are less 
* efficient at eating small children, but more powerful fighters.
* </p>
* @codestart
* Monster.extend("SeaMonster",{
*   eat : function(smallChildren){
*     this._super(smallChildren / 2);
*   },
*   fight : function(){
*     this.health -= 1;
*   }
* });
* 
* lockNess = new SeaMonster('Lock Ness');
* lockNess.eat(4);   //health = 12
* lockNess.fight();  //health = 11
* @codeend
* <h3>Static property inheritance</h3>
* You can also inherit static properties in the same way:
* @codestart
* $.Class.extend("First",
* {
*     staticMethod : function(){ return 1;}
* },{})
* 
* First.extend("Second",{
*     staticMethod : function(){ return this._super()+1;}
* },{})
* 
* Second.staticMethod() // -> 2
* @codeend
* <h2>Namespaces</h2>
* <p>Namespaces are a good idea! We encourage you to namespace all of your code.  
* It makes it possible to drop your code into another app without problems.  
* Making a namespaced class is easy:
* </p>
* @codestart
* $.Class.extend("MyNamespace.MyClass",{},{});
* 
* new MyNamespace.MyClass()
* @codeend
* <h2 id='introspection'>Introspection</h2>
* Often, it's nice to create classes whose name helps determine functionality.  Ruby on
* Rails's [http://api.rubyonrails.org/classes/ActiveRecord/Base.html|ActiveRecord] ORM class 
* is a great example of this.  Unfortunately, JavaScript doesn't have a way of determining
* an object's name, so the developer must provide a name.  Class fixes this by taking a String name for the class.
* @codestart
* $.Class.extend("MyOrg.MyClass",{},{})
* MyOrg.MyClass.shortName //-> 'MyClass'
* MyOrg.MyClass.fullName //->  'MyOrg.MyClass'
* @codeend
* The fullName (with namespaces) and the shortName (without namespaces) are added to the Class's
* static properties.
* 
* 
* <h2>Setup and initialization methods</h2>
* <p>
* Class provides static and prototype initialization functions. 
* These come in two flavors - setup and init.  
* Setup is called before init and
* can be used to 'normalize' init's arguments.  
* </p>
* <div class='whisper'>PRO TIP: Typically, you don't need setup methods in your classes. Use Init instead.
* Reserve setup methods for when you need to do complex pre-processing of your class before init is called.
* 
* </div>
* @codestart
* $.Class.extend("MyClass",
* {
*   setup: function(){} //static setup
*   init: function(){} //static constructor
* },
* {
*   setup: function(){} //prototype setup
*   init: function(){} //prototype constructor
* })
* @codeend
* 
* <h3>Setup</h3>
* <p>Setup functions are called before init functions.  Static setup functions are passed
* the base class followed by arguments passed to the extend function.
* Prototype static functions are passed the Class constructor function arguments.</p>
* <p>If a setup function returns an array, that array will be used as the arguments
* for the following init method.  This provides setup functions the ability to normalize 
* arguments passed to the init constructors.  They are also excellent places
* to put setup code you want to almost always run.</p>
* <p>
* The following is similar to how [jQuery.Controller.prototype.setup]
* makes sure init is always called with a jQuery element and merged options
* even if it is passed a raw
* HTMLElement and no second parameter.
* </p>
* @codestart
* $.Class.extend("jQuery.Controller",{
*   ...
* },{
*   setup : function(el, options){
*     ...
*     return [$(el), 
*             $.extend(true, 
*                this.Class.defaults,
*                options || {} ) ]
*   }
* })
* @codeend
* Typically, you won't need to make or overwrite setup functions.
* <h3>Init</h3>
* 
* <p>Init functions are called after setup functions.
* Typically, they receive the same arguments 
* as their preceding setup function.  The Foo class's <code>init</code> method
* gets called in the following example:
* </p>
* @codestart
* $.Class.Extend("Foo", {
*   init : function( arg1, arg2, arg3){
*     this.sum = arg1+arg2+arg3;
*   }
* })
* var foo = new Foo(1,2,3);
* foo.sum //-> 6
* @codeend
* <h2>Callbacks</h2>
* <p>Similar to jQuery's proxy method, Class provides a 
* [jQuery.Class.static.callback callback]
* function that returns a callback to a method that will always
* have
* <code>this</code> set to the class or instance of the class.
* </p>
* The following example uses this.callback to make sure 
* <code>this.name</code> is available in <code>show</code>.
* @codestart
$.Class.extend("Todo",{
  init : function(name){ this.name = name }
  get : function(){
    $.get("/stuff",this.callback('show'))
  },
  show : function(txt){
    alert(this.name+txt)
  }
})
new Todo("Trash").get()
* @codeend
* <p>Callback is available as a static and prototype method.</p>
* <h2>Demo</h2>
* @demo jquery/class/class.html
* 
* @init Creating a new instance of an object that has extended jQuery.Class 
*     calls the init prototype function and returns a new instance of the class.
* 
*/

jQuery.Class = function(){ 
	if(arguments.length) this.extend.apply(this, arguments)
};

/* @Static*/
$.extend($.Class,{
	/**
	* @function callback
	* Returns a callback function for a function on this Class.
	* The callback function ensures that 'this' is set appropriately.  
	* @codestart
	* $.Class.extend("MyClass",{
	*     getData : function(){
	*         this.showing = null;
	*         $.get("data.json",this.callback('gotData'),'json')
	*     },
	*     gotData : function(data){
	*         this.showing = data;
	*     }
	* },{});
	* MyClass.showData();
	* @codeend
	* <h2>Currying Arguments</h2>
	* Additional arguments to callback will fill in arguments on the returning function.
	* @codestart
	* $.Class.extend("MyClass",{
	*    getData : function(<b>callback</b>){
	*      $.get("data.json",this.callback('process',<b>callback</b>),'json');
	*    },
	*    process : function(<b>callback</b>, jsonData){ //callback is added as first argument
	*        jsonData.processed = true;
	*        callback(jsonData);
	*    }
	* },{});
	* MyClass.getData(showDataFunc)
	* @codeend
	* <h2>Nesting Functions</h2>
	* Callback can take an array of functions to call as the first argument.  When the returned callback function
	* is called each function in the array is passed the return value of the prior function.  This is often used
	* to eliminate currying initial arguments.
	* @codestart
	* $.Class.extend("MyClass",{
	*    getData : function(callback){
	*      //calls process, then callback with value from process
	*      $.get("data.json",this.callback(['process2',callback]),'json') 
	*    },
	*    process2 : function(type,jsonData){
	*        jsonData.processed = true;
	*        return [jsonData];
	*    }
	* },{});
	* MyClass.getData(showDataFunc);
	* @codeend
	* @param {String|Array} fname If a string, it represents the function to be called.  
	* If it is an array, it will call each function in order and pass the return value of the prior function to the
	* next function.
	* @return {Function} the callback function.
	*/
	callback: function(funcs){
			
		//args that should be curried
		var args = jQuery.makeArray(arguments), 
			self;
			
		funcs = args.shift();
		
		if( !jQuery.isArray(funcs) ) {
			funcs = [funcs];
		}
	
		self = this;
		
		return function class_cb(){
			var cur = args.concat(jQuery.makeArray(arguments)), 
				isString, 
				length = funcs.length,
				f =0, 
				func;
			
			for(; f < length; f++ ) {
				func = funcs[f];
				if( !func ) {
					continue;
				}
				
				isString = typeof func == "string";
				if( isString && self._set_called ) {
					self.called = func;
				}
				cur = ( isString ? self[func] : func ).apply(self, cur || []);
				if( f < length- 1 ){
					cur = !jQuery.isArray(cur) || cur._use_call ? [cur] : cur
				}
			}
			return cur;
		}
	},
	/**
	*   @function setContext 
	*   Set the context variable where to register class names
	*/
	setContext: function(context) {
		this._context = context;
	},
	/**
	*   @function getObject 
	*   Gets an object from a String.
	*   If the object or namespaces the string represent do not
	*   exist it will create them.  
	*   @codestart
	*   Foo = {Bar: {Zar: {"Ted"}}}
	*   $.Class.getobject("Foo.Bar.Zar") //-> "Ted"
	*   @codeend
	*   @param {String} objectName the object you want to get
	*   @param {Object} [current=window] the object you want to look in.
	*   @return {Object} the object you are looking for.
	*/
	getObject: function(objectName, current){
		var current = current || this._context || window,
			parts = objectName  ? objectName.split(/\./) :[],
			i=0;
		for(; i < parts.length; i++){
			current = current[parts[i]] || ( current[parts[i]] = {} )
		}
		return current;
	},
	/**
	 * @function newInstance
	 * Creates a new instance of the class.  This method is useful for creating new instances
	 * with arbitrary parameters.
	 * <h3>Example</h3>
	 * @codestart
	 * $.Class.extend("MyClass",{},{})
	 * var mc = MyClass.newInstance.apply(null, new Array(parseInt(Math.random()*10,10))
	 * @codeend
	 * @return {class} instance of the class
	 */
	newInstance: function(){
		var inst = this.rawInstance(),
			args;
		if ( inst.setup ) {
			args = inst.setup.apply(inst, arguments);
		}
		if ( inst.init ) {
			inst.init.apply(inst, $.isArray(args) ? args : arguments);
		}
		return inst;
	},
	/**
	 * Copy and overwrite options from old class
	 * @param {Object} oldClass
	 * @param {String} fullName
	 * @param {Object} staticProps
	 * @param {Object} protoProps
	 */
	setup: function(oldClass, fullName){
		this.defaults = $.extend(true, {}, oldClass.defaults, this.defaults);
		return arguments;
	},
	rawInstance: function(){
		initializing = true;
		var inst = new this();
		initializing = false;
		return inst;
	},
	/**
	 * Extends a class with new static and prototype functions.  There are a variety of ways
	 * to use extend:
	 * @codestart
	 * //with className, static and prototype functions
	 * $.Class.extend('Task',{ STATIC },{ PROTOTYPE })
	 * //with just classname and prototype functions
	 * $.Class.extend('Task',{ PROTOTYPE })
	 * //With just a className
	 * $.Class.extend('Task')
	 * @codeend
	 * @param {String} [fullName]  the classes name (used for classes w/ introspection)
	 * @param {Object} [klass]  the new classes static/class functions
	 * @param {Object} [proto]  the new classes prototype functions
	 * @return {jQuery.Class} returns the new class
	 */
	extend: function(fullName, klass, proto) {
		// figure out what was passed
		if(typeof fullName != 'string'){
			proto = klass;
			klass = fullName;
			fullName = null;
		}
		if(!proto){
			proto = klass;
			klass = null;
		}
		
		proto = proto || {};
		var _super_class = this,
			_super = this.prototype,
			name,
			shortName, 
			namespace,
			prototype;
			
		// Instantiate a base class (but only create the instance,
		// don't run the init constructor)
		initializing = true;
		prototype = new this();
		initializing = false;
		// Copy the properties over onto the new prototype
		inheritProps(proto, _super, prototype);
		
		// The dummy class constructor
		function Class() {
			// All construction is actually done in the init method
			if(initializing) return;
			
			if(this.constructor !== Class && arguments.length){  //we are being called w/o new
				return this.extend.apply(this, arguments)
			} else {												//we are being called w/ new
				return this.Class.newInstance.apply(this.Class,arguments)
			}
		}
		// Copy old stuff onto class
		for(name in this){
			// BUG: hasOwnProperty returns false on http://api.jquery.com/jQuery.ajax/
			if(this.hasOwnProperty(name) && 
				$.inArray(name,['prototype','defaults','getObject']) == -1){
				Class[name] = this[name];
			}
		}
		
		// do static inheritance
		inheritProps(klass, this, Class);
		
		// do namespace stuff
		if (fullName) {
			
			var parts = fullName.split(/\./),
				shortName =  parts.pop();
				current = $.Class.getObject(parts.join('.')),
				namespace = current;

			
			
			var oldProperties = current[shortName];
			current[shortName] = Class;
			$.extend(current[shortName], oldProperties);
		}
		
		// set things that can't be overwritten
		$.extend(Class,{
			prototype: prototype,
			namespace: namespace,
			shortName: shortName,
			constructor: Class,
			fullName: fullName
		});
		
		//make sure our prototype looks nice
		Class.prototype.Class = Class.prototype.constructor =Class;


		/**
		 * @attribute fullName 
		 * The full name of the class, including namespace, provided for introspection purposes.
		 * @codestart
		 * $.Class.extend("MyOrg.MyClass",{},{})
		 * MyOrg.MyClass.shortName //-> 'MyClass'
		 * MyOrg.MyClass.fullName //->  'MyOrg.MyClass'
		 * @codeend
		 */

		var args = Class.setup.apply(Class, [_super_class].concat( $.makeArray(arguments) ));
	
		if(Class.init) {
			Class.init.apply(Class, args || []);
		}

		/* @Prototype*/
		
		return Class;
		/** 
		 * @function setup
		 * Called with the same arguments as new Class(arguments ...) when a new instance is created.
		 * @codestart
		 * $.Class.extend("MyClass",
		 * {
		 *    setup: function(val){
		 *       this.val = val;
		 *    }
		 * })
		 * var mc = new MyClass("Check Check")
		 * mc.val //-> 'Check Check'
		 * @codeend
		 * 
		 * <div class='whisper'>PRO TIP: 
		 * Setup functions are used to normalize constructor arguments and provide a place for
		 * setup code that extending classes don't have to remember to call _super to
		 * run.
		 * </div>
		 * 
		 * @return {Array|undefined} If an array is return, [jQuery.Class.prototype.init] is 
		 * called with those arguments; otherwise, the original arguments are used.
		 */
		//break up
		/** 
		 * @function init
		 * Called with the same arguments as new Class(arguments ...) when a new instance is created.
		 * @codestart
		 * $.Class.extend("MyClass",
		 * {
		 *    init: function(val){
		 *       this.val = val;
		 *    }
		 * })
		 * var mc = new MyClass("Check Check")
		 * mc.val //-> 'Check Check'
		 * @codeend
		 */
		//Breaks up code
		/**
		 * @attribute Class
		 * References the static properties of the instance's class.
		 * <h3>Quick Example</h3>
		 * @codestart
		 * // a class with a static classProperty property
		 * $.Class.extend("MyClass", {classProperty : true}, {});
		 * 
		 * // a new instance of myClass
		 * var mc1 = new MyClass();
		 * 
		 * //
		 * mc1.Class.classProperty = false;
		 * 
		 * // creates a new MyClass
		 * var mc2 = new mc.Class();
		 * @codeend
		 * Getting static properties via the Class property, such as it's 
		 * [jQuery.Class.static.fullName fullName] is very common.
		 */
	}

})





jQuery.Class.prototype. 
  /**
   * @function callback
   * Returns a callback function.  This does the same thing as and is described better in [jQuery.Class.static.callback].
   * The only difference is this callback works
   * on a instance instead of a class.
   * @param {String|Array} fname If a string, it represents the function to be called.  
   * If it is an array, it will call each function in order and pass the return value of the prior function to the
   * next function.
   * @return {Function} the callback function
   */
  callback = jQuery.Class.callback;

  

})(jQuery);

var com = {};

$.Class.setContext({
	com: com
});
/**
 * User: kapilgoel
 * Date: 6/23/11
 * Time: 4:44 PM
 */

if (!com.watchlr) {
    com.watchlr = {};
}

if (!com.watchlr.system) {
    com.watchlr.system = {};
}

if (!com.watchlr.config) {
    com.watchlr.config = {};
}

if (!com.watchlr.util) {
    com.watchlr.util = {};
}

if (!com.watchlr.hosts) {
    com.watchlr.hosts = {};
}

if (!com.watchlr.hosts.adapters) {
    com.watchlr.hosts.adapters = {};
}

if (!com.watchlr.hosts.defaultEngine) {
    com.watchlr.hosts.defaultEngine = {};
}

if (!com.watchlr.hosts.bing) {
    com.watchlr.hosts.bing = {};
}

if (!com.watchlr.hosts.cbsnews) {
    com.watchlr.hosts.cbsnews = {};
}

if (!com.watchlr.hosts.cnn) {
    com.watchlr.hosts.cnn = {};
}

if (!com.watchlr.hosts.espn) {
    com.watchlr.hosts.espn = {};
}

if (!com.watchlr.hosts.facebook) {
    com.watchlr.hosts.facebook = {};
}

if (!com.watchlr.hosts.google) {
    com.watchlr.hosts.google = {};
}

if (!com.watchlr.hosts.orkut) {
    com.watchlr.hosts.orkut = {};
}

if (!com.watchlr.hosts.vimeo) {
    com.watchlr.hosts.vimeo = {};
}

if (!com.watchlr.hosts.watchlr) {
    com.watchlr.hosts.watchlr = {};
}

if (!com.watchlr.hosts.yahoo) {
    com.watchlr.hosts.yahoo = {};
}

if (!com.watchlr.hosts.youtube) {
    com.watchlr.hosts.youtube = {};
}

if (!com.watchlr.ui) {
    com.watchlr.ui = {};
}

if (!com.watchlr.modalwin) {
    com.watchlr.modalwin = {};
}

var $cws    = com.watchlr.system,
   //  $cwsr   = $cws.runtime,
    $cwc    = com.watchlr.config,
    $cwutil = com.watchlr.util,
    $cwf    = com.watchlr.features,
    $cwa    = com.watchlr.analytics,
    $cwui   = com.watchlr.ui,
    // $cwuiw  = com.watchlr.ui.widgets,
    $cwe    = com.watchlr.error,
    $cwm    = com.watchlr.monetization,
    $cwh    = com.watchlr.hosts,
    // these below are defined in the Bootstraps
    $cwss   = undefined, // $ks.services
    // these are defined in their declarations
    $cwat   = undefined;
/**
 * @package com.watchlr.util
 */
$.Class.extend("com.watchlr.util.Error", {

    ASSERT_OK      : 0,
    ASSERT_ERROR   : 1,
    ASSERT_WARNING : 2,
	
	assert:function(t, fn) {
		t = Boolean(t);
		if(!t && fn) fn();
		return !t;
	}
}, {});



/**
 * @package com.watchlr.util
 */

$.Class.extend("com.watchlr.util.Styles", {
		
	insert: function(styleName, element, _package) {
		// get css styles
		if(!$cws.css[styleName]){
			$cws.css[styleName] = (_package && _package[styleName])?_package[styleName]:'/* stylesheet not found */';
		}
		var css = unescape($cws.css[styleName]);
	
		$cwutil.Styles.insertCss(css, element, styleName);
	},
	
	insertCss: function(css, element, styleName) {
		// find the owner document
		var doc = element.ownerDocument ? element.ownerDocument : element;

        // get the css list
		var listVarName = 'watchlr-css-list';
        var docWindow = null;

        // For IE go through each iframe and find if document of the iframe matches our
        // document we are looking for. In other browsers we can get window object
        // using document.defaultView
        if ($.browser.msie) {
            if (window.document == doc) {
                docWindow = window;
            } else {
                $.get('iframe').each(function(index, value) {
                    if (value.document == doc) docWindow = value;
                });
            }
        } else {
            docWindow = doc.defaultView;
        }

        var list = docWindow[listVarName];
		if (!list) list = docWindow[listVarName] = {};

		// get the head tag
		var head = $(doc).find('head').get(0);
        if (!head) {
            head = doc.body;
        }

		// make sure we don't add twice the same stylesheet
		if (styleName) {
			if (list[styleName]) return;
		} else {
			// create a random style name
			styleName = 'raw_style_'+(new Date().getTime());
		}
		
		// is the user using Internet Explorer?
		// IE maximum css limit is 31 (should never happened)
		if ($.browser.msie) {
			try {
				// Try to use IE functions
				var style = doc.createStyleSheet();
				style.cssText = css;
				
			} catch(e) {
				try {
					// Default to the normal method
					// should even work if we exceed 31 stylesheets
					var style = doc.createElement('style');
					style.type = 'text/css';
					style.cssText = css;
					head.appendChild(style);
				} catch (e2) {}
			}
		} else {
			// for Firefox/Safari user the normal method
            var style = doc.createElement('style');
            style.type = 'text/css';
            style.appendChild(doc.createTextNode(css));
            head.appendChild(style);
		}		
		
		// save this stylename to the list
		list[styleName] = true;
	},
		
	/**
	 * @param {String} css
	 * @return {StyleElement}
	 */
	add:function(css, id){
		var oo = $cwutil.Styles.get(id);
		if(null!=oo){
			return oo;
		}
		
		if($.browser.msie){
			var fAssignStyleId = function(_id){
				if(_id){
					var aStyles = $('head').get(0).find('style');
					aStyles[aStyles.length-1].setAttribute('id',_id);
				}
			};
			//throws "Invalid Argument" exception in IE after 31 stylesheets have been reached on the page
			try {
				oo = document.createStyleSheet();
				oo.cssText = unescape(css);
				fAssignStyleId(id);
			} catch(e) {//after 31 we need to append to an existing sheet					
				try{
					//use this id now
					id = 'CommonStyles';
					
					//find existing CommonStyles sheet
					var oCommon = $cwutil.Styles.get(id);
					//store existing styles
					css += oCommon.innerHTML;
					//remove the sheet
					oCommon.parentNode.removeChild(oCommon);
					
					//create a new sheet 
					oo = document.createStyleSheet();
					oo.cssText = unescape(css);
					
					
					fAssignStyleId(id);
				}catch(e){}
			}
		} else {
			oo = document.createElement('style');
			oo.type = 'text/css';
			$('head').get(0).appendChild(oo);
			if(id) oo.setAttribute('id', id);
			oo.appendChild(document.createTextNode(unescape(css)));
		}
		
		return oo;
	},
	
	/*
	 * Defined later once the first stylesheet is added to the page (see AddStyle)
	 */
	get:function(_id){
		return $('head').get(0).find('#'+_id);
	}
}, {});/**
 * @package com.watchlr.util
 */
$.Class.extend("com.watchlr.util.Url", {
	
	getHostArray: function(_pageUrl){
		var domain = /^http:\/\/([^\/]+)/.exec(_pageUrl);
		if (domain && domain[1]) {
			return domain[1].split(".");
		}
		return null;
	},

	getHost: function(_pageUrl){
	    //Take the last two in reverse order
	    var parts = $cwutil.Url.getHostArray(_pageUrl);
	    if (parts && parts.length > 1) {
	        var host = parts[parts.length - 1] + "." + parts[parts.length - 2];
	        // Terrible hack for bbc.co.uk et al
	        if (host === "uk.co" && parts.length > 2) {
	            host = host + "." + parts[parts.length-3];
	        }
	        return host;
	    }
	    return null;
	},
	
	getHostName: function(_url) {
		var hostName = /^https?:\/\/([^\/]*)/i.exec(_url);
		return hostName ? hostName[1] : null
	},

	getDomainName: function(_pageUrl){
	    //Take the last two in reverse order
	    var parts = $cwutil.Url.getHostArray(_pageUrl);
	    if (parts && parts.length > 1) {
	        var domain = parts[parts.length - 2];
	        // Terrible hack for bbc.co.uk et al
	        if (domain.length < 3 && parts.length >= 3) {
		        var domain = parts[parts.length - 3];
	        }
	        return domain;
	    }
	    return '';
	},
	
	isWebsiteHome: function(_pageUrl) {
		return /^http[s]?:\/\/([^\/]+)\/?([#|\?].*)?$/.test(_pageUrl);
	},
	
	/**
	 * @return {Boolean} - check if to incoming urls are the same once the hash is stripped away
	 */
	isSameHashPage: function(_urlA, _urlB){
		if (!_urlA || !_urlB) return false;
		
		var urlA = (_urlA.indexOf('#') != -1) ? _urlA.substring(0, _urlA.indexOf('#')) : _urlA;
		var urlB = (_urlB.indexOf('#') != -1) ? _urlB.substring(0, _urlB.indexOf('#')) : _urlB;
		
		return urlA == urlB;
	},
	
	isInitUrl: function(_pageUrl) {
		return _pageUrl.indexOf('http://www.init.com') == 0;
	},
	
	isSearchWebsite: function(_pageHost) {
		return _pageHost.indexOf('google.') != -1 || _pageHost.indexOf('bing.') != -1 || _pageHost.indexOf('kikin.') != -1 || _pageHost.indexOf('yahoo.') != -1;
	},
	
	isSearchUrl: function(_pageUrl) {
		var searchPages = ',com.google,com.yahoo,com.bing,de.google,com.kikin',
			currentHost = $cwutil.Url.getHost(_pageUrl || $win.location.href);
		return searchPages.indexOf(currentHost) != -1;
	},
	
	analyzeUrlParams: function(url) {
		if (!url) return null;
		
		var idx = url.indexOf('?');
		if (idx != -1) {
			host = url.substring(0, idx),
			params = url.substring(idx+1);
			var data = params.parseQueryString();
			if (data) {
				// remove some parameters
				if (data.ignore) delete data.ignore;
				if (data.callback) delete data.callback;
				if (data.ksu) delete data.ksu;
				if (data.cId) delete data.cId;
				if (data.resultDataType) delete data.resultDataType;
				if (data.libtype) delete data.libtype;
				
				var newParams = '';
				for (var p in data) {
					if (newParams != '') newParams += '&';
					newParams += p+'='+data[p];
				}
				
				return {
					kpis: data.kpi,
					url: host+'?'+newParams
				};
			}
		}
		return null;
	},
	
	getHashOrUrlParameter: function(name) {
		var part = (top.location.hash && top.location.hash.indexOf(name+'=')) ? top.location.hash : top.location.href;
		return $cwutil.Url.getParameter(name, part);
	},
	
	getParameter: function(name, part){
		var data = new RegExp('[^a-z]'+name+'=([^&]*)', 'i').exec(part);
		if (data && data.length >= 2) {
			return decodeURIComponent(data[1]).replace(/\+/gi, ' ');
		}
		return null;
	},
	
	/**
	 * @param window.location
	 */
	isHomepage: function(_win){
		return _win.protocol + "//" + _win.host + "/" == _win.href
	},
	
	replaceCdnUrls: function(_s) {
		if(typeof(_s)=='string'){
			return _s.replace(/url\(img\//g,'url(http://kikin-dev.com/kikin/img/');	
		}else if(typeof(_s)=='object'){
			for(var xx in _s){
				_s[xx] = $cwutil.Url.replaceCdnUrls(_s[xx]);
			}
			return _s;
		}
		
	}
	
}, {});
$.Class.extend("com.watchlr.config.Locale", {
    'en-US': {
        'DateFormat': {
			'just_now': 'just now',
			'a_minute': '1 minute',
			'minutes': 'minutes',
			'a_hour': '1 Hour',
			'hours': 'hours',
			'a_day': '1 day',
			'days': 'days',
			'a_week': '1 week',
			'weeks': 'weeks',
			'a_month': '1 month',
			'months': 'months',
			'a_while_ago': 'a while',
			'ago': ' ago'
		},
        'KikinVideo':{
            'btnSave': 'Watch Later',
			'btnSaved': 'Watch here!',
            'btnSaving': 'Saving...',
            'like': 'Like',
            'liked': 'Liked!',
			'errorDlgTitle': 'We were unable to save your video :-(',
			'errorDlgMsg': 'To save videos on kikin Video you need to login with Facebook.',
            'errorDlgLikeTitle': 'We were unable to like your video :-(',
			'errorDlgLikeMsg': 'To like videos on kikin Video you need to login with Facebook.',
            'errorDlgUnlikeTitle': 'We were unable to unlike your video :-(',
			'errorDlgUnlikeMsg': 'To unlike videos on kikin Video you need to login with Facebook.'
		}
    },

    DEFAULT_LOCALE: 'en-US',

    get : function(type, name) {
        try {
            var locale = navigator.language;
            if (this[locale]) {
                return $cwc.Locale[locale][type][name];
            } else {
                return $cwc.Locale['en-US'][type][name];
            }
        } catch (err) { return ''; }
    }
}, {});
/**
 * @package com.watchlr.system
 */
$.Class.extend("com.watchlr.system.Config", {}, {
	
	data: null,
	
	/**
	 * @constructor
	 * @param {Object} data
	 */
	init: function(data) {
		this.setConfig(data);
		return this;
	},

	/**
	 * @param {String} name
	 * @method getConfig
	 * @type Object
	 */
	getValue: function(name) {
		if(this.data) return this.data[name];
	},

	/**
	 * @method setConfig
	 * @param {Object} data
	 */
	setConfig: function(data) {
        if(!data) return;
		if(typeof data != 'object') throw new Error('Configuration data must be JSON object.');
		this.data = data;
	}
	
});
/**
 * @package com.watchlr.system
 */
$.Class.extend("com.watchlr.system.Service", {}, {

	config: null,
	
	/**
	 * @param {com.watchlr.system.Config} config
	 */
	setConfig: function(config) {
		if(!config) return;
		if(!(config instanceof $cws.Config)) throw new Error('Object "' + name + '" must be a legitimate configuration object.');
		this.config = config;
	},
	
	/**
	 * @type com.kikin.system.Config
	 */
	getConfig: function() {
        return this.config;
	},
	
	debug:function() {	
		var str = '',
			assertions = this.config.getValue('assertions'),
			E = $cwutil.Error;
		if(!assertions || assertions.length == 0) str += 'No assertion tests defined for this service.\n';
		else assertions.each(function(a, i) { 
			var r = E.assert(a.test.apply(this));
			str += (i+1) + ': ' + a.description + '\t\t';
			if(!r) str += 'OK';
			else if(r && a.priority == E.ASSERT_ERROR) str += 'ERROR' + (a.message ? ' ('+a.message+')' : '');
			else if(r && a.priority == E.ASSERT_WARNING) str += 'WARNING' + (a.message ? ' ('+a.message+')' : '');
			else str += 'ERROR';
			str += '\n';
		}, this);
		return str;
	},
	
	/**
	 * @private
	 * @param {String} name
	 */
	getAdapter: function(name) {
		return $cws.services.getService('HostService').getAdapter(name);
	},
	
	/**
	 * @protected
	 * @param {String} name
	 */
	setAdapter: function(name) {
		this.adapter = new (this.getAdapter(name))(this) || null;
	},
	
	/**
	 * @protected
	 * @param {String} name
	 */
	adapterExists: function(name) {
		return Boolean(this.getAdapter(name)); 
	}
	
});
/**
 * @package com.watchlr.system
 */
$.Class.extend("com.watchlr.system.ServiceDaemon", {}, {

	services: [],
	
	/**
	 * @param {String} name
	 * @param {com.kikin.system.Service} service
	 */
	addService: function(name, service) {
        if(!name || !service) return;
		if(!(service instanceof $cws.Service)) throw new Error('Object "' + name + '" must be a legitimate system service.');
		this.services[name] = service;

        // Set shortcut in $ks
        var shortName = name.match(/^([A-Za-z0-9]+)Service/)[1];
        if (!shortName) throw new Error('[ServiceDaemon] invalid service name');
        $cws[shortName] = service;
	},
	
	/**
	 * @type com.kikin.system.Service
	 * @param {String} name
	 */
	getService: function(name) {
        return this.services[name] || false;
	},
	
	/**
	 * @type Boolean
	 * @param {String} name
	 */
	removeService: function(name) {
		return delete this.services[name];
	}
	
});/**
 * @package com.watchlr.system
 */
$.Class.extend("com.watchlr.system.WatchlrRequests", {
    _WATCHLR_API_URL: 'http://www.watchlr.com//api/',

    sendSaveVideoRequest: function(_callback, _url) {
        var reqUrl = $cws.WatchlrRequests._WATCHLR_API_URL + 'add?callback=?';

        $.ajax({
          url: reqUrl,
          dataType: 'json',
          data: {'url': _url},
          success: _callback
        });
    },

    sendUserProfileRequest: function(_callback) {
        var reqUrl = $cws.WatchlrRequests._WATCHLR_API_URL + 'auth/profile?callback=?';

        $.ajax({
          url: reqUrl,
          dataType: 'json',
          success: _callback
        });
    },

    sendUpdateUserProfileRequest: function(_callback) {
        var reqUrl = $cws.WatchlrRequests._WATCHLR_API_URL + 'auth/profile?callback=?';

        $.ajax({
          url: reqUrl,
          dataType: 'json',
          data: {'notifications': '{"emptyq" : 0}'},
          success: _callback
        });
    },

    sendUpdateUserPreferenceRequest: function(_callback, pushToFacebook) {
        var reqUrl = $cws.WatchlrRequests._WATCHLR_API_URL + 'auth/profile?callback=?';

        $.ajax({
          url: reqUrl,
          dataType: 'json',
          data: {'preferences': '{"syndicate" : ' + pushToFacebook + '}'},
          success: _callback
        });
    },

    sendVideosInfoRequest: function(_callback, _videos) {
        var reqUrl = $cws.WatchlrRequests._WATCHLR_API_URL + 'info?callback=?';


        var _videosString = JSON.stringify(_videos, function(key, value) {
            if (typeof HTMLElement === "object") {
                if(value instanceof HTMLElement) {
                    return undefined;
                }
            } else {
                if (value && typeof value === "object" && value.nodeType === 1 && typeof value.nodeName==="string") {
                    return undefined;
                }
            }
            return value;
        }).replace(/\\\"/g, '\"');
        _videosString = _videosString.substr(1, _videosString.length - 2);
        if (_videosString.indexOf('[') != 0) {
            _videosString = '[' + _videosString + ']';
        }
        $.ajax({
          url: reqUrl,
          dataType: 'json',
          data: {'videos': _videosString},
          success: _callback
        });
    },

    sendVideoLikedRequest: function(_callback, _videoUrl) {
        var reqUrl = $cws.WatchlrRequests._WATCHLR_API_URL + 'like?callback=?';

        $.ajax({
          url: reqUrl,
          dataType: 'json',
          data: {'url': _videoUrl},
          success: _callback
        });
	},

    sendVideoUnlikedRequest: function(_callback, _videoUrl) {
        var reqUrl = $cws.WatchlrRequests._WATCHLR_API_URL + 'unlike?callback=?';

        $.ajax({
          url: reqUrl,
          dataType: 'json',
          data: {'url': _videoUrl},
          success: _callback
        });
	}
}, {});/**
 * @package com.watchlr.ui.modalwin
 * 
 * Watchlr templated iframe window
*/

$.Class.extend("com.watchlr.ui.modalwin.WatchlrIframeWindow", {}, {
    _currentTemplateName: 'popup-flash-alert',
    _parentWindow: null,
    _element: null,
    _body: null,
    _win: null,
    _topDoc: null,
    _contentDiv: null,

    /** init function. */
    init: function() {
		// create the iframe
		this.create();
	},

    /** Create Iframe window. */
    create: function(options) {
        // get needed options
		this._parentWindow = options.parentWindow;

		var frame = this._parentWindow.document.createElement('iframe');
		frame.style.border = '0px';
		frame.style.width = '715px';
		frame.style.height = '500px';
		frame.style.position = 'fixed';
		frame.style.display = 'none';
		frame.style.overflow = 'hidden';
		frame.style.zIndex = '2147483647';
		frame.scrolling = 'no';
		frame.allowtransparency = 'true';
		frame.frameBorder = 0;
        this._parentWindow.document.body.appendChild(frame);
		try {
			// write the default content
			frame.contentWindow.document.open();
			frame.contentWindow.document.write('<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd"><html><head><link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=PT%20Sans"></head><body></body></html>');
			frame.contentWindow.document.close();
		} catch (e) {
			try {
				// It may fail on IE if the page domain was changed. we have to do the following hack to change the IFRAME domain to match the parent.
				frame.src = 'javascript:document.write("<!DOCTYPE HTML PUBLIC \\"-//W3C//DTD HTML 4.01 Frameset//EN\\" \\"http://www.w3.org/TR/html4/frameset.dtd\\"><html><head><script type=\'text/javascript\'>document.domain=\''+document.domain+'\';</script></head><body></body></html>")';
				frame.contentWindow.document.write('<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd"><html><head><link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=PT%20Sans"></head><body></body></html>');
				frame.contentWindow.document.close();
			} catch (e) {
                alert("From: watchlr iframe window base class. \nReason:" + e);
				// $kat.trackError({ from: 'draggable_iframe', exception: e, msg: 'failed to create iframe' });
			}
		}

		this._element = frame;
		this._win = this._element.contentWindow;
		this._doc = this._element.contentWindow.document;
		this._topDoc = top.document;
		this._body = this._doc.body;

		// FIX IE9: body attribute not set yet!
		if (this._body == null) this._body = this._element.contentWindow.document.getElementsByTagName('body')[0];

        // set the bosy and style sheet for iframe
		$cwutil.Styles.insert('WatchlrIframeWindowStyles', this.getDocument());
        $(this.getBody()).html($cws.html['WatchlrIframeWindow']);

        // set content div after setting the body of iframe
        this._contentDiv = this.getElement('.content');
	},

    getDocument: function() {
		return this._doc;
	},

	getWindow: function(){
		return this._win;
	},

    getParentWindow: function(){
		return this._parentWindow;
	},

	getBody: function() {
		return this._body;
	},

    getElements: function(selector) {
		return $(this._body).find(selector);
	},

	getElement: function(selector) {
		if (selector) {
			return $(this._body).find(selector);
		} else {
			return this._element;
		}
	},

    setContent: function(content) {
		$(this._contentDiv).html(content);
	},

    hide: function() {
        $(this._element).fadeOut();
    },

    setSize: function(width, height) {
        $(this._element).width(width + 'px');
        $(this._element).height(height + 'px');
    },

    show: function() {
        this.centerFrame();
        $(this._element).show();
    },

    centerFrame: function(elem) {
        var elemWidth = 0;
        var elemHeight = 0;
        var elemOffset = {top: 0, left: 0};
        if (elem) {
            elemWidth = $(elem).width();
            elemHeight = $(elem).height();
            elemOffset = $(elem).offset();
        } else {
            elemWidth = $(this._parentWindow).width();
            elemHeight = $(this._parentWindow).height();
        }

        var frameWidth = $(this._element).outerWidth();
        var frameHeight = $(this._element).outerHeight();

        var frameLeft = ((elemWidth - frameWidth) / 2) + elemOffset.left;
        var frameTop = ((elemHeight - frameHeight) / 2) + elemOffset.top;
        console.log('watchlr frame position and size:' + frameLeft + ", " + frameTop + ", " + frameWidth + ", " + frameHeight);
        if (frameLeft > 0 && frameTop > 0) {
            $(this._element).css('left', frameLeft);
            $(this._element).css('top', frameTop);
        } else {
            $(this._element).css('left', frameWidth);
            $(this._element).css('top', frameHeight);
        }

        console.log($(this._element).css('left') + ", " + $(this._element).css('top'));
	}/*,

    setTemplate: function(className) {
		// is it an array?
		if (typeof className == 'object') className = className.join(' ');
		// is it the current template ?
		if (className == this._currentTemplateName) return;
		// change template
		this._firstElement.set('class', className);
		this._currentTemplateName = className;
	}  */,

    bind: function(eventName, _callback) {
        $(this._element).bind(eventName, _callback);
    },

    trigger: function(eventName, paramArray) {
        if (paramArray) {
            $(this._element).trigger(eventName, paramArray);
        } else {
            $(this._element).trigger(eventName);
        }
    }
});/**
 * @package com.watchlr.ui.modalwin
 */

$cwui.modalwin.WatchlrIframeWindow.extend("com.watchlr.ui.modalwin.AlertWindow", {}, {
    _title: "",
    _description: "",

    init: function(title, description) {
        this._title = title;
        this._description = description;
        this._super();
    },

    create: function() {
        var elem = $('#watchlr_alert_window');
        if (elem) {
            this._super({
                parentWindow: window
            });

            $(this.getElement()).attr('id', 'watchlr_alert_window');
            $(this.getBody()).attr('id', 'watchlr-alert-window');
            this.setContent($cws.html['AlertWindow']);
            $cwutil.Styles.insert('AlertWindowStyles', this.getDocument());
        } else {
            this._element = $('#watchlr_alert_window');
            this._win = this._element.contentWindow;
            this._doc = this._element.contentWindow.document;
            this._topDoc = top.document;
            this._body = this._doc.body;
        }

        $(this.getElement('a.closeButton')).click($.proxy(this._onCloseCallback, this));
        $(this.getElement('a.okButton')).click($.proxy(this._onCloseCallback, this));

        $(this.getElement('.description')).html(this._description);
        $(this.getElement('.title')).html(this._title);
    },

    show: function() {
        this.setSize(315, 140);
        this._super();
        this.trigger('show');
    },

    _onCloseCallback: function () {
        this.hide();
        this.trigger('close');
    }
});/**
 * @package com.watchlr.ui.modalwin
 */

$cwui.modalwin.WatchlrIframeWindow.extend("com.watchlr.ui.modalwin.FacebookConnectWindow", {}, {
    _windowToBeCenteredToElem: null,

    create: function(elem) {
        if (elem) {
            this._windowToBeCenteredToElem = elem;
        }
        this._super({
			parentWindow: window
		});

        $(this.getBody()).attr('id', 'facebook-connect-window');
        this.setContent($cws.html['FacebookConnectWindow']);
        $cwutil.Styles.insert('FacebookConnectWindowStyles', this.getDocument());

        $(this.getElement('a.closeButton')).click($.proxy(this._onCloseCallback, this));
        $(this.getElement('a.watchlr-fb-connect')).click($.proxy(this._onConnectCallback, this));
        $(this.getElement('#facebook-sign-in')).click($.proxy(this._onConnectCallback, this));
        $(this.getElement('#video-page')).click($.proxy(this._onVisitUserProfilePageCallback, this));
    },

    show: function() {
        this.setSize(375, 185);
        this._super();
        this.trigger('show');
    },

    _onCloseCallback: function () {
        this.hide();
        this.trigger('close');
    },

    _onConnectCallback: function() {
        this.hide();
        this.trigger('connect');
    },

    _onVisitUserProfilePageCallback: function() {
        this.trigger('visituserprofilepage');
    }

});/**
 * @package com.watchlr.ui.modalwin
 */

$cwui.modalwin.WatchlrIframeWindow.extend("com.watchlr.ui.modalwin.VideoSavedWindow", {}, {
    _checked: false,

    create: function() {
        this._super({
            parentWindow: window
        });

        $(this.getBody()).attr('id', 'video-saved-window');
        this.setContent($cws.html['VideoSavedWindow']);
        $cwutil.Styles.insert('VideoSavedWindowStyles', this.getDocument());

        $(this.getElement('a.close-button')).click($.proxy(this._onCloseCallback, this));
        $(this.getElement('a.ok-button')).click($.proxy(this._onOkCallback, this));
        $(this.getElement('#video-page')).click($.proxy(this._onVisitUserProfilePageCallback, this));
        $(this.getElement('#show-message')).click($.proxy(this._onShowMessageClicked, this));
    },
    
    show: function() {
    	this._super();
        this.setSize(375, 230);
        this.trigger('show');
    },

    _onCloseCallback: function () {
        this.hide();
        this.trigger('close', [false]);
    },

    _onOkCallback: function () {
        this.hide();
        this.trigger('close', [this._checked]);
    },

    _onShowMessageClicked: function(e) {
        this._checked = e.target.checked;
    },

    _onVisitUserProfilePageCallback: function() {
        this.trigger('visituserprofilepage');
    }
    
});
/**
 * @package com.watchlr.ui.modalwin
 */

$cwui.modalwin.WatchlrIframeWindow.extend("com.watchlr.ui.modalwin.FirstVideoLikedWindow", {}, {
    _checked: 0,

    create: function() {
        this._super({
            parentWindow: window
        });

        $(this.getBody()).attr('id', 'video-liked-window');
        this.setContent($cws.html['FirstVideoLikedWindow']);
        $cwutil.Styles.insert('FirstVideoLikedWindowStyles', this.getDocument());

        $(this.getElement('a.close-button')).click($.proxy(this._onCloseCallback, this));
        $(this.getElement('a.ok-button')).click($.proxy(this._onOkCallback, this));
        $(this.getElement('#user-profile')).click($.proxy(this._onVisitUserProfilePageCallback, this));
        $(this.getElement('#fb-push-message')).click($.proxy(this._onFacebookPushMessageClicked, this));
    },
    
    show: function() {
    	this._super();
        this.setSize(385, 222);
        this.trigger('show');
    },

    _onCloseCallback: function () {
        this.hide();
        this.trigger('close', ['2']);
    },

    _onOkCallback: function () {
        this.hide();
        this.trigger('close', ['' + this._checked]);
    },

    _onFacebookPushMessageClicked: function(e) {
        this._checked = (e.target.checked ? 1 : 0);
    },

    _onVisitUserProfilePageCallback: function() {
        this.trigger('visituserprofilepage');
    }
    
});
/**
 * @package com.watchlr.config
 */

$.Class.extend("com.watchlr.config.HostsConfig", {
    DEFAULT_URL_THRESHOLD: 7,
	supportedEngines: {
        'defaultEngine': {
            'package': $cwh.defaultEngine
        },
	    'com.cnn': {
		    'package': $cwh.cnn
		},
		'com.watchlr': {
			'package': $cwh.watchlr
		},
		/*'com.bing': {
			'package': $kh.bing,
			bindings: []
		},*/
		'com.youtube': {
			'package': $cwh.youtube
		},
        'com.vimeo': {
			'package': $cwh.vimeo
		},
        'com.go.espn': {
		    'package': $cwh.espn
		},
        'com.foxsports': {
		    'package': $cwh.foxsports
		},
        'com.cbsnews': {
		    'package': $cwh.cbsnews
		},
		'com.facebook': {
			'package': $cwh.facebook
		},
		'br.com.orkut': {
			'package': $cwh.orkut
		},
		'com.orkut': {
			'package': $cwh.orkut
		},
		'com.google': {
			'package': $cwh.google,
			bindings: [
				{
					urlMatch: /video.google./i,
					category: "video",
					threshold: 7
				},
				{
					urlMatch: /search[\w\W]*&oi=video/i,
					category: "video",
					threshold: 7
				},
				{
					urlMatch: /www.myvideo./i,
					category: "video",
					threshold: 7
				},
				{
					urlMatch: /www.clipfish.de/i,
					category: "video",
					threshold: 7
				},
				{
					urlMatch: /www.google.[a-z]*\/products/i,
					category: "product",
					threshold: 7
				},
				{
					urlMatch: /maps.google.[a-z]{2,}\/maps\/place/i,
					category: "location",
					threshold: 7
				},
				{
					urlMatch: /maps.google.[a-z]{2,}\/maps[\w\W]*&oi=local/i,
					category: "location",
					threshold: 7
				},
				{
					urlMatch: /search\?(.)*&tbs=nws/i,
					category: "news",
					threshold: 7
				},
				{
					urlMatch: /search\?(.)*&tbs=shop/i,
					category: "product",
					threshold: 7
				},
				{
					urlMatch: /search\?(.)*&tbs=vid/i,
					category: "video",
					threshold: 7
				},
				{
					urlMatch: /search\?(.)*&tbs=plcs/i,
					category: "location",
					threshold: 7
				},
				{
					urlMatch: /search\?(.)*&tbs=isch/i,
					category: "images",
					threshold: 7
				}
			]
		},
		'com.yahoo': {
			'package': $cwh.yahoo,
			bindings: [
				{
					urlMatch: /news.search.yahoo.[a-z]*\/search\/news/i,
					category: 'news',
					threshold: 7
				},
				{
					urlMatch: /video.search.yahoo.[a-z]*\/search\/video/i,
					category: "video",
					threshold: 7
				},
				{
					urlMatch: /shopping.yahoo.[a-z]*/i,
					category: "product",
					threshold: 7
				},
				{
					urlMatch: /[a-z]*.shopping.com*/i,
					category: "product",
					threshold: 7
				},
				{
					urlMatch: /[a-z]*.ebay.com*/i,
					category: "product",
					threshold: 7
				},
				{
					urlMatch: /local.yahoo.[a-z]*/i,
					category: "location",
					threshold: 7
				},
				{
					urlMatch: /news.yahoo.[a-z]*/i,
					category: "news",
					threshold: 7
				}
			]
		}
	}
}, {});
/**
 * @package com.watchlr.hosts
 */

$cws.Service.extend("com.watchlr.hosts.Host", {}, {

    adapters: {},
	
	init: function(config) {
        this.setConfig(config);
		this.loadAdapters();
	},
	
	/**
	 * @private
	 */
	loadAdapters: function() {
		var conf = this.getConfig(),
			pck = conf ? conf.getValue('package') : null;
        if(pck && pck.adapters) this.adapters = pck.adapters;
	},
	
	/**
	 * @type com.watchlr.features.PluginAdapter
	 * @param {Object} name
	 */
	getAdapter: function(name) {
        return this.adapters[name] || false;
	}
	
});/**
 * @package com.watchlr.hosts
 */

$.Class.extend("com.watchlr.hosts.HostController", {

}, {

    _hostName: null,

	host: null,
	
	/**
	 * @constructor
	 */
	init: function() {
		this._setHostService();
	},
	
	/**
	 * @protected
	 */
	_setHostService: function(){
		this.setDefaultHost();
		$cws.services.addService('HostService', this.host);
	},
	
	/**
	 * @protected
	 * @return {String}
	 */
	_getHost: function(_pageUrl){
        //Take the last two in reverse order
        var parts = $cwutil.Url.getHostArray(_pageUrl);
        if (parts && parts.length > 1) {
            var host = parts[parts.length - 1] + "." + parts[parts.length - 2];
            // Terrible hack for bbc.co.uk et al
            if ((host === "uk.co" || host === "br.com" || host === "com.go") && parts.length > 2) {
                host = host + "." + parts[parts.length-3];
            }
            // Terrible hack for getting any google site to be com.google
            if (host.indexOf('.google') != -1) {
            	host = 'com.google';
            }

            return host;
        }
        return null;
	},
	

	/**
	 * @protected
	 * @return {String}
	 */
	_getFullHost: function(_pageUrl){
		var parts = $cwutil.Url.getHostArray(_pageUrl);
		return (parts)?parts.reverse().join('.'):null;
	},
	
	/**
	 * 
	 */
	_setHost: function(_host){
		this._hostName = _host;
	},
	
	/**
	 * @private
	 */
	setDefaultHost: function() {

        // use the current location because the config object cannot be trusted!
        var sNewHost = this._getHost(window.location.href);
        if (sNewHost) this._setHost(sNewHost);
    		
        var supported = $cwc.HostsConfig.supportedEngines,
            engineConfig = supported ? supported[sNewHost] : null;

        if (!sNewHost) {
            throw new Error('Cannot determine host.');
        } else if (supported[sNewHost] && supported[sNewHost]['package']) {
            this.host = new $cwh.Host(new $cws.Config(supported[sNewHost]));
        } else if (supported['defaultEngine'] && supported['defaultEngine']['package']) {
            this.host = new $cwh.Host(new $cws.Config(supported['defaultEngine']));
        } else {
            this.host = new $cwh.Host;
        }
    }

});/**
 * @package com.watchlr.hosts.adapters
 * Site specific stuff
 */

$.Class.extend("com.watchlr.hosts.adapters.KikinSiteAdapter", {
    getInstance: function() {
        try {
            if (!this._instance) {
                var adapter = $cws.services.getService('HostService').getAdapter('KikinSiteAdapter');
                this._instance = adapter ? new adapter() : null;
            }

            return this._instance;
        }
        catch (err) {}
    }
}, {

});/**
 * @package com.watchlr.hosts.adapters
 */

$.Class.extend("com.watchlr.hosts.adapters.InSituVideoAdapter", {
    stats : {
        reset: function() {
            this.supported = 0;
            this.notSupported = 0;
            this.unsupportedDomains = [];
            return this;
        },
        toLogString: function() {
            if (this.supported == 0 && this.notSupported == 0) {
                return '';
            } else {
                return 'InSituVideoFeature:'+
                        'organic='+(this.supported+this.notSupported)+
                        ',organic_annotated='+this.supported;
            }
        },
        supported: 0,
        notSupported: 0,
        unsupportedDomains: []
    }
}, {

	initialize: function() {
		var adapter = $cws.services.getService('HostService').getAdapter('InSituVideoAdapter');
		return adapter ? new adapter() : null;
	},
	attach: function(analytics) {}
});
$.Class.extend("com.watchlr.hosts.adapters.KikinVideoAdapter", {
    getInstance : function() {
        if (!this._instance) {
            var adapter = $cws.services.getService('HostService').getAdapter('KikinVideoAdapter');
            this._instance = adapter ? new adapter() : null;
        }

        return this._instance;
    },
    stats : {
        reset: function() {
            this.enabled = 0;
            return this;
        },
        toLogString: function() {
            if (this.enabled == 0) {
                return '';
            } else {
                return 'KikinVideoAdapter:annotated='+this.enabled;
            }
        }
    }
}, {
    BORDER_WIDTH : 5,
    WATCHLR_COM : 'http://www.watchlr.com//',
    _popupMonitor : null,
    _connectionPopup : null,

    /**
    * list of videos on the page
    */
    videos: [],

    /** currently selected video. */
    selectedVideo: null,

    /** number of kikin supported videos found on page. */
    _videosFound : 0,

    /** div tag to create border around video. */
    kikinVideoBorder: null,

    _showFbPushDialog: false,

    /** list of services supported by kikin. */
    services : [
        {
            domains: ['youtube.com', 's.ytimg.com', 'youtube-nocookie.com'],
            source_regex: [/youtube.com\/v\/([\_\-a-zA-Z0-9]+)/, /youtube\.com\/embed\/([\_\-a-zA-Z0-9]+)/, /youtube-nocookie.com\/v\/([\_\-a-zA-Z0-9]+)/],
            flash_regex: [/&video_id=([\_\-a-zA-Z0-9]+)/i],
            url_regex: [/youtube\.com\/watch\?v=([\_\-a-zA-Z0-9]+)/i],
            url: 'http://www.youtube.com/watch?v='
        },
        {
            domains: ['vimeo.com', 'vimeocdn.com'],
            source_regex: [/vimeo\.com\/video\/([0-9]+)/i, /vimeo\.com\/moogaloop\.swf.*clip_id=([0-9]+)/i],
            flash_regex: [/&clip_id=([0-9]+)/i],
            url_regex: [/vimeo\.com\/([0-9]+)/i],
            url: 'http://www.vimeo.com/'
        },
        {
            domains: ['facebook.com'],
            source_regex: [],
            flash_regex: [/video_id=([0-9]+)/],
            url_regex: [/facebook\.com\/video\/video\.php\?v=([0-9]+)/i],
            url: 'http://www.facebook.com/v/'
        },
        {
            domains: ['cdn.turner.com/cnn', 'cdn.turner.com/money'],
            source_regex: [/videoId=([^&]+)/i, /video\/(.+)d+xd+\.jpg/i, /money\/video\/(.+)d+xd+\.jpg/i],
            flash_regex: [/contentId=([^&]+)/i],
            url_regex: [/cnn\.com\/video\/.\/video\/([^&]+)/i],
            url: 'http://www.cnn.com/video/?/video/'
        },
        /*
        {
            domains: ['justin.tv'],
            source_regex: [],
            flash_regex: [/(channel=([^&]+).*&archive_id=([0-9]+))|(archive_id=([0-9]+).*&channel=([^&]+))/i],
            url_regex: [/justin.tv\/([^&]+).*\/b\/([0-9]+)/i],
            url: function(x) {
                if (x[5]) {
                    var channel = x[6], archive = x[5];
                } else {
                    var channel = x[2], archive = x[3];
                }
                return 'http://www.justin.tv/' + channel + '/b/' + archive;
            }
        },
        */
        {
            domains: ['ustream.tv'],
            source_regex: [],
            flash_regex: [/channelid=([^&]+)/i, /cid=([^&]+)/i],
            url_regex: [/ustream\.tv\/channel\/([^&]+)/i],
            url: 'http://www.ustream.tv/channel/'
        },
        {
            domains: ['ustream.tv'],
            source_regex: [],
            flash_regex: [/vid=([0-9]+)/i],
            url_regex: [/ustream\.tv\/recorded\/([0-9]+)/i],
            url: 'http://www.ustream.tv/recorded/'
        },
        {
            domains: ['revision3.com'],
            source_regex: [/revision3\.com\/player/],
            flash_regex: [],
            url_regex: [/(http:\/\/revision3\.com\/.*)/i],
            use_location: true,
            location_regex: /revision3\.com\/[a-zA-Z0-9]+\/[a-zA-Z0-9]+(\/|\?.*|$)$/,
            url: ''
        },
        /*
        {
            domains: ['dailymotion.com'],
            source_regex: [/dailymotion\.com\/swf\/video\/([a-zA-Z0-9]+)/, /dailymotion\.com\/swf\/([a-zA-Z0-9]+)/, /dailymotion\.com\/.*\/video\/([a-zA-Z0-9]+)\.mp4/],
            flash_regex: [/"videoId":"([a-zA-Z0-9]+)"/, /www.dailymotion.com\/video\/([a-zA-Z0-9]+)_/],
            url_regex: [/dailymotion\.com\/video\/([a-zA-Z0-9_\-]+)/],
            url: 'http://www.dailymotion.com/video/'
        },
        {
            domains: ['collegehumor.com'],
            source_regex: [/clip_id=([0-9]+)/i],
            flash_regex: [/clip_id=([0-9]+)/i],
            url_regex: [/collegehumor\.com\/video:([0-9]+)/i],
            url: 'http://www.collegehumor.com/video/'
        },
        */
        {
            domains: ['twitvid.com'],
            source_regex: [/twitvid.com\/player\/([A-Z0-9]+)/],
            flash_regex: [/twitvid.com\/playVideo_([A-Z0-9]+)/],
            url_regex: [/twitvid\.com\/([A-Z0-9]+)/],
            url: 'http://www.twitvid.com/'
        },
        /*
        {
            domains: ['break.com'],
            source_regex: [],
            flash_regex: [/sLink=(.*)&EmbedSEOLinkKeywords/],
            url_regex: [/(http:\/\/.*\.break\.com\/.*)/i],
            url: ''
        },
        {
            domains: ['myspace.com/videos'],
            source_regex: [/&amp;el=(.*)&amp;on/, /&el=(.*)&on/],
            flash_regex: [],
            url_regex: [/(http:\/\/www\.myspace.com\/index\.cfm\?fuseaction=.*&videoid.*)/, /(http:\/\/vids\.myspace\.com\/index\.cfm\?fuseaction=vids\.individual&videoid.*)/],
            url: ''
        },
        {
            domains: ['mediaservices.myspace.com'],
            source_regex: [/embed\.aspx\/m=([0-9]+)/],
            flash_regex: [],
            url_regex: [/myspace\.com\/video\/vid\/([0-9]+)/i],
            url: 'http://www.myspace.com/video/vid/'
        },
        {
            // metacafe
            domains: ['mcstatic.com'],
            source_regex: [],
            flash_regex: [/pageURL=([^&]+)/],
            url: ''
        },
        {
            domains: ['metacafe.com'],
            source_regex: [/metacafe\.com\/fplayer\/([0-9]+)\//],
            flash_regex: [],
            url_regex: [/metacafe\.com\/watch\/([0-9]+)/i],
            url: 'http://www.metacafe.com/watch/'
        },
        */
        {
            domains: ['blip.tv'],
            source_regex: [/http:\/\/blip\.tv\/play\/([A-Za-z0-9]+)/],
            flash_regex: [],
            url_regex: [/blip\.tv\/players\/episode\/([A-Za-z0-9]+)/],
            url: 'http://blip.tv/players/episode/'
        },
        {
            domains: ['blip.tv'],
            source_regex: [/blip\.tv\/scripts\/flash\/stratos\.swf/],
            flash_regex: [],
            url_regex: [/(http:\/\/blip\.tv\/file\/[0-9]+)/i],
            use_location: true,
            location_regex: /blip\.tv\/[\-a-z]+\/[\-a-z0-9]+/,
            url: ''
        },
        /*
        {
            domains: ['video.google.com'],
            source_regex: [/docid=([\-0-9]+)/i],
            flash_regex: [],
            url_regex: [/video\.google\.com\/videoplay\?docid=([\-0-9]+)/i],
            url: 'http://video.google.com/videoplay?docid='
        },
        {
            domains: ['revver.com'],
            source_regex: [/mediaId=([0-9]+)/],
            flash_regex: [/mediaId=([0-9]+)/],
            url_regex: [/revver\.com\/video\/([0-9]+)/i],
            url: 'http://revver.com/video/'
        },
        {
            domains: ['viddler.com'],
            source_regex: [/viddler\.com\/player/],
            flash_regex: [],
            url_regex: [/(http:\/\/.*viddler\.com\/explore\/.*\/videos\/.*)/i],
            use_location: true,
            location_regex: /viddler\.com\/explore\/.+?\/videos\/.+/,
            url: ''
        },
        {
            domains: ['liveleak.com'],
            source_regex: [/liveleak\.com\/e\/([0-9a-z]+_[0-9]+)/],
            flash_regex: [/token=([0-9a-z]+_[0-9]+)/],
            url_regex: [/liveleak\.com\/view\?i=([0-9a-z]+_[0-9]+)/i],
            url: 'http://liveleak.com/view?i='
        },
        {
            domains: ['dotsub.com'],
            source_regex: [/dotsub\.com\/media\/([\-0-9a-z]+)/],
            flash_regex: [/uuid=([\-0-9a-z]+)/],
            url_regex: [/dotsub\.com\/view\/([\-0-9a-z]+)/i],
            url: 'http://dotsub.com/view/'
        },
        {
            domains: ['overstream.net'],
            source_regex: [],
            flash_regex: [/oid=([0-9a-z]+)/],
            url_regex: [/overstream\.net\/view\.php\?oid=([0-9a-z]+)/i],
            url: 'http://www.overstream.net/view.php?oid='
        },
        {
            domains: ['livestream.com'],
            source_regex: [],
            flash_regex: [/(channel=([^&]+).*&clip=([_\-a-zA-Z0-9]+))|(clip=([_\-a-zA-Z0-9]+).*&channel=([^&]+))/i],
            url_regex: [/livestream\.com\/([^&]+)\/video\?clipId=\/([_\-a-zA-Z0-9]+)/],
            url: function(x) {
                if (x[5]) {
                    var channel = x[6], clip = x[5];
                } else {
                    var channel = x[2], clip = x[3];
                }
                return 'http://www.livestream.com/' + channel + '/video?clipId=' + clip;
            }
        },
        {
            domains: ['worldstarhiphop.com'],
            source_regex: [/worldstarhiphop\.com\/videos\/e\/[0-9]+\/(wshh[a-zA-Z0-9]+)/],
            flash_regex: [/vl=(wshh[a-zA-Z0-9]+)/],
            url_regex: [/worldstarhiphop\.com\/videos\/video\.php\?v=(wshh[a-zA-Z0-9]+)/i],
            url: 'http://www.worldstarhiphop.com/videos/video.php?v='
        },
        {
            domains: ['teachertube.com'],
            source_regex: [],
            flash_regex: [/pg=video_([0-9]+)/],
            url_regex: [/teachertube\.com\/viewVideo\.php\?video_id=([0-9]+)/i],
            url: 'http://www.teachertube.com/viewVideo.php?video_id='
        },
        {
            domains: ['teachertube.com'],
            source_regex: [],
            flash_regex: [/viewKey=([A-Z0-9]+)/i],
            url_regex: [/teachertube\.com\/view_video\.php\?viewkey=([A-Z0-9]+)/i],
            url: 'http://www.teachertube.com/view_video.php?viewkey='
        },
        {
            domains: ['bambuser.com'],
            source_regex: [/vid=([0-9]+)/],
            flash_regex: [],
            url_regex: [/bambuser\.com\/v\/([0-9]+)/i, /bambuser\.com\/.*\/([0-9]+)/i],
            url: 'http://www.bambuser.com/v/'
        },
        {
            domains: ['schooltube.com'],
            source_regex: [/schooltube\.com\/v\/[a-z0-9]+/],
            flash_regex: [],
            url_regex: [/(http:\/\/www\.schooltube\.com\/video\/[a-z0-9]+\/[\-a-zA-Z0-9]+)/i],
            use_location: true,
            location_regex: /schooltube\.com\/video\/[a-z0-9]+\/[\-a-zA-Z0-9]+/,
            url: ''
        },
        */
        {
            domains: ['bigthink.com'],
            source_regex: [/embeds\/video_idea\/([0-9]+)/],
            flash_regex: [],
            url_regex: [/bigthink\.com\/ideas\/([0-9]+)/i],
            url: 'http://www.bigthink.com/ideas/'
        },
        {
            domains: ['brightcove.com'],
            source_regex: [/brightcove\.com\/.+?&playerID=651017566001&/],
            flash_regex: [],
            use_location: true,
            location_regex: /bigthink\.com\/ideas\/[0-9]+/
        },
        {
            domains: ['brightcove.com'],
            source_regex: [/brightcove\.com\/.+?&playerID=651017566001&/],
            flash_regex: [],
            use_location: true,
            location_regex: /bigthink\.com\/series\/[0-9]+/
        },
        /*
        {
            domains: ['xtranormal.com'],
            source_regex: [],
            flash_regex: [/&link=([^&]+)/],
            url_regex: [/(http:\/\/www\.xtranormal\.com\/[^&]+)/i],
            url: ''
        },
        {
            domains: ['socialcam.com'],
            source_regex: [/socialcam\.com\/videos\/([a-zA-Z0-9]+)/],
            flash_regex: [/&id=video_([a-zA-Z0-9]+)/],
            url_regex: [/socialcam\.com\/v\/([a-zA-Z0-9]+)/i],
            url: 'http://socialcam.com/v/'
        },
        */
        {
            domains: ['dipdive.com'],
            source_regex: [/&itemID=([0-9]+)/i, /play\.dipdive\.com\/i\/([0-9]+)/],
            flash_regex: [/&mediaID=([0-9]+)/i],
            url_regex: [/dipdive\.com\/media\/([0-9]+)/i],
            url: 'http://dipdive.com/media/'
        },
        /*
        {
            domains: ['snotr.com'],
            source_regex: [/snotr\.com\/embed\/([0-9]+)/],
            flash_regex: [/video=([0-9]+)/i],
            url_regex: [/snotr.com\/video\/([0-9]+)/i],
            url: 'http://www.snotr.com/video/'
        },
        */
        {
            domains: ['whitehouse.gov'],
            source_regex: [],
            flash_regex: [/&share_url=([^&]+)/],
            url_regex: [/(http:\/\/www\.whitehouse\.gov\/photos-and-video\/video\/.*)/i, /(http:\/\/www\.whitehouse\.gov\/video\/.*)/i, /(http:\/\/wh\.gov\/photos-and-video\/video\/.*)/i, /(http:\/\/wh\.gov\/video\/.*)/i],
            url: ''
        },
        /*
        {
            domains: ['hulu.com'],
            source_regex: [/hulu\.com\/embed\/([_\-a-zA-Z0-9]+)/],
            flash_regex: [],
            url: 'http://r.hulu.com/videos?eid='
        },
        {
            domains: ['crackle.com'],
            source_regex: [/crackle\.com\/flash/],
            flash_regex: [],
            url_regex: [/(http:\/\/(www\.)?crackle.com\/c\/.*)/i],
            use_location: true,
            location_regex: /http:\/\/(www\.)?crackle.com\/c\//,
            url: ''
        },
        {
            domains: ['xfinitytv.comcast.net'],
            source_regex: [/xfinitytv\.comcast\.net(\/[^?]+)/],
            flash_regex: [/<videoUrl>(.+?)<\/videoUrl>/],
            url_regex: [/fancast\.com\/(.+?\/videos)/i],
            url: 'http://www.fancast.com'
        },
        */
        {
            domains: ['funnyordie.com', 'ordienetworks.com'],
            source_regex: [],
            flash_regex: [/key=([a-zA-Z0-9]+)/],
            url_regex: [/funnyordie\.com\/videos\/([a-zA-Z0-9]+)/i],
            url: 'http://www.funnyordie.com/videos/'
        },
        {
            domains: ['ted.com'],
            source_regex: [],
            flash_regex: [/&adKeys=talk=([^;]+)/],
            url_regex: [/ted\.com\/talks\/([^;]+)\.html/i],
            url: function(id) { return 'http://www.ted.com/talks/' + id[1] + '.html'; }
        },
        {
            domains: ['espn.go.com'],
            source_regex: [/espn\.go\.com\/espnvideo\/.+\?id=([0-9]+)/, /espn\.go\.com\/.+\?mediaId=([0-9]+)/],
            flash_regex: [/^id=([0-9]+)$/],
            url_regex: [/espn\.go\.com\/.+\/video\/.+\?videoId=([0-9]+)/i, /espn\.go\.com\/video\/clip\?id=([0-9]+)/i],
            url: 'http://espn.go.com/video/clip?id='
        } //,
        /*
        {
            domains: ['mtvnservices.com'],
            source_regex: [],
            flash_regex: [/sid=The_Daily_Show_.+?&/],
            url_regex: [/(http:\/\/(www\.)?thedailyshow\.com\/(full-episodes|watch)\/.+)/],
            use_location: true,
            location_regex: /http:\/\/(www\.)?thedailyshow\.com\/(full-episodes|watch)\/.+/,
            url: ''
        },
        {
            domains: ['mtvnservices.com'],
            source_regex: [],
            flash_regex: [/sid=Colbert_.+?&/],
            url_regex: [/(http:\/\/(www\.)?colbertnation\.com\/(full-episodes|the-colbert-report-videos)\/.+)/i],
            use_location: true,
            location_regex: /http:\/\/(www\.)?colbertnation\.com\/(full-episodes|the-colbert-report-videos)\/.+/,
            url: ''
        },
        {
            domains: ['mtvnservices.com'],
            source_regex: [/media\.mtvnservices\.com\/mgid:cms:video:comedycentral\.com:([0-9]+)/],
            flash_regex: [],
            url_regex: [/comedycentral\.com\/videos\/index\.jhtml\?.*?videoId=([0-9]+)/i],
            url: 'http://www.comedycentral.com/videos/index.jhtml?videoId='
        },
        {
            domains: ['theonion.com'],
            source_regex: [/theonion\.com\/video_embed\/\?id=([0-9]+)/],
            flash_regex: [],
            url_regex: [/theonion\.com\/video\?id=([0-9]+)/i],
            url: 'http://www.theonion.com/video?id='
        },
        {
            domains: ['theonion.com'],
            source_regex: [/media\.theonion\.com\/flash/],
            flash_regex: [],
            url_regex: [/(http:\/\/(www\.)?theonion\.com\/video\/.+)/],
            use_location: true,
            location_regex: /http:\/\/(www\.)?theonion\.com\/video\/.+/,
            url: ''
        },
        {
            domains: ['video.forbes.com'],
            source_regex: [/images\.forbes\.com\/video\/r2iversion77\/_assets\/swf\/VideoPlayer\.swf/],
            flash_regex: [],
            url_regex: [/(http:\/\/video\.forbes\.com\/fvn\/[\-a-zA-Z0-9]+\/[\-a-zA-Z0-9]+)/],
            use_location: true,
            location_regex: /video\.forbes\.com\/fvn\/[\-a-zA-Z0-9]+\/[\-a-zA-Z0-9]+/
        },
        {
            domains: ['forbes.com/video'],
            source_regex: [/&video=([\-a-zA-Z0-9]+\/[\-a-zA-Z0-9]+)/],
            flash_regex: [],
            url: 'http://video.forbes.com/fvn/'
        },
        {
            domains: ['brightcove.com'],
            source_regex: [/brightcove\.com.+?&publisherID=71683906001&/],
            flash_regex: [],
            url_regex: [/(http:\/\/video\.aol\.com\/video-detail\/.+?\/[0-9]+)/i],
            use_location: true,
            location_regex: /http:\/\/video\.aol\.com\/video-detail\/.+?\/[0-9]+/,
            url: ''
        },
        {
            domains: ['brightcove.com'],
            source_regex: [/brightcove\.com\/.+?&purl=([^&]+?video\.aol\.com\/video\/[^&]+)/],
            url_regex: [/(http:\/\/video\.aol\.com\/video\/[^&]+)/i],
            flash_regex: [],
            url: ''
        },
        {
            // Bravo TV videos are hosted on nbcuni.com
            domains: ['video.nbcuni.com'],
            source_regex: [/video\.nbcuni\.com\/outlet\/embed\/OutletEmbeddedPlayerLoader.swf/],
            flash_regex: [],
            url_regex: [/(http:\/\/.+?\.bravotv\.com\/.+\/videos\/.+)/],
            use_location: true,
            location_regex: /bravotv\.com\/.+\/videos\/.+$/,
            url: ''
        },
        {
            domains: ['cnettv.cnet.com/av/video/cbsnews'],
            source_regex: [],
            flash_regex: [/&shareUrl=http:\/\/www\.cbsnews\.com\/video\/watch\/\?id=([0-9]+n)&/, /&linkUrl=http:\/\/www\.cbsnews\.com\/video\/watch\/\?id=([0-9]+n)&/],
            url: 'http://www.cbsnews.com/video/watch/?id='
        },
        {
            domains: ['a.abcnews.com'],
            source_regex: [],
            flash_regex: [/&showId=([0-9]+)&/],
            url: 'http://abcnews.com/video/playerIndex/?id='
        },
        {
            // Tech crunch
            domains: ['player.ooyala.com'],
            source_regex: [],
            flash_regex: [/&embedCode=([0-9a-zA-Z]+)&/],
            url: 'http://techcrunch.tv/watch?id='
        }
        */
    ],

    /** Run method for video adapter. */
    attach: function() {
        var fn = $.proxy(function() { setTimeout($.proxy(this._onHashChange, this), 1000); }, this);
        /*$(window).hashchange()
        if (window.addEventListener) {
            window.addEventListener('hashchange', fn, false);
        } else {
            window.onhashchange = fn;
        } */

        // $(window).addEvent("load", fn);
        fn();
    },

    _onHashChange: function(e) {
        var embeds = this._findFlashVideoCandidates();
        if (embeds)
            this._findFlashVideos(embeds);

        if ((this.videos.length > 0) && !this.kikinVideoBorder) {
            this._createKikinBorder();
        }
    },

    debug : function(str) {
        //if (!$ks.__PRODUCTION__) {
            try {
                console.log(str);
                // alert(str);
            } catch (e) {}
        //}
    },

    /**
    * find all the videos on the page
    */
    _findFlashVideoCandidates: function() {
        try {
            var embeds = [];

            var embed_tags = $('embed');
            // this.debug('Found ' + embed_tags.length + ' embeds');
            for (var i = 0; i < embed_tags.length; i++) {
                embeds.push(embed_tags[i]);
            }

            var objects = $('object');
            // this.debug('Found ' + objects.length + ' objects');
            for (var i = 0; i < objects.length; i++) {
                if (!/<embed/i.test(objects[i].innerHTML) || (!/<object/i.test(objects[i].innerHTML))) {
                    embeds.push(objects[i]);
                }
            }

            var iframes = $('iframe');
            // this.debug('Found ' + iframes.length + ' iframes');
            for (var i = 0; i < iframes.length; i++) {
                embeds.push(iframes[i]);
            }

            var videos = $('video');
            // this.debug('Found ' + videos.length + ' videos');
            for (var i = 0; i < videos.length; i++) {
                embeds.push(videos[i]);
            }

            return embeds;
        } catch (err) {
            alert("from: _findFlashVideoCandidates of base KikinVideoAdapter. \n Reason:" + err);
            //$kat.trackError({from: "_findFlashVideoCandidates of base KikinVideoAdapter.", exception:err});
        }

        return null;
    },

    _findFlashVideos: function(embeds) {
        try {
            // this.debug('Searching through ' + embeds.length + ' candidates');
            for (var i = 0; i < embeds.length; i++) {
                var embedTag = $(embeds[i]);
                if (embedTag.kikinVideoId != null) {
                    continue;
                }

                var videoUrl = this._findVideoUrl(embeds[i]);
                this.debug("Adding video for embed:" + embeds[i] + " and url: " + videoUrl);
                if (videoUrl) {
                    this._addVideo(embeds[i], videoUrl);
                }
            }

            if (this.videos.length > this._videosFound) {
                this._videosFound = this.videos.length;
                /*$kat.track('VideoAdapterEvt', 'SupportedVideoFound', {
                    campaign: window.location.host
                });*/

                //TODO: Enable this part for getting info

                $cws.WatchlrRequests.sendVideosInfoRequest($.proxy(this._onVideosInfoReceived, this), this.videos);
            }

            this.debug("Number of videos found:" + this.videos.length);
        } catch (err) {
            alert("from: _findFlashVideos of base KikinVideoAdapter. \nReason:" + err);
            // $kat.trackError({from: "_findFlashVideos of base KikinVideoAdapter.", exception:err});
        }
    },

    _findVideoUrl: function(embed) {
        var src = this._getNodeValue(embed, 'src') || this._getNodeValue(embed, 'data');
        var flashvars = this._getNodeValue(embed, 'flashvars');

        if (src.indexOf('/') == 0) {
            src = this._qualifyURL(src);
        } else if (src.indexOf('http://') == -1) {
            src = this._qualifyURL('/' + src);
        }

        this.debug('Flashvars:' + flashvars);
        this.debug('src:' + src);

        for (var j = 0; j < this.services.length; j++) {
            if (src && this._isSupportedDomain(src, this.services[j].domains)) {
                var match = { passed: false },
                	oService = this.services[j];

                if (flashvars) {
                    this._extractId(flashvars, oService.flash_regex, match);
                }

                if (!match.passed && !match.video_id) {
                    this.debug('oService.source_regex: ' + oService.source_regex);
                    this._extractId(src, oService.source_regex, match);
                }

                if (match.passed) {
                    if (oService.use_location != undefined) {
                        if (oService.use_location && oService.location_regex.test(window.location.href)) {
                            this.debug('Using location: ' + window.location.href);
                            return window.location.href;
                        }
                    } else if (match.video_id) {
                        this.debug('Found video with id: ' + match.video_id);
                        if (typeof(oService.url) == 'function') {
                            this.debug('Using URL:' + oService.url(match.video_id));
                            return oService.url(match.video_id);
                        } else {
                            this.debug("Video ids:" + match.video_id);
                            this.debug("Video id:" + match.video_id[1]);
                            this.debug('Using URL:' + (oService.url + match.video_id[1]));
                            return oService.url + match.video_id[1];
                        }
                    }
                }
            }
        }

        return "";
    },

    _addVideo : function(embed, videoUrl) {
        try {
            // create the video object
            var onmouseout= (embed ? embed.onmouseout : null);
            var onmouseover = (embed ? embed.onmouseover : null);
            var video = {
                url                 : videoUrl,
                mouseover           : onmouseover,
                mouseout            : onmouseover,
                saved               : false,
                videoSelected       : false,
                saveButtonSelected  : false,
                coordinates         : null,
                tracked             : false,
                liked               : false,
                likes               : 0,
                saves               : 0,
                id                  : (this.videos.length + 1)
            };

            if (embed)
                this._addMouseEvents(embed);

            // assign the video id to embed object
            embed.kikinVideoId = video.id;

            // push the video object to list.
            this.videos.push(video);

            return video;
        } catch (err) {
            alert("from: _addVideo of base KikinVideoAdapter. \n Reason:" + err);
            // $kat.trackError({from: "_addVideo of base KikinVideoAdapter.", msg:"Error while adding kikin video.", exception:err});
        }
    },

    _addMouseEvents : function(embed) {
        //$(embed).mouseenter(function() { alert('onmoueseenter'); });
        // $(embed).mouseleave(function() { alert('onmoueseleave'); });

        // add mouse events to the object
        var _onVideoMouseOver = $.proxy(this._onVideoMouseOver, this);
        var _onVideoMouseOut = $.proxy(this._onVideoMouseOut, this);

        /*if (embed.nodeName.toLowerCase() == 'iframe') {
            $(embed).mouseenter(_onVideoMouseOver);
            $(embed).mouseleave(_onVideoMouseOut);
            return;
        } */

        // We try to listen mouse events for video in all the possible ways.
        // Different players fire events in different way. For eg.
        // 1. Youtube will fire the event on 'onmouseover'
        // 2. Collegehumour will fire event on 'addEventListener' in Firefox/Chrome and 'attachEvent' in IE
        // 3. Vimeo will always fire the event on 'addEventListener' (even for IE7 and IE8)
        try {
            embed.onmouseover = _onVideoMouseOver;
            embed.onmouseout = _onVideoMouseOut;
            this.debug('Added mouse events successfully for embed:' + embed);
        } catch (e) {
            alert("From: _addMouse events. \n Reason:" + e);
        }

        // If attachEvent is supported listen mouse events using attachEvent
        if (embed.attachEvent) {
            try {
                embed.attachEvent('onmouseover', _onVideoMouseOver);
                embed.attachEvent('onmouseout', _onVideoMouseOut);
                this.debug('Attached mouse events successfully for embed:' + embed);
            } catch (e) {
                alert("From: _addMouse events. \n Reason:" + e);
            }
        }

        // If addEventListener is supported listen mouse events using addEventListener
        if (embed.addEventListener) {
            try {
                embed.addEventListener('mouseover', _onVideoMouseOver, false);
                embed.addEventListener('mouseoout', _onVideoMouseOut, false);
                this.debug('Added events listeners for mouse events successfully for embed:' + embed);
            } catch (e) {
                alert("From: _addMouse events. \n Reason:" + e);
            }
        }
    },

    _getNodeValue: function (obj, id) {
        //var value = $(obj).attr(id);
        var value = "";
        for (var i = 0; i < obj.attributes.length; i++) {
            if (obj.attributes[i].nodeName.toLowerCase() == id) {
                value += obj.attributes[i].nodeValue;
                break;
            }
        }

        var params = $(obj).find('param');
        if (params) {
            for (var i = 0; i < params.length; i++) {
                if (params[i].name.toLowerCase() == id) {
                    value += params[i].value;
                    break;
                }
            }
        }

        return decodeURIComponent(value);
    },

    _isSupportedDomain: function(src, domains) {
        for (var i = 0; i < domains.length; i++) {
            // this.debug('Testing against domain: ' + domains[i] + ' with src: ' + src);
            if (src.indexOf(domains[i]) != -1) {
                this.debug('Matched domain ' + domains[i]);
                return true;
            }
        }
        return false;
    },

    _extractId: function(str, patterns, match) {
        for (var i = 0; i < patterns.length; i++) {
            this.debug('Matching: ' + patterns[i] + ' against ' + str);
            var videoId = patterns[i].exec(str);
            if (videoId) {
                // this.debug('Matched: ' + str + " \tfor pattern:" + patterns[i]);
                match.passed = true;
                match.video_id = videoId;
                return;
            }
        }
    },

    _escapeHTML: function(s) {
        return s.split('&').join('&amp;').split('<').join('&lt;').split('"').join('&quot;');
    },

    _qualifyURL: function(url) {
        var el = document.createElement('div');
        el.innerHTML = '<a href="' + this._escapeHTML(url) + '">x</a>';
        return el.firstChild.href;
    },

    _createKikinBorder : function() {
        try {
            $($('head').get(0)).append('<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=PT%20Sans">');
            $cwutil.Styles.insert('VideoBorderStyles', document);
            // create a div tag for the video
            $(document.body).append($cws.html['VideoBorder']);
            this.kikinVideoBorder = $('#watchlr-video-border');

            $(this.kikinVideoBorder).find('#like-btn-text').html(this._localize('like'));

            $(this.kikinVideoBorder).find('#watchlr-logo').click($.proxy(this._handleVisitingVideoPageRequested, this));
            $(this.kikinVideoBorder).find('#watch-later-btn-img').click($.proxy(this._onSaveButtonClicked, this));
            $(this.kikinVideoBorder).find('#watch-later-btn-text').click($.proxy(this._onSaveButtonClicked, this));
            $(this.kikinVideoBorder).find('#like-btn-img').click($.proxy(this._onLikeButtonClicked, this));
            $(this.kikinVideoBorder).find('#like-btn-text').click($.proxy(this._onLikeButtonClicked, this));

            $(this.kikinVideoBorder).find('#options-button').mouseenter($.proxy(this._onSaveButtonMouseOver, this));
            $(this.kikinVideoBorder).find('#options-button').mouseleave($.proxy(this._onSaveButtonMouseOut, this));

            $(this.kikinVideoBorder).find('#watchlr-logo').mouseenter($.proxy(this._onWatclrLogoMouseEnter, this));
            $(this.kikinVideoBorder).find('#watch-later-btn-img').mouseenter($.proxy(this._onSaveButtonMouseEnter, this));
            $(this.kikinVideoBorder).find('#watch-later-btn-text').mouseenter($.proxy(this._onSaveButtonMouseEnter, this));
            $(this.kikinVideoBorder).find('#like-btn-img').mouseenter($.proxy(this._onLikeButtonMouseEnter, this));
            $(this.kikinVideoBorder).find('#like-btn-text').mouseenter($.proxy(this._onLikeButtonMouseEnter, this));

            $(this.kikinVideoBorder).find('#watchlr-logo').mouseleave($.proxy(this._onWatclrLogoMouseLeave, this));
            $(this.kikinVideoBorder).find('#watch-later-btn-img').mouseleave($.proxy(this._onSaveButtonMouseLeave, this));
            $(this.kikinVideoBorder).find('#watch-later-btn-text').mouseleave($.proxy(this._onSaveButtonMouseLeave, this));
            $(this.kikinVideoBorder).find('#like-btn-img').mouseleave($.proxy(this._onLikeButtonMouseLeave, this));
            $(this.kikinVideoBorder).find('#like-btn-text').mouseleave($.proxy(this._onLikeButtonMouseLeave, this));

        } catch (e) {
            alert("from: createKikinBorder of base KikinVideoAdapter. \nReason:" + e);
            // $kat.trackError({from:"createKikinBorder of base KikinVideoAdapter", msg: "Unable to create the border around video.", exception:e});
        }
    },

    /**
    * draw the border around the flash videos on the page.
    */
    _drawKikinBorder: function(left, top, width, height, saved, liked, likes) {
        if (!this.kikinVideoBorder) {
            this._createKikinBorder();
        }

        if ((left >= 0 )&& (top >= 0) && width && height && this.kikinVideoBorder) {
            try {
                // set the position and dimensions for the left border
                var leftBorderStyle = {
                    'left'   : '' + (left - this.BORDER_WIDTH) + 'px',
                    'top'    : '' + top + 'px',
                    'width'  : '' + this.BORDER_WIDTH + 'px',
                    'height' : '' + height + 'px'
                };
                $(this.kikinVideoBorder).find('#left-border').css(leftBorderStyle);


                // this.debug("Left border is created with dimensions:" + leftBorder.style.left + "," + leftBorder.style.top + ", " + leftBorder.style.width + ", " + leftBorder.style.height);

                // set the position and dimensions for the right border
                var rightBorderStyle = {
                    'left'   : '' + (left + width) + 'px',
                    'top'    : '' + top + 'px',
                    'width'  : '' + this.BORDER_WIDTH + 'px',
                    'height' : '' + height + 'px'
                };
                $(this.kikinVideoBorder).find('#right-border').css(rightBorderStyle);


                // this.debug("Right border is created with dimensions:" + rightBorder.style.left + "," + rightBorder.style.top + ", " + rightBorder.style.width + ", " + rightBorder.style.height);

                // set the position and dimensions for the top border
                var topBorderStyle = {
                    'left'   : '' + (left - this.BORDER_WIDTH) + 'px',
                    'top'    : '' + (top - this.BORDER_WIDTH) + 'px',
                    'width'  : '' + (width + (2 * this.BORDER_WIDTH)) + 'px',
                    'height' : '' + this.BORDER_WIDTH + 'px'
                };
                $(this.kikinVideoBorder).find('#top-border').css(topBorderStyle);

                // this.debug("Top border is created with dimensions:" + topBorder.style.left + "," + topBorder.style.top + ", " + topBorder.style.width + ", " + topBorder.style.height);

                // set the position and dimensions for the bottom border
                var bottomBorderStyle = {
                    'left'   : '' + (left - this.BORDER_WIDTH) + 'px',
                    'top'    : '' + (top + height) + 'px',
                    'width'  : '' + (width + (2 * this.BORDER_WIDTH)) + 'px',
                    'height' : '' + this.BORDER_WIDTH + 'px'
                };
                var bottomBorder = $(this.kikinVideoBorder).find('#bottom-border');
                $(bottomBorder).css(bottomBorderStyle);

                if (saved) {
                    $(this.kikinVideoBorder).find('#watch-later-btn-text').html(this._localize('btnSaved'));
                    $(this.kikinVideoBorder).find('#watch-later-btn-img').removeClass();
                    $(this.kikinVideoBorder).find('#watch-later-btn-img').addClass("watchlr-image saved-button-image");
                } else if (!this.selectedVideo.savingVideo) {
                    $(this.kikinVideoBorder).find('#watch-later-btn-text').html(this._localize('btnSave'));
                    $(this.kikinVideoBorder).find('#watch-later-btn-img').removeClass();
                    $(this.kikinVideoBorder).find('#watch-later-btn-img').addClass("watchlr-image watch-later-button-image");
                }


                var kikinLikeBtn = $(this.kikinVideoBorder).find('#like-btn-img');
                var likeBtnText = $(this.kikinVideoBorder).find('#like-btn-text');
                // var kikinLikeBtnText = $(this.kikinVideoBorder).find('#kikinLikeBtnText');
                if (liked) {
                    $(kikinLikeBtn).removeClass();
                    $(kikinLikeBtn).addClass('watchlr-image like-button-image');
                    $(likeBtnText).html(this._localize('liked'));
                } else {
                    $(kikinLikeBtn).removeClass();
                    $(kikinLikeBtn).addClass('watchlr-image unlike-button-image');
                    $(likeBtnText).html(this._localize('like'));
                }

                var saveButton =  $(this.kikinVideoBorder).find('#options-button');
                var saveButtonTop = parseInt($(bottomBorder).css('top'));

                var saveButtonLeft = parseInt($(bottomBorder).css('left')) +
                                     parseInt($(bottomBorder).css('width')) -
                                     (parseInt($(saveButton).css('width')) + /*paddign*/23);

                $(saveButton).css({
                    'left' : '' + saveButtonLeft + 'px',
                    'top'  : '' + saveButtonTop + 'px'
                });

                $(this.kikinVideoBorder).show();
            } catch (e) {
                alert('from: drawKikinBorder of base KikinVideoAdapter. \nReason:' + e);
                // $kat.trackError({from: "drawKikinBorder of base KikinVideoAdapter", msg: "Unable to reposition border around video.", exception:e});
            }
        }
    },

    /**
     * retrieves the coordinates for the video
     * @param embed
     */
    _getVideoCoordinates: function(embed) {
        try {
            // this.debug("Get called in base class getVideoCoordinates");
            var videoWidth = embed.clientWidth || embed.width;
            if (!videoWidth) {
                videoWidth = this._getNodeValue(embed, 'width');
            }

            var videoHeight = embed.clientHeight || embed.height;
            if (!videoHeight) {
                videoHeight = this._getNodeValue(embed, 'height');
            }

            var parent = embed;
            var offsetLeft = 0;
            var offsetTop = 0;
            // Calculate the absolute position of the video
            while (parent && (parent != document.body)) {
                offsetLeft += parent.offsetLeft;
                offsetTop += parent.offsetTop;
                var oldParent = parent;
                parent = parent.offsetParent;

                // if the element has set the scroll property,
                // then calculate the relative position of video in the view port.
                // relative position of video in context of view port can be calculated using
                // offsetLeft = element.scrollLeft - (absolute position of video in the element)
                // offsetTop = element.scrollTop - (absolute position of video in the element)
                var parentElement = oldParent;
                while (parentElement && (parentElement != parent)) {
                    // alert(parentElement);
                    // this.debug('Parent element: ' + parentElement.tagName);
                    var overFlow = $(parentElement).css('overflow');
                    if (overFlow && (overFlow == "scroll" || overFlow == "auto")) {
                        if (parentElement.scrollLeft) {
                            // this.debug('Left scroll is:' + parentElement.scrollLeft);
                            offsetLeft -= parentElement.scrollLeft;
                        }
                        if (parentElement.scrollTop) {
                            // this.debug('Top scroll is:' + parentElement.scrollTop);
                            offsetTop -= parentElement.scrollTop;
                        }

                    } else {
                        var overFlowX = $(parentElement).css('overflow-x');
                        if (overFlowX && (overFlowX == "scroll" || overFlowX == "auto")  && parentElement.scrollLeft) {
                            // this.debug("scroll left position is: " + parentElement.scrollLeft);
                            offsetLeft -= parentElement.scrollLeft;
                        }

                        var overFlowY = $(parentElement).css('overflow-y');
                        if (overFlowY && (overFlowY == "scroll" || overFlowY == "auto") && parentElement.scrollTop) {
                            // this.debug("scroll top position is: " + parentElement.scrollTop);
                            offsetTop -= parseInt(parentElement.scrollTop);
                        }
                    }

                    parentElement = $(parentElement).parent().get(0);
                }

                // this.debug("Offset Left:" + offsetLeft + " \t Offset Top: " + offsetTop);
            }

            var coordinates = {
                left    : offsetLeft,
                top     : offsetTop,
                width   : videoWidth,
                height  : videoHeight
            };

            return coordinates;
        } catch (e) {
            alert('from: getVideoCoordinates of base KikinVideoAdapter. \nReason:' + e);
            // $kat.trackError({from: "getVideoCoordinates of base KikinVideoAdapter", msg: "Unable to calculate the coordinates for video.", exception:e});
        }

        return null;
    },

    /**
     * when user mouse overs the video
     * @param e
     */
    _onVideoMouseOver: function(e) {
        try {
            var evt = e;
            if (!evt)
                evt = window.event;

            // If there is no event, we cannot find the target, and thus, we cannot find the video ID
            // associated with the target. So ignore the event
            if (!evt)
                return;

            var target = evt.target;
            if (!target)
                target = evt.srcElement;

            this.debug("Video mouse over for target:" + (target ? target.nodeName : "not found"));

            if (target) {
                if (target.nodeType == 3) {
                    target = target.parentNode;
                }

                // get the kikin video id
                var kikinVideoId = target.kikinVideoId;
                if (kikinVideoId === null || kikinVideoId == undefined) {
                    var embedTags = target.getElementsByTagName('embed');
                    if (embedTags.length == 1) {
                        kikinVideoId = embedTags[0].kikinVideoId;
                    }
                }

                this.debug("Video id associated with target:" + kikinVideoId);

                // if kikin video is is valid
                // draw the border around video
                if (kikinVideoId) {
                    var selectedVideo = this.videos[kikinVideoId - 1];

                    try {
                        if (!selectedVideo.tracked) {
                            /*$kat.track('VideoAdapterEvt', 'VideoMouseOver', {
                                campaign: window.location.host
                            });*/
                            selectedVideo.tracked = true;
                        }
                    } catch (err) {}

                    // if selected video is different than the video saved in the object
                    // hide the saved object video if it is visible
                    if (this.selectedVideo && (this.selectedVideo != selectedVideo)) {
                        $(this.kikinVideoBorder).fadeOut();
                        // this.kikinVideoBorder.style.visibility = "hidden";
                        this.selectedVideo.videoSelected = false;
                        this.selectedVideo.shareButtonSelected = false;
                    }

                    // set the new selected video
                    this.selectedVideo = selectedVideo;



                    // calculate the coordinates for video
                    selectedVideo.coordinates = this._getVideoCoordinates(target);

                    if (selectedVideo.coordinates) {
                        this.debug("Coordinates for video:" + selectedVideo.coordinates.left + ", " + selectedVideo.coordinates.top + ", " + selectedVideo.coordinates.width + ", " + selectedVideo.coordinates.height);

                        // draw the border around video
                        this._drawKikinBorder(selectedVideo.coordinates.left,
                                              selectedVideo.coordinates.top,
                                              selectedVideo.coordinates.width,
                                              selectedVideo.coordinates.height,
                                              selectedVideo.saved,
                                              selectedVideo.liked,
                                              selectedVideo.likes);
                    }

                    selectedVideo.videoSelected = true;

                    try {
                        // call the original mouseover event
                        if (selectedVideo.onmouseover) {
                            selectedVideo.onmouseover();
                        }
                    } catch (e) {}
                }
            }
        } catch (err) {
            alert('from: onVideoMouseOver of base KikinVideoAdapter. \nReason:' + err);
            // $kat.trackError({from: "onVideoMouseOver of base KikinVideoAdapter", exception:err});
        }
    },

    /**
     * on mouse out from video
     * @param e
     */
    _onVideoMouseOut: function(e) {
        try {

            var evt = e;
            if (!evt)
                evt = window.event;

            // If there is no event, we cannot find the target, and thus, we cannot find the video ID
            // associated with the target. So ignore the event
            if (!evt)
                return;

            var target = evt.target;
            if (!target)
                target = evt.srcElement;

            // this.debug("Video mouse out for target:" + (target ? target.nodeName : "not found"));

            if (target) {
                if (target.nodeType == 3) {
                    target = target.parentNode;
                }

                // fetch the kikin video id
                var kikinVideoId = target.kikinVideoId;
                if (kikinVideoId === null || kikinVideoId == undefined) {
                    var embedTags = target.getElementsByTagName('embed');
                    if (embedTags.length == 1) {
                        kikinVideoId = embedTags[0].kikinVideoId;
                    }
                }

                // this.debug("Video id associated with target:" + kikinVideoId);

                // if kikin video id is valid
                if (kikinVideoId >= 0) {
                    // set the selected video property to false
                    var selectedVideo = this.videos[parseInt(kikinVideoId, 10) - 1];
                    selectedVideo.videoSelected = false;

                    // hide the border after a second
                    setTimeout($.proxy(function() {
                        var selectedVideo = this.selectedVideo;

                        // if mouse is not over the video or share button of the video
                        // hide the video
                        if (selectedVideo &&
                        	!selectedVideo.shareButtonSelected &&
                            !selectedVideo.videoSelected &&
                            !this.selectedVideo.savingVideo &&
                            !this.selectedVideo.likingVideo)
                        {
                            // $(this.kikinVideoBorder).css('visibility', 'hidden');
                            $(this.kikinVideoBorder).fadeOut();
                        }
                    }, this), 1000);


                    try {
                        if (selectedVideo.onmouseout) {
                            selectedVideo.onmouseout();
                        }
                    }  catch (e) {}
                }
            }
        } catch (err) {
            alert('from: onVideoMouseOut of base KikinVideoAdapter. \nReason:' + err);
            // $kat.trackError({from: "onVideoMouseOut of base KikinVideoAdapter", exception:err});
        }
    },

    /**
     * on mouse over share button
     * @param e
     */
    _onSaveButtonMouseOver: function(e) {
        try {
            // this.debug("On button mouse over");
            if (e) e.stopPropagation();

            this.selectedVideo.shareButtonSelected = true;
        } catch (err) {
            alert('from: onSaveButtonMouseOver of base KikinVideoAdapter. \nReason:' + err);
            // $kat.trackError({from: "onSaveButtonMouseOver of base KikinVideoAdapter", exception:err});
        }
    },

    /**
     * on mouse out of share button
     * @param e
     */
    _onSaveButtonMouseOut: function(e) {
        try {
            if (e) e.stopPropagation();

            // this.debug("On button mouse out");

            this.selectedVideo.shareButtonSelected = false;

            // hide the border after 1 second
            setTimeout($.proxy(function() {

                // if mouse is not over share button or video,
                // hide the border
                var selectedVideo = this.selectedVideo;
                if (!selectedVideo.shareButtonSelected &&
                    !selectedVideo.videoSelected &&
                    !this.selectedVideo.savingVideo &&
                    !this.selectedVideo.likingVideo)
                {
                    $(this.kikinVideoBorder).fadeOut();
                }
            }, this), 1000);
        } catch (err) {
            alert('from: onSaveButtonMouseOut of base KikinVideoAdapter. \nReason:' + err);
            // $kat.trackError({from: "onSaveButtonMouseOut of base KikinVideoAdapter", exception:err});
        }
    },

    _onWatclrLogoMouseEnter : function(e) {
        try {
            if (e) e.stopPropagation();

            var watchlrLogoImg = $(this.kikinVideoBorder).find('#watchlr-logo');
            $(watchlrLogoImg).removeClass();
            $(watchlrLogoImg).addClass('watchlr-image watchlr-logo-hover-image');
        } catch (err) {
            alert('from: _onWatclrLogoMouseEnter of base KikinVideoAdapter. \nReason:' + err);
            // $kat.trackError({from: "onSaveButtonMouseOut of base KikinVideoAdapter", exception:err});
        }
    },

    _onSaveButtonMouseEnter : function(e) {
        try {
            if (e) e.stopPropagation();

            var watchLaterButtonImg = $(this.kikinVideoBorder).find('#watch-later-btn-img');
            $(watchLaterButtonImg).removeClass();
            if (this.selectedVideo.saved) {
                $(watchLaterButtonImg).addClass('watchlr-image saved-button-hover-image');
            } else {
                $(watchLaterButtonImg).addClass('watchlr-image watch-later-button-hover-image');
            }

            var watchLaterButtonText = $(this.kikinVideoBorder).find('#watch-later-btn-text');
            $(watchLaterButtonText).css({
                'text-decoration': 'underline',
                'color': '#000000'
            });

        } catch (err) {
            alert('from: _onSaveButtonMouseEnter of base KikinVideoAdapter. \nReason:' + err);
            // $kat.trackError({from: "onSaveButtonMouseOut of base KikinVideoAdapter", exception:err});
        }
    },

    _onLikeButtonMouseEnter : function(e) {
        try {
            if (e) e.stopPropagation();

            var likeButtonImg = $(this.kikinVideoBorder).find('#like-btn-img');

            if (this.selectedVideo.liked) {
                // $(likeButtonImg).removeClass();
                // $(likeButtonImg).addClass('watchlr-image like-button-hover-image');
            } else {
                $(likeButtonImg).removeClass();
                $(likeButtonImg).addClass('watchlr-image unlike-button-hover-image');
            }

            var likeButtonText = $(this.kikinVideoBorder).find('#like-btn-text');
            $(likeButtonText).css({
                'text-decoration': 'underline',
                'color': '#000000'
            });

        } catch (err) {
            alert('from: _onLikeButtonMouseEnter of base KikinVideoAdapter. \nReason:' + err);
            // $kat.trackError({from: "onSaveButtonMouseOut of base KikinVideoAdapter", exception:err});
        }
    },

    _onWatclrLogoMouseLeave : function(e) {
        try {
            if (e) e.stopPropagation();

            var watchlrLogoImg = $(this.kikinVideoBorder).find('#watchlr-logo');
            $(watchlrLogoImg).removeClass();
            $(watchlrLogoImg).addClass('watchlr-image watchlr-logo-image');
        } catch (err) {
            alert('from: _onWatclrLogoMouseLeave of base KikinVideoAdapter. \nReason:' + err);
            // $kat.trackError({from: "onSaveButtonMouseOut of base KikinVideoAdapter", exception:err});
        }
    },

    _onSaveButtonMouseLeave : function(e) {
        try {
            if (e) e.stopPropagation();

            var watchLaterButtonImg = $(this.kikinVideoBorder).find('#watch-later-btn-img');
            $(watchLaterButtonImg).removeClass();
            if (this.selectedVideo.saved) {
                $(watchLaterButtonImg).addClass('watchlr-image saved-button-image');
            } else {
                $(watchLaterButtonImg).addClass('watchlr-image watch-later-button-image');
            }

            var watchLaterButtonText = $(this.kikinVideoBorder).find('#watch-later-btn-text');
            $(watchLaterButtonText).css({
                'text-decoration': 'none',
                'color': '#ffffff'
            });

        } catch (err) {
            alert('from: _onSaveButtonMouseLeave of base KikinVideoAdapter. \nReason:' + err);
            // $kat.trackError({from: "onSaveButtonMouseOut of base KikinVideoAdapter", exception:err});
        }
    },

    _onLikeButtonMouseLeave : function(e) {
        try {
            if (e) e.stopPropagation();

            var likeButtonImg = $(this.kikinVideoBorder).find('#like-btn-img');
            $(likeButtonImg).removeClass();
            if (this.selectedVideo.liked) {
                $(likeButtonImg).addClass('watchlr-image like-button-image');
            } else {
                $(likeButtonImg).addClass('watchlr-image unlike-button-image');
            }

            var likeButtonText = $(this.kikinVideoBorder).find('#like-btn-text');
            $(likeButtonText).css({
                'text-decoration': 'none',
                'color': '#ffffff'
            });

        } catch (err) {
            alert('from: _onLikeButtonMouseLeave of base KikinVideoAdapter. \nReason:' + err);
            // $kat.trackError({from: "onSaveButtonMouseOut of base KikinVideoAdapter", exception:err});
        }
    },

    /**
     * when user clicks the share button
     * share the video
     *
     * @param e
     */
    _onSaveButtonClicked: function(e) {
        try {
            if (e) e.stopPropagation();
            var target = e.target;

            // this.debug("On button mouse clicked");

            try {
                // this.debug("Is video saved:" + this.selectedVideo.saved);
                if (!this.selectedVideo.saved) {

                    // change the save button to saving spinner
                    var saveButton = $(this.kikinVideoBorder).find('#watch-later-btn-img');
                    $(saveButton).removeClass();
                    $(saveButton).addClass("watchlr-image spinner-image");

                    // change the save button text to saving...
                    $($(this.kikinVideoBorder).find('#watch-later-btn-text')).html(this._localize('btnSaving'));

                    this.selectedVideo.savingVideo = true;
                    $cws.WatchlrRequests.sendSaveVideoRequest($.proxy(this._updateButtonState, this), this.selectedVideo.url);
                    /*$kat.track('Video', 'SaveVideoClk', {
                        campaign: window.location.host
                    });*/
                } else {
                    window.open(this.WATCHLR_COM);
                    /*$kat.track('Video', 'ToVKikinCom', {
                        campaign: window.location.host
                    });*/
                }
            } catch (e) {
                alert('from: onSaveButtonClicked of base KikinVideoAdapter. \nReason:' + e);
                // $kat.trackError({ from: 'onSaveButtonClicked of base KikinVideoAdapter', msg: 'error while saving video', exception: e });
            }
        } catch (err) {
            alert('from: onSaveButtonClicked of base KikinVideoAdapter. \nReason:' + err);
            // $kat.trackError({from: "onSaveButtonClicked of base KikinVideoAdapter", exception:err});
        }
    },

    /**
     * when user clicks the like button
     * like the video
     *
     * @param e
     */
    _onLikeButtonClicked: function(e) {
        try {
            if (e) e.stopPropagation();
            var target = e.target;

            // this.debug("On button mouse clicked");

            try {
                // change the like button to saving spinner
                var likeButton = $(this.kikinVideoBorder).find('#like-btn-img');
                $(likeButton).removeClass();
                $(likeButton).addClass("watchlr-image spinner-image");

                // change the save button text to liking...
                // $($(this.kikinVideoBorder).find('#watch-later-btn-text')).html(this._localize('btnSaving'));

                this.selectedVideo.likingVideo = true;

                // If we don't have to show the push to facebook dialog, then make the request to server
                // else we are going to make the call when user closes the push to facebook dialog.

                if (!this.selectedVideo.liked) {
                    if (this._showFbPushDialog) {
                        var oAlert = new $cwui.modalwin.FirstVideoLikedWindow();
                        oAlert.bind('close', $.proxy(this._onPushToFacebookWindowClosed, this));
                        oAlert.bind('visituserprofilepage', $.proxy(this._handleVisitingVideoPageRequested, this));
                        oAlert.show();
                    } else {
                        $cws.WatchlrRequests.sendVideoLikedRequest($.proxy(this._onVideoLiked, this), this.selectedVideo.url);
                        //$kat.track('Video', 'LikeVideoClk', {
                        //    campaign: window.location.host
                        //});
                    }
                } else {
                    window.open(this.WATCHLR_COM + '#!/liked_queue');
                }

                /*if (this._showFbPushDialog) {
                    var oAlert = new $cwui.modalwin.FirstVideoLikedWindow();
                    oAlert.bind('close', $.proxy(this._onPushToFacebookWindowClosed, this));
                    oAlert.bind('visituserprofilepage', $.proxy(this._handleVisitingVideoPageRequested, this));
                    oAlert.show();
                } else {
                    if (!this.selectedVideo.liked) {
                        $cws.WatchlrRequests.sendVideoLikedRequest($.proxy(this._onVideoLiked, this), this.selectedVideo.url);
                        //$kat.track('Video', 'LikeVideoClk', {
                        //    campaign: window.location.host
                        //});
                    } else {
                        // $cws.WatchlrRequests.sendVideoUnlikedRequest($.proxy(this._onVideoLiked, this), this.selectedVideo.url);
                        //$kat.track('Video', 'UnlikeVideoClk', {
                        //    campaign: window.location.host
                        //});
                    }
                } */
            } catch (e) {
                alert('from: onLikeButtonClicked of base KikinVideoAdapter. \nReason:' + e);
                // $kat.trackError({ from: 'onLikeButtonClicked of base KikinVideoAdapter', msg: 'error while liking video', exception: e });
            }
        } catch (err) {
            alert('from: onLikeButtonClicked of base KikinVideoAdapter. \nReason:' + err);
        }
    },

    /**
	 * determine if the popup window is closed, when it is call the commonCallback
	 */
	_monitorPopup: function() {
        this.debug("Window is created:" + (this._connectionPopup==null));
        this.debug("Window is closed:" + (this._connectionPopup.closed));
		if(this._connectionPopup==null || this._connectionPopup.closed){
			this._popupMonitor = false;
			this._commonCallback();
		} else if(this._popupMonitor){
            console.log("Checking again");
			setTimeout($.proxy(this._monitorPopup, this), 600);
		}
	},

    _commonCallback: function() {
        this.debug('get called in common callback');
        if (this.selectedVideo.savingVideo) {
            $cws.WatchlrRequests.sendSaveVideoRequest($.proxy(this._updateButtonState, this), this.selectedVideo.url);
        } else if (this.selectedVideo.likingVideo) {
            this.debug('making the request for fetching user info');
            $cws.WatchlrRequests.sendUserProfileRequest($.proxy(this.onUserProfileReceived, this));
        }
    },

    _handleFacebookConnectionCancelled: function() {
        if (this.selectedVideo.savingVideo) {
            this.selectedVideo.savingVideo = false;

            // change the save button to saving spinner
            var saveButton = $(this.kikinVideoBorder).find('#watch-later-btn-img');
            $(saveButton).removeClass();
            $(saveButton).addClass("watchlr-image watch-later-button-image");

            // change the save button text to saving...
            $($(this.kikinVideoBorder).find('#watch-later-btn-text')).html(this._localize('btnSave'));

            var oAlert = new $cwui.modalwin.AlertWindow(
                this._localize('errorDlgTitle'),
                this._localize('errorDlgMsg')
            );
            oAlert.show();

        } else if (this.selectedVideo.likingVideo) {
            this.selectedVideo.likingVideo = false;

            // change the like button to saving spinner
            var saveButton = $(this.kikinVideoBorder).find('#like-btn-img');
            $(saveButton).removeClass();

            // change the save button text to liking...
            // $($(this.kikinVideoBorder).find('#watch-later-btn-text')).html(this._localize('btnSaving'));

            if (!this.selectedVideo.liked) {
                var oAlert = new $cwui.modalwin.AlertWindow(
                    this._localize('errorDlgLikeTitle'),
                    this._localize('errorDlgLikeMsg')
                );
                oAlert.show();
                $(saveButton).addClass("watchlr-image unlike-button-image");
            } else {
                var oAlert = new $cwui.modalwin.AlertWindow(
                    this._localize('errorDlgUnlikeTitle'),
                    this._localize('errorDlgUnlikeMsg')
                );
                oAlert.show();
                $(saveButton).addClass("watchlr-image like-button-image");
            }
        }

        /*$kat.track('VideoAdapterEvt', 'LoginCancel', {
            campaign: window.location.host
        });*/
    },

    _handleFacebookConnectionRequested: function() {
        var url = this.WATCHLR_COM + 'login/facebook?next=' + encodeURIComponent(this.WATCHLR_COM+'static/html/connectWindow.html?connected=true&code=200');
        this._connectionPopup = window.open(url, '_blank', 'location=1, width=' + 800 + ',height=' + 600 + ',left=' + 200 + ',top=' + 200);
        this._popupMonitor = true;
        this._monitorPopup();
    },

    _handleVisitingVideoPageRequested: function() {
        window.open(this.WATCHLR_COM);
    },

    /** When video is saved. */
    _updateButtonState: function(data) {
        try {
            // this.debug("Data received from server:" + data);
            if(this.selectedVideo){
                var buttonText = "";
                var res = null;
                if (typeof data == "object") {
                    res = data;
                } else {
                    res = JSON.decode(data);
                }

                var videoSavedSuccessfully = false;
                if (res && res.success && res.result && res.result.saved) {
                    videoSavedSuccessfully = true;
                } else {
                    if (res) {
                        switch (res.code) {

                            case 400: {
                                videoSavedSuccessfully = true;
                                break;
                            }

                            case 401: {
                                this.debug("Session sent was an invalid session");
                                var oAlert = new $cwui.modalwin.FacebookConnectWindow();
                                oAlert.bind('close', $.proxy(this._handleFacebookConnectionCancelled, this));
                                oAlert.bind('connect', $.proxy(this._handleFacebookConnectionRequested, this));
                                oAlert.bind('visituserprofilepage', $.proxy(this._handleVisitingVideoPageRequested, this));
                                oAlert.show();
                                break;
                            }

                            default: {
                                var oAlert = new $cwui.modalwin.AlertWindow(
                                    this._localize('errorDlgTitle'),
                                    this._localize('errorDlgMsg')
                                );
                                oAlert.show();
                                alert('from: updateButtonState of base KikinVideoAdapter. \nReason:' + 'Unable to save video');
                                // $kat.trackError({from: "updateButtonState of base KikinVideoAdapter", msg:"Unable to save video. Error code:" + res.code + ", Error:" + res.error});
                            }
                        }
                    } else {
                        var oAlert = new $cwui.modalwin.AlertWindow(
                            this._localize('errorDlgTitle'),
                            this._localize('errorDlgMsg')
                        );

                        alert('from: updateButtonState of base KikinVideoAdapter. \nReason:' + 'Unable to save video');
                        //$kat.trackError({from: "updateButtonState of base KikinVideoAdapter", msg:"Unable to save video. Reason:" + (res ? res.error : "Result is null")});
                    }
                }

                var saveButtonText = $(this.kikinVideoBorder).find('#watch-later-btn-text');
                var saveButtonImg = $(this.kikinVideoBorder).find('#watch-later-btn-img');
                $(saveButtonImg).removeClass();
                if (videoSavedSuccessfully) {
                    this.selectedVideo.savingVideo = false;
                    this.selectedVideo.saved = true;
                    $(saveButtonText).html(this._localize('btnSaved'));
                    $(saveButtonImg).addClass("watchlr-text saved-button-image");

                    // video Id can be 0;
                    if (res.result) {
                        var oResult = res.result;
                        if (oResult.id != null && oResult.id != undefined)
                            this.selectedVideo.videoId = oResult.id;
                        if(oResult.emptyq) {
                            var oAlert = new $cwui.modalwin.VideoSavedWindow();
                            oAlert.bind('close', $.proxy(this._onSavedWindowClosed, this));
                            oAlert.bind('visituserprofilepage', $.proxy(this._handleVisitingVideoPageRequested, this));
                            oAlert.show();
                        }
                    }

                } else {
                    $(saveButtonText).html(this._localize('btnSave'));
                    $(saveButtonImg).addClass("watchlr-text watch-later-button-text");
                }

                // hide the border after 1 second
                setTimeout($.proxy(function() {
                    // if mouse is not over share button or video,
                    // hide the border
                    var selectedVideo = this.selectedVideo;
                    if (!selectedVideo.shareButtonSelected &&
                        !selectedVideo.videoSelected &&
                        !this.selectedVideo.savingVideo &&
                        !this.selectedVideo.likingVideo)
                    {
                        $(this.kikinVideoBorder).fadeOut();
                    }
                }, this), 1000);
            }
        } catch (err) {
            alert('from: updateButtonState of base KikinVideoAdapter. \nReason:' + err);
            // $kat.trackError({from: "updateButtonState of base KikinVideoAdapter", exception:err});
        }
	},

    /** When video is liked. */
    _onVideoLiked: function(data) {
        try {
            // this.debug("Data received from server:" + data);
            if(this.selectedVideo){

                var res = null;
                if (typeof data == "object") {
                    res = data;
                } else {
                    res = JSON.decode(data);
                }

                // this.debug("On video liked:" + JSON.encode(res));

                var videoLikedSuccessfully = false;
                if (res && res.success) {
                    videoLikedSuccessfully = true;
                } else {
                    if (res) {
                        switch (res.code) {

                            case 400: {
                                videoLikedSuccessfully = true;
                                break;
                            }

                            case 401: {
                                // this.debug("Session sent was an invalid session:" + $ks.KikinPlugin.getKke("_KVS"));
                                var oAlert = new $cwui.modalwin.FacebookConnectWindow();
                                oAlert.bind('close', $.proxy(this._handleFacebookConnectionCancelled, this));
                                oAlert.bind('connect', $.proxy(this._handleFacebookConnectionRequested, this));
                                oAlert.bind('visituserprofilepage', $.proxy(this._handleVisitingVideoPageRequested, this));
                                oAlert.show();
                                break;
                            }

                            default: {
                                if (!this.selectedVideo.liked) {
                                    var oAlert = new $cwui.modalwin.AlertWindow(
                                        this._localize('errorDlgLikeTitle'),
                                        this._localize('errorDlgLikeMsg')
                                    );
                                    oAlert.show();
                                } /*else {
                                    var oAlert = new $cwui.modalwin.AlertWindow(
                                        this._localize('errorDlgUnlikeTitle'),
                                        this._localize('errorDlgUnlikeMsg')
                                    );
                                    oAlert.show();
                                }  */
                                alert("from: _onVideoLiked of base KikinVideoAdapter. \nReason:" + err);

                                // $kat.trackError({from: "_onVideoLiked of base KikinVideoAdapter", msg:"Unable to like video. Error code:" + res.code + ", Error:" + res.error});
                            }
                        }
                    } else {
                        if (!this.selectedVideo.liked) {
                            var oAlert = new $cwui.modalwin.AlertWindow(
                                this._localize('errorDlgLikeTitle'),
                                this._localize('errorDlgLikeMsg')
                            );
                            oAlert.show();
                        } /*else {
                            var oAlert = new $cwui.modalwin.AlertWindow(
                                this._localize('errorDlgUnlikeTitle'),
                                this._localize('errorDlgUnlikeMsg')
                            );
                            oAlert.show();
                        }   */
                        alert("from: _onVideoLiked of base KikinVideoAdapter. \nReason:" + err);
                        // $kat.trackError({from: "_onVideoLiked of base KikinVideoAdapter", msg:"Unable to like video. Reason:" + (res ? res.error : "Result is null")});
                    }
                }

                var likeBtnImage = $(this.kikinVideoBorder).find('#like-btn-img');
                var likeBtnText = $(this.kikinVideoBorder).find('#like-btn-text');
                if (videoLikedSuccessfully) {
                    this.selectedVideo.likingVideo = false;
                    if (res.result) {
                        var oResult = res.result;
                        if (typeof oResult.liked == 'boolean')
                            this.selectedVideo.liked = oResult.liked;

                        if (typeof oResult.likes == 'number')
                            this.selectedVideo.likes = oResult.likes;
                    }


                    // var kikinLikeBtnText = $(this.kikinVideoBorder).find('#kikinLikeBtnText');
                    if (this.selectedVideo.liked) {
                        $(likeBtnImage).removeClass();
                        $(likeBtnImage).addClass('watchlr-image like-button-image');
                        $(likeBtnText).html(this._localize('liked'));
                        // $(kikinLikeBtnText).css('color', '#FF0000');
                    } else {
                        $(likeBtnImage).removeClass();
                        $(likeBtnImage).addClass('watchlr-image unlike-button-image');
                        // $(kikinLikeBtnText).css('color', '#505050');
                    }
                } else {
                    if (!this.selectedVideo.liked) {
                        $(likeBtnImage).removeClass();
                        $(likeBtnImage).addClass('watchlr-image like-button-image');
                        $(likeBtnText).html(this._localize('like'));
                        // $(kikinLikeBtnText).css('color', '#FF0000');
                    } else {
                        $(likeBtnImage).removeClass();
                        $(likeBtnImage).addClass('watchlr-image unlike-button-image');
                        // $(kikinLikeBtnText).css('color', '#505050');
                    }
                }

                // hide the border after 1 second
                setTimeout($.proxy(function() {
                    // if mouse is not over share button or video,
                    // hide the border
                    var selectedVideo = this.selectedVideo;
                    if (!selectedVideo.shareButtonSelected &&
                        !selectedVideo.videoSelected &&
                        !this.selectedVideo.savingVideo &&
                        !this.selectedVideo.likingVideo)
                    {
                        $(this.kikinVideoBorder).fadeOut();
                    }
                }, this), 1000);
            }
        } catch (err) {
            alert("From: _onVideoLiked of base KikinVideoAdapter. \nReason:" + err);
            //$kat.trackError({from: "_onVideoLiked of base KikinVideoAdapter", exception:err});
        }
	},

    _onSavedWindowClosed: function(evt, showMessageUnchecked) {
        try {
            if (showMessageUnchecked) {
                 $cws.WatchlrRequests.sendUpdateUserProfileRequest($.proxy(this._onUserProfileUpdated, this));
            }
        } catch (err) {
            alert("From: _onSavedWindowClosed of base KikinVideoAdapter. \nReason:" + err);
            // $kat.trackError
        }
    },

    _onPushToFacebookWindowClosed: function(evt, pushToFcaebook) {
        try {
            if (pushToFcaebook == '0' || pushToFcaebook == '1') {
                $cws.WatchlrRequests.sendUpdateUserPreferenceRequest($.proxy(this._onUserProfileUpdated, this), pushToFcaebook);
            }

            if (!this.selectedVideo.liked) {
                $cws.WatchlrRequests.sendVideoLikedRequest($.proxy(this._onVideoLiked, this), this.selectedVideo.url);
                /*$kat.track('Video', 'LikeVideoClk', {
                    campaign: window.location.host
                });*/
            } else {
                $cws.WatchlrRequests.sendVideoUnlikedRequest($.proxy(this._onVideoLiked, this), this.selectedVideo.url);
                /*$kat.track('Video', 'UnlikeVideoClk', {
                    campaign: window.location.host
                });*/
            }
        } catch (err) {
            alert("From: _onPushToFacebookWindowClosed of base KikinVideoAdapter. \nReason:" + err);
            // $kat.trackError
        }
    },

    _onUserProfileUpdated: function(data) {
        var str = "";
        for (var i in data) {
            str += i + ": " + data[i] + "\r\n";
        }
        this.debug(str);
    },

	/**
	 * @param {String}
	 */
	_localize: function(_key){
		return $cwc.Locale.get('KikinVideo', _key);
	},

    onUserProfileReceived: function(data) {
        this.debug("User profile info received.");
        var res = null;
        if (typeof data == 'object') {
            res = data;
        } else {
            res = JSON.decode(data);
        }

        if (res && res.success && res.result && res.result.preferences && res.result.preferences.syndicate == 2) {
            this._showFbPushDialog = true;
        }

        // It may happen that user is not signed in and try to like the
        // video. At that time we have to make a call to server to fetch user info
        // so that we can decide whether we want to show the first liked video message
        if (this.selectedVideo && this.selectedVideo.likingVideo) {
            // If we don't have to show the push to facebook dialog, then make the request to server
            // else we are going to make the call when user closes the push to facebook dialog.
            if (this._showFbPushDialog) {
                var oAlert = new $cwui.modalwin.FirstVideoLikedWindow();
                oAlert.bind('close', $.proxy(this._onPushToFacebookWindowClosed, this));
                oAlert.bind('visituserprofilepage', $.proxy(this._handleVisitingVideoPageRequested, this));
                oAlert.show();
            } else {
                if (!this.selectedVideo.liked) {
                    $cws.WatchlrRequests.sendVideoLikedRequest($.proxy(this._onVideoLiked, this), this.selectedVideo.url);
                    /*$kat.track('Video', 'LikeVideoClk', {
                        campaign: window.location.host
                    });*/
                } else {
                    $cws.WatchlrRequests.sendVideoUnlikedRequest($.proxy(this._onVideoLiked, this), this.selectedVideo.url);
                    /*$kat.track('Video', 'UnlikeVideoClk', {
                        campaign: window.location.host
                    });*/
                }
            }
        }
    },

    _onVideosInfoReceived: function(data) {
        var res = null;
        if (typeof data == 'object') {
            res = data;
        } else {
            res = JSON.decode(data);
        }

        // this.debug("Received video info:" + str);

        if (res && res.success && res.result) {
            if (res.result.videos && res.result.videos.length > 0) {
                for (var i = 0; i < res.result.videos.length; i++) {
                    var videoInfo = res.result.videos[i];
                    if (typeof videoInfo.id == 'number') {
                        var videoIndex = videoInfo.id - 1;
                        if (typeof videoInfo.liked == 'boolean') {
                            this.videos[videoIndex].liked = videoInfo.liked;
                        }

                        if (typeof videoInfo.saved == 'boolean') {
                            this.videos[videoIndex].saved = videoInfo.saved;
                        }

                        if (typeof videoInfo.likes == 'number') {
                            this.videos[videoIndex].likes = videoInfo.likes;
                        }

                        if (typeof videoInfo.saves == 'number') {
                            this.videos[videoIndex].saves = videoInfo.saves;
                        }
                    }
                }
            }

            if (res.result.user && res.result.user.preferences && res.result.user.preferences.syndicate == 2) {
                this._showFbPushDialog = true;
            }
        }
    }

});
/**
 * @package com.watchlr.hosts.defaultEngine.adapters
 */

$cwh.adapters.KikinSiteAdapter.extend("com.watchlr.hosts.defaultEngine.adapters.KikinSiteAdapter", {}, {

	init: function() {
    },

	run: function() {

        // We only run KikinVideo adapter if kikin video experiment is set
        try {
            var kva = $cwh.adapters.KikinVideoAdapter.getInstance();
            if (kva) kva.attach();
        } catch(e) {
            alert("from: default_site_adapter. \nReason:" + e);
            // $kat.trackError({ from: 'default_site_adapter', exception: e, msg: 'unable to create video adapter'});
        }
	}
});

/**
 * @package com.watchlr.hosts.defaultEngine.adapters
 */
$cwh.adapters.KikinVideoAdapter.extend("com.watchlr.hosts.defaultEngine.adapters.KikinVideoAdapter", {}, {
    /* @override */
    attach: function() {
        this._super();
    }
});

/**
 * @package com.watchlr.hosts.espn.adapters
 */

$cwh.adapters.KikinSiteAdapter.extend("com.watchlr.hosts.espn.adapters.KikinSiteAdapter", {}, {

    run: function() {
        // We only add KikinVideo adapter if kikin video experiment is set
        try {
            var kva = $cwh.adapters.KikinVideoAdapter.getInstance();
            if (kva) kva.attach();
        } catch(e) {
            alert("From: espn_site_adapter. \nReason:" + e);
            //$kat.trackError({ from: 'espn_site_adapter', exception: e, msg: 'unable to create video adapter'});
        }
	}
});
/**
 * @package com.watchlr.hosts.youtube.adapters
 */
$cwh.adapters.KikinSiteAdapter.extend("com.watchlr.hosts.youtube.adapters.KikinSiteAdapter", {}, {
	
	run: function() {

        try {
	    	if(0==window.location.pathname.indexOf('/results')){
	    		// var isva = new $kh.adapters.InSituVideoAdapter();
	    		// if (isva) isva.attach();
	    	}
		} catch(e) {}

        try {
            var kva = $cwh.adapters.KikinVideoAdapter.getInstance();
            if (kva) kva.attach();
        } catch(e) {
            alert("From: youtube_site_adapter.\nReason: " + e);
            // $kat.trackError({ from: 'youtube_site_adapter', exception: e, msg: 'unable to create video adapter'});
        }
	}
	
});
/**
 * @package com.watchlr.hosts.cnn.adapters
 */

$cwh.adapters.KikinVideoAdapter.extend("com.watchlr.hosts.cnn.adapters.KikinVideoAdapter", {}, {

	/* @override */
	attach: function() {
        //if (/cnn\.com\/video/.test(window.document.location.href)) {
            // this.debug("Hooking into cnn.com/video api");
            try {
                if (window.CVP && window.CVP.instances) {
                    for (var i in window.CVP.instances) {
                        var original = window.CVP.instances[i].onContentBegin;
                        window.CVP.instances[i].onContentBegin = $.proxy(function() {
                            try {
                                this._onVideoUrlChange(window.CVP.instances[i], arguments[0]);
                                return original.apply(this, arguments);
                            } catch (e) {
                                alert("From: attach of cnn's KikinVideoAdapter.\nReason:" + e);
                                // $kat.trackError({from:"attach of cnn's KikinVideoAdapter", msg: "Unable to call cnn's original onContentBegin callback", exception:e});
                            }
                        }, this);
                    }
                }

            } catch (err) {
                alert("From: attach of cnn's KikinVideoAdapter. \nReason:" + err);
                // $kat.trackError({from:"attach of cnn's KikinVideoAdapter", msg: "Unable to wrap onContentBegin callback", exception:err});
            }
        // }
        this._super();
	},

    /**
    * find all the videos on the page
    */
    _findFlashVideoCandidates: function() {
        var embeds = this._super();

        var images = $('img');
        // this.debug('Found ' + images.length + ' images');
        for (var i = 0; i < images.length; i++) {
            embeds.push(images[i]);
        }

        return embeds;
    },

    _onVideoUrlChange : function(target, videoId) {
        try {
            // this.debug('Changed video id:' + videoId + " for target:" + target.options.id);
            if (this.videos) {
                var embed = $('#' + target.options.id);
                if (embed && embed.kikinVideoId) {
                    // this.debug("Video id associated with changed video target:" + embed.kikinVideoId);
                    this.videos[embed.kikinVideoId - 1].url = "http://www.cnn.com/video/?/video/" + videoId;
                    this.videos[embed.kikinVideoId - 1].saved = false;
                    this.videos[embed.kikinVideoId - 1].tracked = false;

                    this._videosFound = this.videos.length;
                    /*$kat.track('VideoAdapterEvt', 'SupportedVideoFound', {
                        campaign: window.location.host
                    });*/

                    new $cws.WatchlrRequests.sendVideosInfoRequest($.proxy(this._onVideosInfoReceived, this), this.videos);
                }
            }
        } catch (err) {
            alert("From: _onVideoUrlChange of cnn's KikinVideoAdapter. \n Reason:" + err);
            // $kat.trackError({from:"_onVideoUrlChange of cnn's KikinVideoAdapter", msg: "Unable to change video URL on video change", exception:err});
        }
    }
});/**
 * @package com.watchlr.hosts.youtube.adapters
 */
$cwh.adapters.KikinVideoAdapter.extend("com.watchlr.hosts.youtube.adapters.KikinVideoAdapter", {}, {

	/* @override */
	attach: function() {
        this._super();
	},

    _findVideoUrl: function(embed) {
        try {
            var videoUrl = this._super(embed);
            if (!videoUrl) {
                var videoId = this._getNodeValue(embed, 'data-youtube-id');
                if (videoId) {
                    videoUrl = 'http://www.youtube.com/watch?v=' + videoId;
                }
            }

            return videoUrl;
        } catch (err) {
            alert("From: _findVideoUrl of youtube's KikinVideoAdapter.\nReason: " + err);
            // $kat.trackError({from: "_findVideoUrl of youtube's KikinVideoAdapter.", msg:"Error while finding video url for video tag.", exception:err});
        }

        return null;
    }
});/**
 * @package com.watchlr.hosts.cbsnews.adapters
 */

$cwh.adapters.KikinSiteAdapter.extend("com.watchlr.hosts.cbsnews.adapters.KikinSiteAdapter", {}, {

    run: function() {
        // We only add KikinVideo adapter if kikin video experiment is set
        try {
            var kva = $cwh.adapters.KikinVideoAdapter.getInstance();
            if (kva) kva.attach();
        } catch(e) {
            alert("From: cbs_news_site_adapter. \nReason:" + e);
            //$kat.trackError({ from: 'cbs_news_site_adapter', exception: e, msg: 'unable to create video adapter'});
        }
	}
});
/**
 * @package com.watchlr.hosts.bing.adapters
 */
$cwh.adapters.KikinSiteAdapter.extend("com.watchlr.hosts.bing.adapters.KikinSiteAdapter", {}, {

	run: function() {
		// only for the search pages
		if (window.location.href.match(/^http:\/\/www\.bing\.com\/search(.*)/i)) {
			this.injectIntoSearchPage();
		}

        try {
            var kva = $cwh.adapters.KikinVideoAdapter.getInstance();
            if (kva) kva.attach();
        } catch(e) {
            alert("From: bing_site_adapter. \nReason:" + e);
            // $kat.trackError({ from: 'bing_site_adapter', exception: e, msg: 'unable to create video adapter'});
        }
	},
	
	injectIntoSearchPage: function() {
    	try {
			// attach to the videos
	    	var isva = new $kh.adapters.InSituVideoAdapter();
	    	if (isva) isva.attach();

    	} catch(e) {
            alert("From: injectIntoSearchPage of bing KikinSiteAdapter. \nReason:" + e);
			// $kat.trackError({ from: 'site_adapter', exception: e, msg: 'injectiong failed in bing'});
    	}
	}
	
});
/**
 * @package com.watchlr.hosts.bing.adapters
 */

$cwh.adapters.InSituVideoAdapter.extend("com.watchlr.hosts.bing.adapters.InSituVideoAdapter", {}, {

	attach: function() {}

//	attach: function() {
//		var stats = $kh.adapters.InSituVideoAdapter.stats.reset();
//
//    	// add needed styles
//		$ku.Styles.insert('InSituVideoStyles', $win.document);		
//		
//		// look the page for video images
//        $$('#results_container div.sc_vc_wa').each(function(videoDiv) {
//        	// get the host config (fails if not compatible)
//        	var hostConfig = this.getHostConfig(videoDiv);
//        	if (!hostConfig) {
//                stats.notSupported++;
//        		return;
//        	}
//        	
//        	// create our little beautiful icon
//            var name = hostConfig.name.toString(),
//            	imgLink = videoDiv.getElement('.vt_tl'),
//                // Create button overlay
//                overlay = new Element('div', {
//                    'class': 'kikinIsvOverlay kikinIsvGoogleOverlay'
//                }).inject(imgLink, 'top'),
//                button = new Element('div', {
//                    'class': 'kikinIsvButton'
//                }).inject(overlay),
//                arrow = new Element('div', {
//                    'class': 'kikinIsvOverlayArrow'
//                }).inject(button);
//            
//            var SMALL_THUMB_X = 80,
//            	SMALL_THUMB_Y = 60,
//            	BORDER_RAD = 2;
//
//            overlay.setStyles({
//        		width: imgLink.offsetWidth,
//        		height: imgLink.offsetHeight
//            });
//
//            button.setStyles({
//                marginTop:button.getStyle('marginTop').toInt()+imgLink.offsetHeight-SMALL_THUMB_Y-BORDER_RAD*2,
//                marginLeft:button.getStyle('marginLeft').toInt()+imgLink.offsetWidth-SMALL_THUMB_X-BORDER_RAD*2
//            });
//            $ku.Element.setBrowserClasses(button);
//
//			var handler = this.onClickVideoThumbnail.bind(this);
//            
//            // Remove bing's overlay play button
//            videoDiv.getElement('.vt_vsp').dispose();
//            imgLink.set('onMouseOver', '').set('onMouseDown', '').removeEvents('mouseover').removeEvents('mouseout');
//            imgLink.removeClass('vt_stl');
//            imgLink.getElements('.vt_vp').dispose();
//            imgLink.getElements('.vt_vsm').dispose();
//
//            // Attach event to button for video play
//            overlay.addEvent('click', handler);
//            
//            stats.supported++;
//		}, this);
//	},
//	
//	getHostConfig: function(videoDiv) {
//		var link;
//		
//		// try to get the link
//        if(link = videoDiv.getElement('.sc_m12 a')) {
//        	// is this url supported?
//        	var supportedHosts = $kc.FeaturesConfig.plugins.InSituVideoFeature.config.supportedHosts,
//        		hostConfig = supportedHosts[$ku.String.getHostName(link.href)];
//            return hostConfig;
//		}
//        
//		return null;
//	},
//
//	onClickVideoThumbnail: function(e) {
//	    e.stop();
//	    
//	    // create once the video panel that will show the videos
//	    if (!this.videoPanel) {
//			this.videoPanel = new $kf.insituvideo.InSituVideoPanel({
//				document: $win.document
//			});	    
//	    }
//	    
//	    // get some infos
//	    var videoDiv = $(e.target).getParent('div.sc_vc_wa'),
//	    	imgLink = videoDiv.getElement('.vt_tl'),
//	    	img = imgLink.getElement('img'),
//	    	link = videoDiv.getElement('.sc_m12 a')
//	        hostConfig = this.getHostConfig(videoDiv);
//	    
//	    // set infos in the right panel
//	    this.videoPanel.setInfos({
//    		title: img.get('alt'),
//    		rating: '',
//			partnerId: $kf.core.FeaturesDisplayNames.ids.ORGANIC,
//			hostName: hostConfig.name,
//			url: link.get('href')
//	    });
//	    
//	    // set the player
//	    this.videoPanel.setPlayer(
//    		new $kf.insituvideo.InSituDefaultPlayer({
//				data: $kf.insituvideo.InSituVideoFeature.getSwiffData(link),
//				document: $win.document
//			})
//	    );
//	    
//    	var imgHeight = imgLink.getSize().y || 90;
//    	var relElement = $('results_container') || $($win.document.body);
//		this.videoPanel.setStyle('left', relElement.getPosition().x);
//		this.videoPanel.setStyle('top', imgLink.getPosition().y-6+imgHeight);
//	    
//	    // show the panel and start playing
//	    this.videoPanel.open()
//	}
	
});
/**
 * @package com.watchlr.hosts.bing.adapters
 */

$cwh.adapters.KikinVideoAdapter.extend("com.watchlr.hosts.bing.adapters.KikinVideoAdapter", {}, {

	/* @override */
	attach: function() {
        this._super();
	}
});
/**
 * @package com.watchlr.hosts.youtube.adapters
 */
$cwh.adapters.InSituVideoAdapter.extend("com.watchlr.hosts.youtube.adapters.InSituVideoAdapter", {}, {
	 
	/*attach: function() {
    	// add needed styles
		$ku.Styles.insert('InSituVideoStyles', $win.document);
		var handler = this.onClickVideoThumbnail.bind(this);
        
		// look the page for video images
        $$('a.ux-thumb-wrap').each(function(link) {
        	// is this link useful?
        	var match = link.href.match(/watch\?(.*)/);
        	if (!match || match.length == 0) return;
        	
        	// is there a action menu?
        	var actions = link.getElement('.video-actions');
        	if (!actions) return;
        	
        	new Element('button', {
        		'aria-pressed': 'false',
        		'role': 'button',
        		'title': '',
        		'onclick': 'return false',
        		'type': 'button',
        		'class': 'master-sprite start yt-uix-button yt-uix-button-short yt-uix-tooltip',
        		'styles': {
        			'width': '58px'
        		},
        		'html': '<img alt="" src="http://s.ytimg.com/yt/img/pixel-vfl3z5WfW.gif" style="background-image: url(\'http://kikin-dev.com/kikin/img/tiny-kikin.png\'); height: 16px; width: 16px;"> <span class="yt-uix-button-content"><span class="play-label">Play</span></span>'
        	})
            .addEvent('click', handler)
        	.inject(actions, 'top');
		}, this);
	},

	onClickVideoThumbnail: function(e) {
	    e.stop();
	    
	    // create once the video panel that will show the videos
	    if (!this.videoPanel) {
			this.videoPanel = new $kf.insituvideo.InSituVideoPanel({
				document: $win.document
			});	    
	    }
	    
	    // get some infos
	    var elContainer = null,
	    	videoUrl = null,
	    	videoTitle = null,
	    	target = $(e.target);
	    
	    // case1: result page videos
	    if (elContainer = target.getParent('.result-item')) {
	        var elTitle = elContainer.getElement('h3 a'),
	        	elVideoImg = elContainer.getElement('.video-thumb img');
	        
	        videoUrl = elTitle.get('href');
	        videoTitle = elTitle.get('html');
	    
	    // case2: watch page videos
	    } else if (elContainer = target.getParent('.video-list-item')) {
	        var elTitle = elContainer.getElement('span.title'),
	        	elVideoLink = elContainer.getElement('a'),
	        	elVideoImg = elContainer.getElement('.video-thumb img');
	        
	        videoUrl = elVideoLink.get('href');
	        videoTitle = elTitle.get('html');

	    // case3: homepage
	    } else if (elContainer = target.getParent('.feeditem')) {
	    	 var elTitle = elContainer.getElement('h3 a'),
	        	elVideoImg = elContainer.getElement('.video-thumb img');

	        videoUrl = elTitle.get('href');
	        videoTitle = elTitle.get('html');
	    } else {
	    	return;
	    }
	    
	    // set infos in the right panel
	    this.videoPanel.setInfos({
    		title: videoTitle,
    		rating: '',
			partnerId: $kf.core.FeaturesDisplayNames.ids.YOUTUBE,
			hostName: 'Youtube',
			url: videoUrl
	    });
	    
		var videoId = videoUrl.match(/watch\?(.*)/)[1].parseQueryString().v,
			src = 'http://www.youtube.com/v/'+videoId+'?border=0&fs=1&autoplay=1';
	    
	    // set the player
	    this.videoPanel.setPlayer(
    		new $kf.insituvideo.InSituDefaultPlayer({
				data: {
    				src: src,
    				vars: { autoplay: true }
    			},
				document: $win.document
			})
	    );
	    
    	var imgSize = elVideoImg.getSize(),
    		imgWidth = imgSize.x,
    		imgHeight = imgSize.y || 66,
    		winWidth = $($win).getWidth(),
    		imgPosX = elContainer.getPosition().x,
    		left = (imgPosX + 660 < winWidth) ? imgPosX : winWidth - 660 - 20,
    		top = elVideoImg.getPosition().y+imgHeight;
    	
		this.videoPanel.setStyle('left', left);
		this.videoPanel.setStyle('top', top);
	    
	    // show the panel and start playing
	    this.videoPanel.open()
	}  */
			
});/**
 * @package com.watchlr.hosts.cbsnews.adapters
 */

$cwh.adapters.KikinVideoAdapter.extend("com.watchlr.hosts.cbsnews.adapters.KikinVideoAdapter", {}, {

	/* @override */
	attach: function() {
        // this.debug("Hooking into CBS news video api");
        this._super();
	},

    /**
    * find all the videos on the page
    */
    _findFlashVideoCandidates: function() {
        var embeds = this.parent();

        try {
            if (!this.videos || (this.videos.length == 0)) {
                var videoElement = window.CBSVideo.playerId ? $("#" + window.CBSVideo.playerId) : null;
                if (!videoElement) {
                    this._addOnClickEvent($('#flashvideocontent'));
                } else {
                    try {
                        var videoFlashVars = decodeURIComponent(window.CBSVideo.getFlashVars());
                        var re = /&contentValue=([0-9,]+)&/;
                        var videoId = re.exec(videoFlashVars)[1];

                        // this.debug('Video Id found:' + videoId);
                        if (!videoId || videoId.indexOf(',') != -1) {
                            videoId = window.CBSVideo.activeId;
                        }

                        // var embed = window.CBSVideo.playerId ? $('#' + window.CBSVideo.playerId) : null;
                        // this.debug('Embed tag found:' + videoElement);

                        if (videoId) {
                            var url = "http://www.cbsnews.com/video/watch/?video_id=" + videoId;
                            this._addVideo(videoElement, url);
                        }
                    } catch (err) {
                        alert("From: _findFlashVideoCandidates of CBS news. \nReason:" + err);
                        // $kat.trackError({from:"_findFlashVideoCandidates of CBS news", msg: "Unable to get falshvars using CBS JS API.", exception:err})
                    }
                }

                if (this.videos.length > this._videosFound) {
                    this._videosFound = this.videos.length;
                    /*$kat.track('VideoAdapterEvt', 'SupportedVideoFound', {
                        campaign: window.location.host
                    });*/

                    new $cws.WatchlrRequests.sendVideosInfoRequest($.proxy(this._onVideosInfoReceived.bind, this), this.videos);
                }

                if (window.cbsiPlayer) {
                    window._onVideoPlayerStateChange = $.proxy(this._onVideoPlayerStateChange.bind, this);
                    window.cbsiPlayer.addEventJSCallback('onStateChange_cbsi', '_onVideoPlayerStateChange');
                }
            }

        } catch (outerErr) {
            alert('From: _findFlashVideoCandidates of CBS news. \nReason:' + outerErr);
            // $kat.trackError({from:"_findFlashVideoCandidates of CBS news", msg: "Unable to find CBS video element.", exception:outerErr})
        }

        return embeds;
    },

    /**
     * Adds onClick event to all the child nodes of the element
     * @param elem
     */
    _addOnClickEvent: function(elem) {
        var childNodes = elem.childNodes;
        for (var i = 0; i < childNodes.length; i++) {
            var node = $(childNodes[i]);
            $(node).click($.proxy(this._onVideoElementClicked.bind, this));
            if (node.childNodes && node.childNodes.length > 0) {
                this._addOnClickEvent(node);
            }
        }
    },

    /**
     * When user clicks on an image element to play video
     */
    _onVideoElementClicked: function() {
        var videoElement = $('#flashvideocontent');
        if (videoElement) {
            setTimeout($.proxy(this._onEmbedTagInserted, this, videoElement), 500);
        }
    },

    /**
     * When Image element is converted to video element
     * @param videoElement
     */
    _onEmbedTagInserted: function(videoElement) {
        var hasnewVideos = false;
        var objectTags = videoElement.getElementsByTagName('object');
        if (objectTags.length > 0) {
            hasnewVideos = true;
        } else {
            var embedTags = videoElement.getElementsByTagName('embed');
            if (embedTags.length > 0) {
                hasnewVideos = true;
            } else {
                var iframes = videoElement.getElementsByTagName('iframe');
                if (iframes.length > 0) {
                    hasnewVideos = true;
                } else {
                    setTimeout($.proxy(this._onEmbedTagInserted.bind, this, videoElement), 500);
                }
            }
        }

        if (hasnewVideos) {
            var embeds = this._findFlashVideoCandidates();
            if (embeds) {
                this._findFlashVideos(embeds);
            }
        }
    },

    /** When CBS video player state changes. */
    _onVideoPlayerStateChange : function() {
        if (arguments.length > 1 && (arguments[0] == 1) && window.CBSVideo.activeId) {
            this._onVideoUrlChange(window.CBSVideo.activeId);
        }
    },

    /**
     * When CBS
     * @param videoId
     */
    _onVideoUrlChange : function(videoId) {
        try {
            // this.debug("Video Id found:" + videoId);
            if (this.videos && (this.videos.length == 1)) {
                var lastSavedUrl = this.videos[0].url;
                this.videos[0].url = "http://www.cbsnews.com/video/watch/?video_id=" + videoId;
                if (lastSavedUrl != this.videos[0].url) {
                    this.videos[0].saved = false;
                    this.videos[0].tracked = false;

                    this._videosFound = this.videos.length;
                    /*$kat.track('VideoAdapterEvt', 'SupportedVideoFound', {
                        campaign: window.location.host
                    });*/

                    new $cws.WatchlrRequests.sendVideosInfoRequest($.proxy(this._onVideosInfoReceived, this), this.videos);

                }
            }
        } catch (err) {
            alert("From: _onVideoUrlChange of CBS news KikinVideoAdapter. \nReason:" + err);
            // $kat.trackError({from:"_onVideoUrlChange of CBS news KikinVideoAdapter", msg: "Unable to change video URL on video change", exception:err});
        }
    }
});/**
 * @package com.watchlr.hosts.cnn.adapters
 */

$cwh.adapters.KikinSiteAdapter.extend("com.watchlr.hosts.cnn.adapters.KikinSiteAdapter", {}, {

    run: function() {
        // We only add KikinVideo adapter if kikin video experiment is set
        try {
            var kva = $cwh.adapters.KikinVideoAdapter.getInstance();
            if (kva) kva.attach();
        } catch(e) {
            alert("From: cnn_site_adapter. \nReason:" + e);
            //$kat.trackError({ from: 'cnn_site_adapter', exception: e, msg: 'unable to create video adapter'});
        }
	}
});
/**
 * @package com.watchlr.hosts.yahoo.adapters
 */
$cwh.adapters.KikinVideoAdapter.extend("com.watchlr.hosts.yahoo.adapters.KikinVideoAdapter", {}, {
	/* @override */
	attach: function() {
        this._super();
	},

    _findFlashVideoCandidates: function() {
        $('ul.c-thumb.video li').each($.proxy(this._addKikinVideoBorder, this));
        return this._super();
    },

    _addKikinVideoBorder: function(pos, img) {
        try {
            var videoUrl = this.getVideoUrl(img);
            this.debug("URL for image element:" + videoUrl);
            if (videoUrl) {
                for (var i = 0; i < this.services.length; i++) {
                    if (!this.services[i].url_regex)
                        continue;
                    var match = {passed: false};
                    this._extractId(videoUrl, this.services[i].url_regex, match);
                    if (match.passed && match.video_id && match.video_id.length > 1) {
                        if (typeof(this.services[i].url) == 'function') {
                            videoUrl = this.services[i].url(match.video_id);
                        } else {
                            videoUrl = this.services[i].url + match.video_id[1];
                        }

                        if (videoUrl) {
                            $(img).mouseover($.proxy(this._onVideoThumbnailMouseOver, this));
                            $(img).mouseleave($.proxy(this._onVideoThumbnailMouseOut, this));


                            var video = {
                                url                 : videoUrl,
                                mouseover           : null,
                                mouseout            : null,
                                saved               : false,
                                videoSelected       : false,
                                saveButtonSelected  : false,
                                coordinates         : null
                            };

                            // calculate the videoId
                            img.kikinVideoId = (this.videos.length + 1);
                            this.videos.push(video);
                            break;
                        }
                    }
                }
            }
        } catch (err) {
            alert("From: addKikinVideoBorder of Yahoo Video adapter. \nReason: " + err);
        }
    },

    getVideoUrl: function(videoDiv) {
        // try to get the link
        var link = $(videoDiv).find('a');
        if(link) {
            // get rurl parameter
            var href = decodeURIComponent($(link).attr('href')),
                    params = href.parseQueryString(),
                    url = (params && params.rurl) ? params.rurl.replace(/&amp;/g, '&') : null;
            return url;
        }
        alert(link);
        return null;
    },

    _onVideoThumbnailMouseOver : function(e) {
        try {
            var target = e.target;
            this.debug("Mouseover target kikin video id:" + target.kikinVideoId);
            if (target && target.kikinVideoId) {

                var selectedVideo = this.videos[target.kikinVideoId - 1];

                // if selected video is different than the video saved in the object
                // hide the saved object video if it is visible
                if (this.selectedVideo && (this.selectedVideo != selectedVideo)) {
                    // this.kikinVideoBorder.style.visibility = "hidden";
                    $(this.kikinVideoBorder).fadeOut();
                    this.selectedVideo.videoSelected = false;
                    this.selectedVideo.shareButtonSelected = false;
                }

                // set the new selected video
                this.selectedVideo = selectedVideo;

                // calculate the coordinates for video
                selectedVideo.coordinates = this._getVideoCoordinates(target);

                if (selectedVideo.coordinates) {
                    this.debug("Coordinates for video:" + selectedVideo.coordinates.left + ", " + selectedVideo.coordinates.top + ", " + selectedVideo.coordinates.width + ", " + selectedVideo.coordinates.height);
                    // draw the border around video
                    this._drawKikinBorder(selectedVideo.coordinates.left,
                                          selectedVideo.coordinates.top,
                                          selectedVideo.coordinates.width,
                                          selectedVideo.coordinates.height,
                                          selectedVideo.saved);
                }

                // this.debug("Border around selected video is visible: " + this.kikinVideoBorder.style.visibility);
                selectedVideo.videoSelected = true;

            }
        } catch (err) {
            alert("From: _onVideoThumbnailMouseOver of google's KikinVideoSearchAdapter.\nReason: " + err);
            // $kat.trackError({from: "_onVideoThumbnailMouseOver of google's KikinVideoSearchAdapter", exception:err});
        }
    },

    _onVideoThumbnailMouseOut : function(e) {
        try {
            var target = e.target;
            this.debug("Mouseover target kikin video id:" + target.kikinVideoId);
            if (target && target.kikinVideoId) {
                // set the selected video property to false
                var selectedVideo = this.videos[target.kikinVideoId - 1];
                selectedVideo.videoSelected = false;

                // hide the border after a second
                setTimeout($.proxy(function() {
                    var selectedVideo = this.selectedVideo;

                    // if mouse is not over the video or share button of the video
                    // hide the video
                    if (!selectedVideo.shareButtonSelected &&
                        !selectedVideo.videoSelected &&
                        !this.selectedVideo.savingVideo &&
                        !this.selectedVideo.likingVideo)
                    {
                        $(this.kikinVideoBorder).fadeOut();
                        //this.kikinVideoBorder.style.visibility = "hidden";
                    }
                }, this), 1000);
            }
        } catch (err) {
            alert("From: _onVideoThumbnailMouseOut of google's KikinVideoSearchAdapter.\nReason: " + err);
            // $kat.trackError({from: "_onVideoThumbnailMouseOut of google's KikinVideoSearchAdapter", exception:err});
        }
    }
});/**
 * @package com.watchlr.hosts.google.adapters
 */
$cwh.adapters.KikinVideoAdapter.extend("com.watchlr.hosts.google.adapters.KikinVideoAdapter", {}, {

    numberOfVideoElementCandidates: 0,
    viewerPageContainer : null,
    sameDirContainer : null,

	/* @override */
	attach: function() {
        if (window.location.href.match(/^http:\/\/www\.google\.com\/reader\/.*/)) {
            // this.debug("Called in google reader implementation.");
            this.viewerPageContainer = $("#viewer-page-container");
            if (this.viewerPageContainer) {
                this._applyPageModifyEvent(this.viewerPageContainer);
            }

            this.sameDirContainer = $("#entries");
            if (this.sameDirContainer) {
                this._applyPageModifyEvent(this.viewerPageContainer);
            }
        }

        this._super();
	},

    _applyPageModifyEvent: function(container) {
        if (container) {
            if (window.document.body.addEventListener) {
                window.document.body.addEventListener('DOMNodeInserted', $.proxy(this._firePageModifiedEvent, this), false);
            } else {
                $($(container).parent().get(0)).scroll($.proxt(this._firePageModifiedEvent, this));
                $(document.body).bind("mousewheel", $.proxy(this._firePageModifiedEvent, this));
                var nextEntryButton = $("#entries-down");
                $(nextEntryButton).click($.proxy(this._firePageModifiedEvent, this));
            }
        }
    },

    _firePageModifiedEvent: function() {
        try {
            // this.debug("google reader page modified event fired.");
            var target = null;
            // this.debug("ViewerPageContainer display style:" + $(this.viewerPageContainer).getStyle('display'));
            if (this.viewerPageContainer && $(this.viewerPageContainer).css('display') != "none") {
                target = $(this.viewerPageContainer);
            } else if (this.sameDirContainer) {
                target = $(this.sameDirContainer);
            }

            if (target) {
                // this.debug("Tagrget in _firePageModifiedEvent:" + target);
                var flashVideoCandidatesLength = $(target).find("iframe").length +
                                                 $(target).find("object").length +
                                                 $(target).find("embed").length;
                if (flashVideoCandidatesLength > this.numberOfVideoElementCandidates) {
                    var embeds = this._findFlashVideoCandidates();
                    if (embeds) {
                        this._findFlashVideos(embeds);
                    }
                }
            }
        } catch (e) {
            alert("From: on page scroll on google reader. \nReason: " + e);
            // $kat.trackError({from: 'on page scroll on google reader', msg: '', exception: e});
        }
    },

    /**
    * find all the videos on the page
    */
    _findFlashVideoCandidates: function() {
        var embeds = [];
        if (window.location.href.match(/^http:\/\/www\.google\.com\/reader\/.*/)) {
            // this.debug("Finding flash video candidates in google reader implementation.");
            var target = null;
            if (this.viewerPageContainer && $(this.viewerPageContainer).css('display') != "none") {
                target =  $(this.viewerPageContainer);
            } else if (this.sameDirContainer) {
                target = $(this.sameDirContainer);
            }

            if (target) {
                var embed_tags = $(target).find('embed');
                // this.debug('Found ' + embed_tags.length + ' embeds');
                for (var i = 0; i < embed_tags.length; i++) {
                    embeds.push(embed_tags[i]);
                }

                var objects = $(target).find('object');
                // this.debug('Found ' + objects.length + ' objects');
                for (var i = 0; i < objects.length; i++) {
                    if (!/<embed/i.test(objects[i].innerHTML) || (!/<object/i.test(objects[i].innerHTML))) {
                        embeds.push(objects[i]);
                    }
                }

                var iframes = $(target).find('iframe');
                // this.debug('Found ' + iframes.length + ' iframes');
                for (var i = 0; i < iframes.length; i++) {
                    embeds.push(iframes[i]);
                }

                this.numberOfVideoElementCandidates = (iframes.length + objects.length + embed_tags.length);
            }
        } else {
            // look the page for video images
            $('#res li.videobox a img[id*=vidthumb]').each($.proxy(this._addKikinVideoBorder, this));
            //single video result - http://www.google.com/search?hl=en&q=ducati+696
            $('#res table a img[id*=vidthumb]').each($.proxy(this._addKikinVideoBorder, this));

            embeds = this._super();
        }

        return embeds;
    },

    _addKikinVideoBorder: function(pos, img) {
        try {
            this.debug("Creating kikin border for img:" + img);
            var videoUrl = this.getVideoUrl(img);
            this.debug("URL for image element:" + videoUrl);
            if (videoUrl) {
                for (var i = 0; i < this.services.length; i++) {
                    if (!this.services[i].url_regex)
                        continue;
                    var match = {passed: false};
                    this._extractId(videoUrl, this.services[i].url_regex, match);
                    if (match.passed && match.video_id && match.video_id.length > 1) {
                        if (typeof(this.services[i].url) == 'function') {
                            videoUrl = this.services[i].url(match.video_id);
                        } else {
                            videoUrl = this.services[i].url + match.video_id[1];
                        }

                        if (videoUrl) {
                            var imgParent = $(img).parents('td').get(0);
                            $(imgParent).mouseover($.proxy(this._onVideoThumbnailMouseOver, this));
                            $(imgParent).mouseleave($.proxy(this._onVideoThumbnailMouseOut, this));


                            var video = {
                                url                 : videoUrl,
                                mouseover           : null,
                                mouseout            : null,
                                saved               : false,
                                videoSelected       : false,
                                saveButtonSelected  : false,
                                coordinates         : null
                            };

                            // calculate the videoId
                            img.kikinVideoId = (this.videos.length + 1);
                            this.videos.push(video);
                            break;
                        }
                    }
                }
            }
        } catch (err) {
            alert("From: addKikinVideoBorder of Google Video adapter. \nReason: " + err);
        }
    },

    getVideoUrl: function(img) {
        var imgParentTable = null;

		if(imgParentTable = $(img).parent('a').get(0)) {
            var url = imgParentTable.href,
                videoUrl = /url\?url=(.*)&rct=/i.exec(url);
            if (videoUrl && videoUrl.length > 1) {
                return decodeURIComponent(videoUrl[1]);
            }
        }

		return null;
    },

    _onVideoThumbnailMouseOver : function(e) {
        try {
            var target = $($(e.target).parents('table').get(0)).find('td a img');
            target = target.get(0);
            this.debug("Mouseover target kikin video id:" + target.kikinVideoId);
            if (target && target.kikinVideoId) {

                var selectedVideo = this.videos[target.kikinVideoId - 1];

                // if selected video is different than the video saved in the object
                // hide the saved object video if it is visible
                if (this.selectedVideo && (this.selectedVideo != selectedVideo)) {
                    // this.kikinVideoBorder.style.visibility = "hidden";
                    $(this.kikinVideoBorder).fadeOut();
                    this.selectedVideo.videoSelected = false;
                    this.selectedVideo.shareButtonSelected = false;
                }

                // set the new selected video
                this.selectedVideo = selectedVideo;

                // calculate the coordinates for video
                selectedVideo.coordinates = this._getVideoCoordinates($(target).parents('table').get(0));

                if (selectedVideo.coordinates) {
                    this.debug("Coordinates for video:" + selectedVideo.coordinates.left + ", " + selectedVideo.coordinates.top + ", " + selectedVideo.coordinates.width + ", " + selectedVideo.coordinates.height);
                    // draw the border around video
                    this._drawKikinBorder(selectedVideo.coordinates.left,
                                          selectedVideo.coordinates.top,
                                          selectedVideo.coordinates.width,
                                          selectedVideo.coordinates.height,
                                          selectedVideo.saved);
                }

                // this.debug("Border around selected video is visible: " + this.kikinVideoBorder.style.visibility);
                selectedVideo.videoSelected = true;

            }
        } catch (err) {
            alert("From: _onVideoThumbnailMouseOver of google's KikinVideoSearchAdapter.\nReason: " + err);
            // $kat.trackError({from: "_onVideoThumbnailMouseOver of google's KikinVideoSearchAdapter", exception:err});
        }
    },

    _onVideoThumbnailMouseOut : function(e) {
        try {
            var target = $($(e.target).parents('table').get(0)).find('td a img');
            target = target.get(0);
            this.debug("Mouseover target kikin video id:" + target.kikinVideoId);
            if (target && target.kikinVideoId) {
                // set the selected video property to false
                var selectedVideo = this.videos[target.kikinVideoId - 1];
                selectedVideo.videoSelected = false;

                // hide the border after a second
                setTimeout($.proxy(function() {
                    var selectedVideo = this.selectedVideo;

                    // if mouse is not over the video or share button of the video
                    // hide the video
                    if (!selectedVideo.shareButtonSelected &&
                        !selectedVideo.videoSelected &&
                        !this.selectedVideo.savingVideo &&
                        !this.selectedVideo.likingVideo)
                    {
                        $(this.kikinVideoBorder).fadeOut();
                        //this.kikinVideoBorder.style.visibility = "hidden";
                    }
                }, this), 1000);
            }
        } catch (err) {
            alert("From: _onVideoThumbnailMouseOut of google's KikinVideoSearchAdapter.\nReason: " + err);
            // $kat.trackError({from: "_onVideoThumbnailMouseOut of google's KikinVideoSearchAdapter", exception:err});
        }
    }
});
/**
 * @package com.watchlr.hosts.facebook.adapters
 */

$cwh.adapters.KikinSiteAdapter.extend("com.watchlr.hosts.facebook.adapters.KikinSiteAdapter", {}, {

    init: function() {},

    run: function() {
		try {

            // for facebook we need to run every time the hash changes
            var fn = $.proxy(function() {
                setTimeout($.proxy(this.injectIntoPage, this), 1000);
            }, this);

            if ($.browser.msie) window.document.body.onhashchange = fn
            else if ($.browser.mozilla || $.browser.webkit) window.addEventListener('hashchange', fn, false);

            setTimeout($.proxy(this.injectIntoPage, this), 1000);
        } catch(err) {
            alert("From: facebook_site_adapter.\nReason:" + err);
        }
	},

	injectIntoPage: function() {
		try {
            var kva = $cwh.adapters.KikinVideoAdapter.getInstance();
            if (kva) kva.attach();

        } catch(e) {
            alert("From: facebook_site_adapter. \nReason:" + e);
            // $kat.trackError({ from: 'facebook_site_adapter', exception: e, msg: 'unable to create video adapter'});
        }

	}
});
/**
 * @package com.kikin.hosts.espn.adapters
 */

$cwh.adapters.KikinVideoAdapter.extend("com.watchlr.hosts.espn.adapters.KikinVideoAdapter", {}, {

	/* @override */
	attach: function() {
        // this.debug("Hooking into espn.go.com video api");
        try {
            var original = window.espn.video.play;
            window.espn.video.play = $.proxy(function() {
                try {
                    if (arguments.length > 0) {
                        this._onVideoUrlChange(arguments[0]);
                        original.apply(this, arguments);
                    }
                } catch (e) {
                    alert("From: attach of espn's KikinVideoAdapter. \nReason:" + e);
                    // $kat.trackError({from:"attach of espn's KikinVideoAdapter", msg: "Unable to call espn's original espn.video.play function", exception:e});
                }
            }, this);
        } catch (err) {
            alert("From: attach of espn's KikinVideoAdapter. \nReason:" + err);
            // $kat.trackError({from:"attach of espn's KikinVideoAdapter", msg: "Unable to wrap espn.video.play function", exception:err});
        }

        this._super();
	},

    _onVideoUrlChange : function(videoId) {
        try {
            // this.debug("Video Id found:" + videoId);
            if (this.videos && (this.videos.length == 1)) {
                this.videos[0].url = "http://espn.go.com/video/clip?id=" + videoId;
                this.videos[0].saved = false;
                this.videos[0].tracked = false;

                this._videosFound = this.videos.length;
                /*$kat.track('VideoAdapterEvt', 'SupportedVideoFound', {
                    campaign: $win.location.host
                });*/

                new $cws.WatchlrRequests.sendVideosInfoRequest($.proxy(this._onVideosInfoReceived, this), this.videos);

            } else {
                setTimeout($.proxy(function() {
                   var embeds = this._findFlashVideoCandidates();
                    if (embeds)
                        this._findFlashVideos(embeds);
                    if (this.videos && (this.videos.length == 1)) {
                        this.videos[0].url = "http://espn.go.com/video/clip?id=" + videoId;
                        this.videos[0].saved = false;
                        this.videos[0].tracked = false;
                    }
                }, this), 1000);
            }
        } catch (err) {
            alert("From: _onVideoUrlChange of espn's KikinVideoAdapter. \nReason:" + err);
            // $kat.trackError({from:"_onVideoUrlChange of espn's KikinVideoAdapter", msg: "Unable to change video URL on video change", exception:err});
        }
    }
});/**
 * @package com.watchlr.hosts.google.adapters
 */
$cwh.adapters.KikinSiteAdapter.extend("com.watchlr.hosts.google.adapters.KikinSiteAdapter", {}, {

	run: function() {
		// only for the search pages
		if (window.location.href.match(/^http:\/\/www\.google\.[^\/]+\/(.*)/)) {
			this.injectIntoSearchPage();
		}

        try {
            var kva = $cwh.adapters.KikinVideoAdapter.getInstance();
            if (kva) kva.attach();
        } catch(e) {
            alert("From: google_site_adapter. \nReason: " + e);
            // $kat.trackError({ from: 'google_site_adapter', exception: e, msg: 'unable to create video adapter'});
        }
	},
	
	injectIntoSearchPage: function() {
		var fn = $.proxy(this.onHashHasChanged, this),
			body = window.document.body;
	
		if ($.browser.msie) {
			body.attachEvent('onkeyup', function() {
				body.onhashchange = fn;
				body.detachEvent('onkeyup', arguments.callee);
			});
			body.onhashchange = fn;
		} else if ($.browser.mozilla || $.browser.webkit)
			window.addEventListener('hashchange', fn, false);
		
		var usrAgent = window.navigator.userAgent.toLowerCase();
		// HACKY HACK: for ff3.5, there are no hashchange.
		if ($.browser.mozilla && (usrAgent.indexOf('firefox/3.5') > 0 || usrAgent.indexOf('firefox/3.0') > 0)) {
			var ffInject = function() {
				if (window.google && window.google.msg) {
					window.google.msg.listen(1, function() { return true; });
					window.google.msg.listen(0, function() { setTimeout(fn, 250); return true; });
				}
			};
			// wait for the page to be loaded or google.msg there
			if (window.google && window.google.msg) ffInject();
			else $(window).load(ffInject);
		}
		
		//check when coming from non-ajax search
		fn();
	},
	
	onHashHasChanged: function(e) {
		// delete old injection if there was one waiting

        if (this._delayedInject) clearTimeout(this._delayedInject);
    	this._delayedInject = setTimeout($.proxy(this.delayedInjection, this), 500);

	},
	
	delayedInjection: function() {
    	try {
			// attach to the videos
	    	// var isva = new $cwh.adapters.InSituVideoAdapter();
	    	// if (isva) isva.attach();
	    	
    		// We only add KikinVideo adapter if kikin video experiment is set
            try {
                var kva = $cwh.adapters.KikinVideoAdapter.getInstance();
                if (kva) kva.attach();
            } catch(e) {
                alert("From: google_site_adapter. \nReason: " + e);
                //$kat.trackError({ from: 'google_site_adapter', exception: e, msg: 'unable to create video adapter'});
            }

    	} catch(err) {
            alert("From: site_adapter. \nReason:" + err);
			// $kat.trackError({ from: 'site_adapter', exception: e, msg: 'injectiong failed in google'});
    	}
    	
    	this._delayedInject = null;
	}
			
});
/**
 * @package com.watchlr.hosts.google.adapters
 */
$cwh.adapters.InSituVideoAdapter.extend("com.watchlr.hosts.google.adapters.InSituVideoAdapter", {}, {

	_stats: null
	
	/*attach: function() {
		this._stats = $cwh.adapters.InSituVideoAdapter.stats.reset();

    	// add needed styles
		$cwu.Styles.insert('InSituVideoStyles', window.document);

		// look the page for video images
		$('#res li.videobox a img[id*=vidthumb]').each($.proxy(this._addVideoPlayback, this));
		//single video result - http://www.google.com/search?hl=en&q=ducati+696
		$('#res table a img[id*=vidthumb]').each($.proxy(this._addVideoPlayback, this));

        // track unsupported domains
        if (this._stats.unsupportedDomains.length > 0) {
            // $kat.track('InSituAdapterEvt','Unsupported', {campaign: this._stats.unsupportedDomains.join(',')});
        }
	},

	_addVideoPlayback: function(img) {
    	// get the host config (fails if not compatible)

    	var videoUrl = this.getVideoUrl(img),
    		supportedHosts = $kc.FeaturesConfig.plugins.InSituVideoFeature.config.supportedHosts,
			hostConfig = videoUrl ? supportedHosts[$ku.String.getHostName(videoUrl)] : null;

        if (!hostConfig) {
    		this._stats.notSupported++;
            if (videoUrl) this._stats.unsupportedDomains.push($ku.String.getHostName(videoUrl));
    		return;
    	}

        // create our little beautiful icon
        var name = hostConfig.name.toString(),
            // Create button overlay
            overlay = new Element('div', {
                'class': 'kikinIsvOverlay kikinIsvGoogleOverlay'
            }).inject(img.getParent('a'), 'before'),
            button = new Element('div', {
                'class': 'kikinIsvButton'
            }).inject(overlay),
            arrow = new Element('div', {
                'class': 'kikinIsvOverlayArrow'
            }).inject(button);

        var SMALL_THUMB_X = 80,
        	SMALL_THUMB_Y = 60,
        	BORDER_RAD = 2;

        overlay.setStyles({
    		width:img.offsetWidth,
    		height:img.offsetHeight
        });

        button.setStyles({
            marginTop:button.getStyle('marginTop').toInt()+img.offsetHeight-SMALL_THUMB_Y-BORDER_RAD*2,
            marginLeft:button.getStyle('marginLeft').toInt()+img.offsetWidth-SMALL_THUMB_X-BORDER_RAD*2
        });

		var handler = this.onClickVideoThumbnail.bind(this),
			googleLink = overlay.getNext().removeEvents('click').addEvent('click', handler),
			googlePlay = googleLink.getElement('.play_icon');

		$ku.Element.setBrowserClasses(button);

        // Remove google's overlay play button and insert new kikin button
        if (img.getNext()) img.getNext().dispose();
		if (googlePlay) googlePlay.style.background = 'none';

        // Attach event to button for video play
        overlay.addEvent('click', handler);

        this._stats.supported++;
	},

	getVideoUrl: function(img) {
		var imgParentTable = null,
			imgCite = null;

		if(imgParentTable = img.getParent('a')) {
            var url = imgParentTable.href,
                videoUrl = /url\?url=(.*)&rct=/i.exec(url);
            if (videoUrl && videoUrl.length > 1) {
                return decodeURIComponent(videoUrl[1]);
            }
        }

		return null;
	},

	onClickVideoThumbnail: function(e) {
	    e.stop();

	    // create once the video panel that will show the videos
	    if (!this.videoPanel) {
			this.videoPanel = new $kf.insituvideo.InSituVideoPanel({
				document: $win.document
			});
	    }

	    // get some infos
	    var elContainer = $(e.target).getParent('table'),
	        elInfoContainer = elContainer.getElement('td:last-child'),
	        elRating = elInfoContainer.getElement('font'),
	        elTitle = elContainer.getElement('a.l'),
	        elVideoLink = elContainer.getElement('td a'),
	        elVideoImg = elContainer.getElement('td a img'),
	        videoUrl = this.getVideoUrl(elVideoImg),
    		supportedHosts = $kc.FeaturesConfig.plugins.InSituVideoFeature.config.supportedHosts,
			hostConfig = videoUrl ? supportedHosts[$ku.String.getHostName(videoUrl)] : null;

	    // set infos in the right panel
	    this.videoPanel.setInfos({
    		title: elTitle.get('html'),
    		rating: '',
			partnerId: $kf.core.FeaturesDisplayNames.ids.ORGANIC,
			hostName: hostConfig.name,
			url: elTitle.get('href')
	    });

	    // set the player
	    this.videoPanel.setPlayer(
    		new $kf.insituvideo.InSituDefaultPlayer({
				data: $kf.insituvideo.InSituVideoFeature.getSwiffData(elVideoImg.getParent('a')),
				document: $win.document
			})
	    );

    	var imgHeight = elVideoImg.getSize().y || 66;
    	var relElement = $('kikin_top') || $('center_col') || $($win.document.body);
		this.videoPanel.setStyle('left', relElement.getPosition().x);
		this.videoPanel.setStyle('top', elVideoImg.getPosition().y+imgHeight);

	    // show the panel and start playing
	    this.videoPanel.open()
	}*/

});/**
 * @package com.watchlr.hosts.foxsports.adapters
 */
$cwh.adapters.KikinSiteAdapter.extend("com.watchlr.hosts.foxsports.adapters.KikinSiteAdapter", {}, {
	run: function() {
        // We only add KikinVideo adapter if kikin video experiment is set
        try {
            var kva = $cwh.adapters.KikinVideoAdapter.getInstance();
            if (kva) kva.attach();
        } catch(e) {
            alert("From: fox_sports_site_adapter. \nReason: " + e);
            // $kat.trackError({ from: 'fox_sports_site_adapter', exception: e, msg: 'unable to create video adapter'});
        }
	}
});
/**
 * @package com.watchlr.hosts.foxsports.adapters
 */
$cwh.adapters.KikinVideoAdapter.extend("com.watchlr.hosts.foxsports.adapters.KikinVideoAdapter", {}, {

	/* @override */
	attach: function() {
        // this.debug("Hooking into msn.foxsports.com video api");
        try {
            if (window.Player && window.Player.OnVideoTitle) {
                var original = window.Player.OnVideoTitle;
                window.Player.OnVideoTitle = $.proxy(function() {
                    try {
                        if (arguments.length >= 2) {
                            // Original parameters are, text and id
                            this._onVideoUrlChange(arguments[1]);
                            original.apply(this, arguments);
                        }
                    } catch (e) {
                        alert("From: attach of fox sports KikinVideoAdapter. \nReason: " + e);
                        // $kat.trackError({from:"attach of fox sports KikinVideoAdapter", msg: "Unable to call fox sports original Player.OnVideoTitle function", exception:e});
                    }
                }, this);
            }

        } catch (err) {
            alert("From: attach of fox sports KikinVideoAdapter. \nReason: " + err);
            //$kat.trackError({from:"attach of fox sports KikinVideoAdapter", msg: "Unable to wrap Player.OnVideoTitle function", exception:err});
        }

        this.parent();
	},

    _findVideoUrl: function(embed) {
        var src = this._getNodeValue(embed, 'src') || this._getNodeValue(embed, 'data');

        if (src.indexOf('/') == 0) {
            src = this._qualifyURL(src);
        } else if (src.indexOf('http://') == -1) {
            src = this._qualifyURL('/' + src);
        }

        var videoUrl = "";
        // this.debug("Source is:" + src);
        if (src && (src.indexOf('video.s-msn.com') != -1) && embed.vidGetId) {
            videoUrl = "http://msn.foxsports.com/video/?vid=" + embed.vidGetId();
        }

        return videoUrl;
    },

    _onVideoUrlChange : function(videoId) {
        try {
            // this.debug("Video Id found:" + videoId);
            if (this.videos && (this.videos.length == 1)) {
                var embed = $('Player1').get(0);
                var vid = null;
                if (embed.vidGetId) {
                    vid = embed.vidGetId();
                } else {
                    vid = videoId;
                }

                if (vid) {
                    this.videos[0].url = "http://msn.foxsports.com/video/?vid=" + vid;
                    this.videos[0].saved = false;
                    this.videos[0].tracked = false;

                    this._videosFound = this.videos.length;
                    /*$kat.track('VideoAdapterEvt', 'SupportedVideoFound', {
                        campaign: window.location.host
                    });*/

                    new $cws.WatchlrRequests.sendVideosInfoRequest($.proxy(this._onVideosInfoReceived, this), this.videos);
                }
            }
        } catch (err) {
            alert("From: _onVideoUrlChange of fox sports KikinVideoAdapter. \nReason:" + err);
            //$kat.trackError({from:"_onVideoUrlChange of fox sports KikinVideoAdapter", msg: "Unable to change video URL on video change", exception:err});
        }
    }
});/**
 * @package com.watchlr.hosts.orkut.adapters
 */
$cwh.adapters.KikinSiteAdapter.extend("com.watchlr.hosts.orkut.adapters.KikinSiteAdapter", {}, {

	run: function() {
		// our callback function everytime the page changes
		var fn = $.proxy(function() { this.injectIntoCommunityPage.delay(1000, this); }, this);
		
		// check for hash changes
		if ($.browser.msie) window.document.body.onhashchange = fn;
		else if ($.browser.mozilla || $.browser.webkit) window.addEventListener('hashchange', fn, false);
		
		// inject in this page
		fn();
	},
	
	injectIntoCommunityPage: function() {
		// We only add KikinVideo adapter if kikin video experiment is set
        try {
            var kva = $cwh.adapters.KikinVideoAdapter.getInstance();
            if (kva) kva.attach();
        } catch(e) {
            alert("From: orkut_site_adapter.\nReason: " + e);
            // $kat.trackError({ from: 'orkut_site_adapter', exception: e, msg: 'unable to create video adapter'});
        }
	}
			
});
/**
 * @package com.watchlr.hosts.orkut.adapters
 */
$cwh.adapters.KikinVideoAdapter.extend("com.watchlr.hosts.orkut.adapters.KikinVideoAdapter", {}, {

	/* @override */
	attach: function() {
        this._super();
	}
});/**
 * @package com.watchlr.hosts.yahoo.adapters
 */
$cwh.adapters.InSituVideoAdapter.extend("com.watchlr.hosts.yahoo.adapters.InSituVideoAdapter", {}, {
	
	/*attach: function() {
		var stats = $kh.adapters.InSituVideoAdapter.stats.reset();

    	// add needed styles
		$ku.Styles.insert('InSituVideoStyles', $win.document);		
		
		// look the page for video images
        $$('ul.c-thumb.video li').each(function(videoDiv) {
        	// get the host config (fails if not compatible)
        	var hostConfig = this.getHostConfig(videoDiv);
        	if (!hostConfig) {
                stats.notSupported++;
        		return;
        	}
        	
        	// create our little beautiful icon
            var name = hostConfig.name.toString(),
            	imgLink = videoDiv.getElement('.thm'),
                // Create button overlay
                overlay = new Element('div', {
                    'class': 'kikinIsvOverlay kikinIsvGoogleOverlay'
                }).inject(imgLink, 'top'),
                button = new Element('div', {
                    'class': 'kikinIsvButton'
                }).inject(overlay),
                arrow = new Element('div', {
                    'class': 'kikinIsvOverlayArrow'
                }).inject(button);
            
            var SMALL_THUMB_X = 80,
            	SMALL_THUMB_Y = 60,
            	BORDER_RAD = 2;

            overlay.setStyles({
        		width: imgLink.offsetWidth,
        		height: imgLink.offsetHeight
            });

            button.setStyles({
                marginTop:button.getStyle('marginTop').toInt()+imgLink.offsetHeight-SMALL_THUMB_Y-BORDER_RAD*2-1,
                marginLeft:button.getStyle('marginLeft').toInt()+imgLink.offsetWidth-SMALL_THUMB_X-BORDER_RAD*2-3
            });
            $ku.Element.setBrowserClasses(button);

			var handler = this.onClickVideoThumbnail.bind(this);
            
            // Remove bing's overlay play button
			imgLink.getElement('em').empty();

            // Attach event to button for video play
            overlay.addEvent('click', handler);
            
            stats.supported++;
		}, this);
	},
	
	_getVideoUrl: function(videoDiv) {
		// try to get the link
        if(link = videoDiv.getElement('a')) {
        	// get rurl parameter
        	var href = decodeURIComponent(link.get('href')),
        		params = href.parseQueryString(),
        		url = (params && params.rurl) ? params.rurl.replace(/&amp;/g, '&') : null;
        	return url;
        }
        return null;
	},
	
	getHostConfig: function(videoDiv) {
		var link;
		
		// try to get the link
        if(link = videoDiv.getElement('a')) {
        	// is this url supported?
        	var supportedHosts = $kc.FeaturesConfig.plugins.InSituVideoFeature.config.supportedHosts,
        		url = this._getVideoUrl(videoDiv),
        		hostConfig = supportedHosts[$ku.String.getHostName(url)];
        	
            return hostConfig;
		}
        
		return null;
	},

	onClickVideoThumbnail: function(e) {
	    e.stop();
	    
	    // create once the video panel that will show the videos
	    if (!this.videoPanel) {
			this.videoPanel = new $kf.insituvideo.InSituVideoPanel({
				document: $win.document
			});	    
	    }
	    
	    // get some infos
	    var videoDiv = $(e.target).getParent('li'),
	    	imgLink = videoDiv.getElement('.thm'),
	    	img = imgLink.getElement('img'),
	    	titleEle = videoDiv.getElement('a:not(.thm)')
	    	url = this._getVideoUrl(videoDiv),
	        hostConfig = this.getHostConfig(videoDiv);
	    
	    // set infos in the right panel
	    this.videoPanel.setInfos({
    		title: titleEle.get('text'),
    		rating: '',
			partnerId: $kf.core.FeaturesDisplayNames.ids.ORGANIC,
			hostName: hostConfig.name,
			url: url
	    });
	    
	    // set the player
	    this.videoPanel.setPlayer(
    		new $kf.insituvideo.InSituDefaultPlayer({
				data: $kf.insituvideo.InSituVideoFeature.getSwiffData(url),
				document: $win.document
			})
	    );
	    
    	var imgHeight = imgLink.getSize().y || 90;
    	var relElement = $('results') || $($win.document.body);
		this.videoPanel.setStyle('left', relElement.getPosition().x+32);
		this.videoPanel.setStyle('top', imgLink.getPosition().y-6+imgHeight);
	    
	    // show the panel and start playing
	    this.videoPanel.open()
	} */
});
/**
 * @package com.watchlr.hosts.yahoo.adapters
 */
$cwh.adapters.KikinSiteAdapter.extend("com.watchlr.hosts.yahoo.adapters.KikinSiteAdapter", {}, {
	
	run: function() {
		// only for the search pages
		if (window.location.href.match(/^http:\/\/search\.yahoo\.com\/search(.*)/i)) {
			this.injectIntoSearchPage();
		}

        // We only add KikinVideo adapter if kikin video experiment is set
        /*try {
            var kva = $cwh.adapters.KikinVideoAdapter.getInstance();
            if (kva) kva.attach();
        } catch(e) {
            alert("From: yahoo_site_adapter.\nReason: " + e);
            // $kat.trackError({ from: 'yahoo_site_adapter', exception: e, msg: 'unable to create video adapter'});
        } */
	},
	
	injectIntoSearchPage: function() {
    	/*try {
	    	// attach to the videos
	    	// var isva = new $kh.adapters.InSituVideoAdapter();
	    	// if (isva) isva.attach();
	    	
			var kva = $cwh.adapters.KikinVideoAdapter.getInstance();
            if (kva) kva.attach();
	    	
    	} catch(e) {
            alert("From: site_adapter.\nReason: " + e);
			// $kat.trackError({ from: 'site_adapter', exception: e, msg: 'injectiong failed in yahoo'});
    	}   */
	}
			
});
/**
 * @package com.watchlr.hosts.watchlr.adapters
 */
$cwh.adapters.KikinVideoAdapter.extend("com.watchlr.hosts.watchlr.adapters.KikinVideoAdapter", {}, {
	/* @override */
	attach: function() {}
});/**
 * @package com.watchlr.hosts.watchlr.adapters
 */
$cwh.adapters.KikinSiteAdapter.extend("com.watchlr.hosts.watchlr.adapters.KikinSiteAdapter", {}, {
	
	run: function() {
        try {
            var kva = $cwh.adapters.KikinVideoAdapter.getInstance();
            if (kva) kva.attach();
        } catch(e) {
            alert("From: watchlr_site_adapter.\nReason: " + e);
            // $kat.trackError({ from: 'vimeo_site_adapter', exception: e, msg: 'unable to create video adapter'});
        }
	}
});
/**
 * @package com.watchlr.hosts.vimeo.adapters
 */
$cwh.adapters.KikinSiteAdapter.extend("com.watchlr.hosts.vimeo.adapters.KikinSiteAdapter", {}, {
	
	run: function() {
        try {
            var kva = $cwh.adapters.KikinVideoAdapter.getInstance();
            if (kva) kva.attach();
        } catch(e) {
            alert("From: vimeo_site_adapter.\nReason: " + e);
            // $kat.trackError({ from: 'vimeo_site_adapter', exception: e, msg: 'unable to create video adapter'});
        }
	}
});
/**
 * @package com.watchlr.hosts.vimeo.adapters
 */
$cwh.adapters.KikinVideoAdapter.extend("com.watchlr.hosts.vimeo.adapters.KikinVideoAdapter", {}, {

	/* @override */
	attach: function() {
        this._super();
	},

    _findFlashVideos: function(embeds) {
        try {
            this._super(embeds);
            if (this.videos && (this.videos.length == 0)) {
                var div = $('.a').get(0);
                // this.debug('Found div for video:' + div);
                if (div) {
                    var divParent = $(div.parentNode);
                    // this.debug('Found video div parent:' + divParent + " with id:" + divParent.id)
                    if (divParent && divParent.id) {
                        var videoId = /player_([0-9]+)_[0-9]+/i.exec(divParent.id);
                        if (videoId && videoId.length > 1)
                            videoId = videoId[1];
                        // this.debug('Found video ID:' + videoId);
                        if (videoId) {
                            div.kikinVideoId = (this.videos.length + 1);
                            $(div).mouseenter($.proxy(this._onVideoThumbnailMouseOver, this));
                            $(div).mouseleave($.proxy(this._onVideoThumbnailMouseOut, this));
                            var videoUrl = 'http://www.vimeo.com/' + videoId;
                            this._addVideo(div, videoUrl);
                        }
                    }
                }
            }

            if (this.videos.length > this._videosFound) {
                this._videosFound = this.videos.length;
                /*$kat.track('VideoAdapterEvt', 'SupportedVideoFound', {
                    campaign: $win.location.host
                });*/

                new $ks.WatchlrtRequests.sendVideosInfoRequest($.proxy(this._onVideosInfoReceived, this), this.videos);

            }
        } catch (err) {
            alert("From: _findFlashVideos of vimeo's KikinVideoAdapter..\nReqason: " + err);
            // $kat.trackError({from: "_findFlashVideos of vimeo's KikinVideoAdapter.", exception:err});
        }
    },

    _hasClassName: function(target, classname) {
        var classnames = $(target).attr('class');
        if (classnames) {
            var classnamesarray = classnames.split();
            for (var i = 0; i < classnamesarray.length; i++) {
                // this.debug('class names found:' + classnamesarray);
                if (classname == classnamesarray[i].toLowerCase())
                    return true;
            }
        }

        return false;
    },

    _onVideoThumbnailMouseOver: function(e) {
        try {
            var target = $(e.target);
            while (target && !this._hasClassName(target, 'a')) {
                target = $(target.parentNode);
            }

            if (target && target.kikinVideoId) {
                // this.debug("Target's kikin video id:" + target.kikinVideoId);
                var selectedVideo = this.videos[target.kikinVideoId - 1];

                // if selected video is different than the video saved in the object
                // hide the saved object video if it is visible
                if (this.selectedVideo && (this.selectedVideo != selectedVideo)) {
                    // this.kikinVideoBorder.style.visibility = "hidden";
                    $(this.kikinVideoBorder).fadeOut();
                    this.selectedVideo.videoSelected = false;
                    this.selectedVideo.shareButtonSelected = false;
                }

                // set the new selected video
                this.selectedVideo = selectedVideo;

                // calculate the coordinates for video
                selectedVideo.coordinates = this._getVideoCoordinates(target);

                if (selectedVideo.coordinates) {
                    // this.debug("Coordinates for video:" + selectedVideo.coordinates.left + ", " + selectedVideo.coordinates.top + ", " + selectedVideo.coordinates.width + ", " + selectedVideo.coordinates.height);

                    // draw the border around video
                    this._drawKikinBorder(selectedVideo.coordinates.left,
                                          selectedVideo.coordinates.top,
                                          selectedVideo.coordinates.width,
                                          selectedVideo.coordinates.height,
                                          selectedVideo.saved);
                }

                // this.debug("Border around selected video is visible: " + this.kikinVideoBorder.style.visibility);
                selectedVideo.videoSelected = true;
            }
        } catch (err) {
            alert("From: _onVideoThumbnailMouseOver of vimeo's KikinVideoAdapter.\nReason:" + err);
            // $kat.trackError({from: "_onVideoThumbnailMouseOver of vimeo's KikinVideoAdapter.", exception:err});
        }
    },

    _onVideoThumbnailMouseOut: function(e) {
        try {
            var target = $(e.target);
            while (target && !this._hasClassName(target, 'a')) {
                target = $(target.parentNode);
            }

            if (target && target.kikinVideoId) {
                // this.debug("Target's kikin video id:" + target.kikinVideoId);

                // set the selected video property to false
                var selectedVideo = this.videos[target.kikinVideoId - 1];
                selectedVideo.videoSelected = false;

                // hide the border after a second
                setTimeout($.proxy(function() {
                    var selectedVideo = this.selectedVideo;

                    // if mouse is not over the video or share button of the video
                    // hide the video
                    if (!selectedVideo.shareButtonSelected &&
                        !selectedVideo.videoSelected &&
                        !this.selectedVideo.savingVideo &&
                        !this.selectedVideo.likingVideo)
                    {
                        // this.kikinVideoBorder.style.visibility = "hidden";
                        $(this.kikinVideoBorder).fadeOut();
                    }
                }, this), 1000);
            }
        } catch (err) {
            alert("From: _onVideoThumbnailMouseOut of vimeo's KikinVideoAdapter.\nReason:" + err);
            // $kat.trackError({from: "_onVideoThumbnailMouseOut of vimeo's KikinVideoAdapter.", exception:err});
        }
    }
});/**
 * @package com.watchlr.hosts.facebook.adapters
 */
$cwh.adapters.KikinVideoAdapter.extend("com.watchlr.hosts.facebook.adapters.KikinVideoAdapter", {}, {
    videoAnchorTagsLength: 0,

	/* @override */
	attach: function() {
        try {
            this.debug("Get called in Facebook video adapter.");
            if (window.document.body.addEventListener) {
                window.document.body.addEventListener('DOMNodeInserted', $.proxy(this._firePageModifiedEvent, this), false);
            } else {
                // setInterval(this._firePageModifiedEvent.bind(this), 1000);
                window.scroll($.proxy(this._firePageModifiedEvent, this));
                window.document.body.bind("mousewheel", $.proxy(this._firePageModifiedEvent, this));
            }

            this._super();
        } catch (err) {
            // this.debug("Error attaching to scroll events on facebook page. \nReason: " + err);
        }
	},

    _firePageModifiedEvent: function() {
        // this.debug("Page modified event fired.");
        var anchor_tags = $("a.uiVideoThumb");
        // this.debug("Number of video elements found:" + anchor_tags.length);
        // this.debug("Number of video elements already found:" + this.videoAnchorTagsLength);
        if (anchor_tags.length > this.videoAnchorTagsLength) {
            var embeds = this._findFlashVideoCandidates();
            if (embeds) {
                this._findFlashVideos(embeds);
            }
        }
    },

    /**
    * find all the videos on the page
    */
    _findFlashVideoCandidates: function() {
        try {
            var videoAnchors = [];
            var anchor_tags = $("a.uiVideoThumb");
            // this.debug('Found ' + anchor_tags.length + ' anchors');
            this.videoAnchorTagsLength = anchor_tags.length;

            $(anchor_tags).each($.proxy(function(index, elem) {
                if (elem.kikinVideoId != null) {
                    return;
                }

                var videoUrl = "";
                var anchorAjaxify = this._getNodeValue(elem, "ajaxify");
                // this.debug("Matching against: " + anchorAjaxify);

                var re = /ajax\/flash\/expand_inline\.php\?target_div=u[0-9]+_[0-9]+&share_id=([0-9]+)/;
                var result = re.exec(anchorAjaxify);
                if (result) {
                    // this.debug("Found with video id:" + result[1]);
                    videoUrl = "http://www.facebook.com/?video_id=" + result[1];
                } else {
                    re = /ajax\/flash\/expand_inline\.php\?target_div=u[0-9]+_[0-9]+&v=([0-9]+)/;
                    result = re.exec(anchorAjaxify);
                    if (result) {
                        // this.debug("Found with video id:" + result[1]);
                        videoUrl = "http://www.facebook.com/?video_id=" + result[1];
                    }
                }

                // this.debug("Videos object:" + this.videos.length);
                if (videoUrl) {
                    var video = {
                        url                 : videoUrl,
                        mouseover           : null,
                        mouseout            : null,
                        saved               : false,
                        videoSelected       : false,
                        saveButtonSelected  : false,
                        coordinates         : null,
                        parentNode          : $(elem).parent().get(0),
                        tracked             : false,
                        liked               : false,
                        likes               : 0,
                        saves               : 0,
                        id                  : (this.videos.length + 1)
                    };

                    // calculate the videoId
                    var videoId = video.id;
                    var anchorTagParent = $(elem).parent().get(0);

                    anchorTagParent.kikinVideoId = videoId;
                    elem.kikinVideoId = videoId;

                    console.log('AnchorTag kikinVideoId:' + elem.kikinVideoId);

                    var anchorTagChildNodes = $(elem).children() ;
                    if (anchorTagChildNodes && anchorTagChildNodes.length > 0) {
                        for (var j = 0; j < anchorTagChildNodes.length; j++) {
                            $(anchorTagChildNodes[j]).kikinVideoId = videoId;
                        }
                    }

                    $(elem).click($.proxy(this._onVideoImageClicked, this));
                    $(elem).mouseenter($.proxy(this._onVideoThumbnailMouseOver, this));
                    $(elem).mouseleave($.proxy(this._onVideoThumbnailMouseOut, this));

                    this.videos.push(video);
                }
            }, this));

            if (this.videos.length > this._videosFound) {
                    this._videosFound = this.videos.length;
                    /*$kat.track('VideoAdapterEvt', 'SupportedVideoFound', {
                        campaign: $win.location.host
                    });*/

                    new $cws.WatchlrRequests.sendVideosInfoRequest($.proxy(this._onVideosInfoReceived, this), this.videos);
                }

                // this.debug("Number of videos found:" + this.videos.length);

        } catch (err) {
            alert("From: findFlashVideoCandidates of facebook's KikinVideoAdapater. \nReason:" + err);
            // $kat.trackError({from: "findFlashVideoCandidates of facebook's KikinVideoAdapater.", msg: "Unable to find flash videos on facebook page.", exception:err});
        }
    },

    _onVideoImageClicked: function(e) {
        try {
            // hide the existing border, as image is going to be converted into
            // video element.
            $(this.kikinVideoBorder).fadeOut();
            try {
                var parentNode = this.selectedVideo.parentNode;
                if (parentNode.addEventListener) {
                    parentNode.addEventListener('DOMNodeInserted', $.proxy(this._onEmbedTagCreated, this), false);
                } else {
                    setTimeout($.proxy(this._fireOnVideoElementInserted, this), 500);
                }
            } catch (er) {
                alert("OnImageClicked error: " + er);
            }
        } catch (err) {
            alert("From: onVideoImageClicked of facebook's KikinVideoAdapater. \nReason:" + err);
            // $kat.trackError({from: "onVideoImageClicked of facebook's KikinVideoAdapater.", exception:err});
        }
    },

    _fireOnVideoElementInserted: function() {
        try{
            var parentNode = this.selectedVideo.parentNode;
            if ($(parentNode).find('iframe') || $(parentNode).find('object')) {
                this._onEmbedTagCreated();
            } else {
                setTimeout($.proxy(this._fireOnVideoElementInserted, this), 500);
            }
        } catch (err) {
            alert("From: fireOnVideoElementInserted of facebook's KikinVideoAdapater. \nReason:" + err);
            // $kat.trackError({from: "fireOnVideoElementInserted of facebook's KikinVideoAdapater.", msg: "Unable to fire the event.", exception:err});
        }
    },

    _onEmbedTagCreated: function() {
        try {
            this.debug("In onEmbedTagCreated.");
            if (this.selectedVideo) {
                var parentNode = this.selectedVideo.parentNode;
                this.debug("Selected video id is:" + parentNode.kikinVideoId);

                var iframe = $(parentNode).find('iframe');
                if (iframe && iframe.length > 0) {
                    this.debug('Iframe found');
                    iframe = iframe.get(0);
                    this._addMouseEvents(iframe);
                    iframe.kikinVideoId = parentNode.kikinVideoId;
                    this.selectedVideo.mouseover = iframe.onmouseover;
                    this.selectedVideo.mouseoout = iframe.onmouseout;
                    return;
                }

                var object = $(parentNode).find('object');
                if (object && object.length > 0) {
                    this.debug('Object found');
                    object = object.get(0);
                    this._addMouseEvents(object);
                    object.kikinVideoId = parentNode.kikinVideoId;
                    this.selectedVideo.mouseover = object.onmouseover;
                    this.selectedVideo.mouseoout = object.onmouseout;
                    return;
                }

                var embed = $(parentNode).find('embed');
                if (embed && embed.length > 0) {
                    this.debug('Embed found');
                    embed = embed.get(0);
                    this._addMouseEvents(embed);
                    embed.kikinVideoId = parentNode.kikinVideoId;
                    this.selectedVideo.mouseover = embed.onmouseover;
                    this.selectedVideo.mouseoout = embed.onmouseout;
                }
            }
        } catch (err) {
            alert("From: onEmbedTagCreated of facebook's KikinVideoAdapater. \nReason:" + err);
            // $kat.trackError({from: "onEmbedTagCreated of facebook's KikinVideoAdapater.", exception:err});
        }
    },

    /**
     * retrieves the coordinates for the video
     * @param embed
     */
    _getVideoCoordinates: function(embed) {
        try {
            var videoWidth = embed.clientWidth || embed.width;
            if (!videoWidth) {
                videoWidth = this._getNodeValue(embed, 'width');
            }

            var videoHeight = embed.clientHeight || embed.height;
            if (!videoHeight) {
                videoHeight = this._getNodeValue(embed, 'height');
            }

            var parent = embed.offsetParent;
            var offsetLeft = embed.offsetLeft;
            var offsetTop = embed.offsetTop;

            while (parent && parent != window.document.body) {
                offsetLeft += parent.offsetLeft;
                offsetTop += parent.offsetTop;

                if ("UIImageBlock clearfix" == $(parent).attr('class')) {
                    try {
                        var profileImage = $(parent).find("a.actorPhoto");
                        if (profileImage && profileImage.length == 1) {
                            offsetLeft += $($(profileImage).get(0)).clientWidth + parseInt($(profileImage).get(0)).css('margin-right');
                        } else {
                            // this.debug("Cannot find the profile picture");
                        }
                    } catch (e) {
                        // this.debug(e);
                    }
                }
                parent = parent.offsetParent;
            }

            var coordinates = {
                left    : offsetLeft,
                top     : offsetTop,
                width   : videoWidth,
                height  : videoHeight
            };

            return coordinates;
        } catch (err) {
            alert("From: getVideoCoordinates of facebook's KikinVideoAdapater. \nReason:" + err);
            //$kat.trackError({from: "getVideoCoordinates of facebook's KikinVideoAdapater.", exception:err});
        }

        return null
    },

    _onVideoThumbnailMouseOver : function(e) {
        // this.debug('Anchor tag parent mouse over');
        try {
            var target = e.target;
            if (target) {
                // this.debug('Target node type:' + e.target.nodeName.toLowerCase());

                while (target && target.nodeName.toLowerCase() != 'div') {
                    target = target.parentNode;
                    //this.debug('Target node type:' + target.nodeName.toLowerCase());
                }

                // this.debug("Target's kikin video id:" + target.kikinVideoId);
                if (target && target.kikinVideoId) {
                    var selectedVideo = this.videos[target.kikinVideoId - 1];

                    // if selected video is different than the video saved in the object
                    // hide the saved object video if it is visible
                    if (this.selectedVideo && (this.selectedVideo != selectedVideo)) {
                        $(this.kikinVideoBorder).fadeOut();
                        this.selectedVideo.videoSelected = false;
                        this.selectedVideo.shareButtonSelected = false;
                    }

                    // set the new selected video
                    this.selectedVideo = selectedVideo;

                    // calculate the coordinates for video
                    selectedVideo.coordinates = this._getVideoCoordinates(target);

                    if (selectedVideo.coordinates) {
                        // this.debug("Coordinates for video:" + selectedVideo.coordinates.left + ", " + selectedVideo.coordinates.top + ", " + selectedVideo.coordinates.width + ", " + selectedVideo.coordinates.height);

                        // draw the border around video
                        this._drawKikinBorder(selectedVideo.coordinates.left,
                                              selectedVideo.coordinates.top,
                                              selectedVideo.coordinates.width,
                                              selectedVideo.coordinates.height,
                                              selectedVideo.saved);
                    }

                    // this.debug("Border around selected video is visible: " + $(this.kikinVideoBorder).css('visibility'));
                    selectedVideo.videoSelected = true;
                }
            }
        } catch (err) {
            alert("From: _onVideoThumbnailMouseOver of facebook's KikinVideoAdapter. \nReason:" + err);
            // $kat.trackError({from: "_onVideoThumbnailMouseOver of facebook's KikinVideoAdapter", exception:err});
        }
    },

    _onVideoThumbnailMouseOut : function(e) {
        // this.debug('Anchor tag parent mouse out');
        try {
            var target = e.target;
            if (target) {
                // this.debug('Target node type:' + target.nodeName.toLowerCase());
                while (target && target.nodeName.toLowerCase() != 'div') {
                    target = target.parentNode;
                    // this.debug('Target node type:' + target.nodeName.toLowerCase());
                }

                if (target && target.kikinVideoId) {
                    // set the selected video property to false
                    var selectedVideo = this.videos[target.kikinVideoId - 1];
                    selectedVideo.videoSelected = false;

                    // hide the border after a second
                    setTimeout($.proxy(function() {
                        var selectedVideo = this.selectedVideo;

                        // if mouse is not over the video or share button of the video
                        // hide the video
                        if (!selectedVideo.shareButtonSelected &&
                            !selectedVideo.videoSelected &&
                            !this.selectedVideo.savingVideo &&
                            !this.selectedVideo.likingVideo)
                        {
                            $(this.kikinVideoBorder).fadeOut();
                        }
                    }, this), 1000);
                }
            }
        } catch (err) {
            alert("From: _onVideoThumbnailMouseOut of facebook's KikinVideoAdapter. \nReason:" + err);
            //$kat.trackError({from: "_onVideoThumbnailMouseOut of facebook's KikinVideoAdapter", exception:err});
        }
    }
});
/**
 * @package com.watchlr.system.runtime
 * @author kapil.goel@kikin.com
 */

$.Class.extend('com.watchlr.system.runtime.Bootstrap', {}, {

	run: function() {
        // Load services configuration data
        // $cws.config = new $cws.Config($cwc.SystemConfig);
		// $cws.runtime.config = new $cws.Config($kc.RuntimeConfig);

        $cwss = $cws.services = new $cws.ServiceDaemon();
        $cws.controllers = {};
        $cws.controllers.HostController = new com.watchlr.hosts.HostController();

        //BarUtil always sets the layout to No for ytonly
		// $ks.controllers.LayoutController = new $kui.LayoutController;
		// $ks.controllers.ErrorController = new com.kikin.error.ErrorController();

		// if ($ku.Kikin.isKikinHttpRequestSupported()) {
		// 	setKikinPluginRequests();
		// }

    	try {
	    	var ksa = $cwh.adapters.KikinSiteAdapter.getInstance();
            if (ksa)
                ksa.run();
    	} catch(e) {
            alert("from: bootstrap. \nReason:" + e);
    		// $cwat.trackError({ from: 'bootstrap', exception: e, msg: 'KikinSiteAdapter failed'});
    	}
    }

});
com.watchlr.system.css = {};
com.watchlr.system.css['AlertWindowStyles']='a {color: #2AACE1;text-decoration: none;    cursor: pointer;}a:hover {    text-decoration: underline;}#watchlr-alert-window .watchlr-logo {    background:url(\'http://www.watchlr.com/static/images/watchlr.png\') no-repeat scroll 0px 0px transparent;    width: 90px;    height: 50px;    position: absolute;    margin: 5px;    left : 0px;    top: 0px;    display: block;}#watchlr-alert-window .closeButton {    background:url(\'http://www.watchlr.com/static/images/close.png\') no-repeat scroll 0px 0px transparent;    width: 18px;    height: 19px;    display: block;    margin-top: 10px;    float: right;}#watchlr-alert-window .details {    overflow: hidden;    position: absolute;    left: 0px;    top: 25px;    width : 290px;    height: 60px;    padding: 5px;    text-align: left;    margin: 15px 10px;}#watchlr-alert-window .title {    position: absolute;    left: 0px;    top: 0px;    width : 290px;    height: 30px;    font-size: 16px;}#watchlr-alert-window .description {    overflow: hidden;    position: absolute;    left: 0px;    top: 30px;    width : 290px;    height: 30px;}#watchlr-alert-window .okButton {    background:url(\'http://www.watchlr.com/static/images/okay_button.png\') no-repeat scroll 0px 0px transparent;    width: 47px;    height: 21px;    display: block;    top: 98px;    left: 245px;    position: absolute;}';
com.watchlr.system.css['FacebookConnectWindowStyles']='a {color: #2AACE1;text-decoration: none;    cursor: pointer;}a:hover {    text-decoration: underline;}#facebook-connect-window .watclr-logo {    background:url(\'http://www.watchlr.com/static/images/watchlr.png\') no-repeat scroll 0px 0px transparent;    width: 90px;    height: 50px;    position: absolute;    margin: 5px;    left : 0px;    top: 0px;    display: block;}#facebook-connect-window .closeButton {    background:url(\'http://www.watchlr.com/static/images/close.png\') no-repeat scroll 0px 0px transparent;    width: 18px;    height: 19px;    display: block;    margin-top: 10px;    float: right;}#facebook-connect-window .watchlr-fb-connect {    background:url(\'http://www.watchlr.com/static/images/fb_wtch_button.png\') no-repeat scroll 0px 0px transparent;    width: 171px;    height: 67px;    position: absolute;    display: block;    margin: 5px;    left: 90px;    top: 40px;}#facebook-connect-window .details {    overflow: hidden;    position: absolute;    left: 0px;    top: 120px;    width : 345px;    height: 60px;    padding: 0px 0px 5px 5px;}#facebook-connect-window .details .fb-sign-in-msg {    left: 175px;    font-size: 13px;    position: absolute;}#facebook-connect-window .details #facebook-sign-in {    left: 50px;    font-size: 13px;    position: absolute;}#facebook-connect-window .details .watch-later-msg {    text-align: left;    font-size: 13px;}';
com.watchlr.system.css['FirstVideoLikedWindowStyles']='a {color: #2AACE1;text-decoration: none;    cursor: pointer;}a:hover {    text-decoration: underline;}#video-liked-window {}#video-liked-window .header {    width: 100%;    height: 60px;    position: absolute;    left: 0px;    top: 0px;}#video-liked-window .watchlr-logo {    background:url(\'http://www.watchlr.com/static/images/watchlr.png\') no-repeat scroll 0px 0px transparent;    width: 90px;    height: 31px;    margin: 5px;    display: block;}#video-liked-window .close-button {    background:url(\'http://www.watchlr.com/static/images/close.png\') no-repeat scroll 0px 0px transparent;    width: 18px;    height: 19px;    display: block;    margin-top: 10px;}#video-liked-window .message {    overflow: hidden;    padding: 5px;}#video-liked-window .video-liked-img {    background:url(\'http://www.watchlr.com/static/images/heart_fb.png\') no-repeat scroll 0px 0px transparent;    width: 150px;    height: 45px;    display: block;    margin: 5px;    position: absolute;    left: 90px;    top: 55px;}#video-liked-window .video-liked-msg {    width : 245px;    height: 35px;    text-align: center;    font-size: 16px;    position: absolute;    top: 105px;    left: 47px;}#video-liked-window .footer {    left: 0px;    top: 180px;    width : 100%;    height: 30px;    position: absolute;}#video-liked-window .footer-left {    margin-top: 5px;}#fb-push-message {    position:relative;    top:-2px;    margin-left:3px;    margin-right: 2px;}#video-liked-window .fb-show-message-label {    position:relative;    top:-2px;    font-size: 13px;}#video-liked-window .left {    float: left;}#video-liked-window .right {    float: right;}#video-liked-window .ok-button {    background:url(\'http://www.watchlr.com/static/images/okay_button.png\') no-repeat scroll 0px 0px transparent;    width: 47px;    height: 21px;    display: block;    margin: 0 5px 0 0;}';
com.watchlr.system.css['VideoBorderStyles']='a {cursor: pointer;}a:hover {    text-decoration: underline;}#watchlr-video-border {    outline: none;    display: none;}#watchlr-video-border .video-border {    position : absolute;    background-color: #AAEB6E;    z-index: 1000000}#watchlr-video-border .video-top-border {    border-top-left-radius: 7px;    border-top-right-radius: 7px;    -moz-border-radius-topleft: 7px;    -moz-border-radius-topright: 7px;}#watchlr-video-border .video-bottom-border {    border-bottom-left-radius: 7px;    -moz-border-radius-bottomleft: 7px;}#watchlr-video-border .video-options-button {    border-bottom-right-radius: 7px;    border-bottom-left-radius: 7px;    -moz-border-radius-bottomleft: 7px;    -moz-border-radius-bottomright: 7px;    padding: 0px 11px 0px 12px;    text-align: center;    width: 375px;    height: 40px;}#watchlr-video-border .watchlr-text {    font-family: \'PT Sans\';    font-size: 18px;    font-style: normal;    font-weight: 600;    font-variant: normal;    display: inline;    color: #ffffff;    margin: 0px 5px;    position: relative;    top: 3px;}#watchlr-video-border .watchlr-image {    vertical-align: text-bottom;    display: inline-block;    position: relative;    top: 4px;}#watchlr-video-border .watchlr-logo-image {    background-image : url(\'http://www.watchlr.com/static/images/logo_normal.png\');    height: 23px;    width: 75px;}#watchlr-video-border .watchlr-logo-hover-image {    background-image : url(\'http://www.watchlr.com/static/images/logo_hover.png\');    height: 23px;    width: 75px;}#watchlr-video-border .unlike-button-image {    background-image : url(\'http://www.watchlr.com/static/images/heart_normal.png\');    height: 21px;    width: 24px;}#watchlr-video-border .unlike-button-hover-image {    background-image : url(\'http://www.watchlr.com/static/images/heart_hover1.png\');    height: 21px;    width: 23px;}#watchlr-video-border .like-button-image {    background-image : url(\'http://www.watchlr.com/static/images/heart_normal2.png\');    height: 21px;    width: 24px;}#watchlr-video-border .like-button-hover-image {    background-image : url(\'http://www.watchlr.com/static/images/heart_broken_hover.png\');    height: 21px;    width: 24px;}#watchlr-video-border .watch-later-button-image {    background-image : url(\'http://www.watchlr.com/static/images/plus_normal.png\');    height: 21px;    width: 21px;}#watchlr-video-border .watch-later-button-hover-image {    background-image : url(\'http://www.watchlr.com/static/images/plus_hover.png\');    height: 21px;    width: 21px;}#watchlr-video-border .saved-button-image {    background-image : url(\'http://www.watchlr.com/static/images/check_hover.png\');    height: 21px;    width: 24px;}#watchlr-video-border .saved-button-hover-image {    background-image : url(\'http://www.watchlr.com/static/images/check_click.png\');    height: 21px;    width: 24px;}#watchlr-video-border .spinner-image {    background-image : url(\'http://www.watchlr.com/static/images/ajax-loader.gif\');    height: 16px;    width: 16px;}#watchlr-video-border .slash {    background-image : url(\'http://www.watchlr.com/static/images/slash.png\');    height: 41px;    width: 26px;    vertical-align: middle;    display: inline-block;}#like-btn-text {    width: 100px;}#watch-later-btn-text {    width: 100px;}';
com.watchlr.system.css['VideoSavedWindowStyles']='a {color: #2AACE1;text-decoration: none;    cursor: pointer;}a:hover {    text-decoration: underline;}#video-saved-window {font-size: 13px;}#video-saved-window .header {    width: 100%;    height: 60px;    position: absolute;    left: 0px;    top: 0px;}#video-saved-window .watchlr-logo {    background:url(\'http://www.watchlr.com/static/images/watchlr.png\') no-repeat scroll 0px 0px transparent;    width: 90px;    height: 31px;    margin: 5px;    display: block;}#video-saved-window .close-button {    background:url(\'http://www.watchlr.com/static/images/close.png\') no-repeat scroll 0px 0px transparent;    width: 18px;    height: 19px;    display: block;    margin-top: 10px;}#video-saved-window .message {    overflow: hidden;    padding: 5px;}#video-saved-window .video-saved {    width: 100%;    height: 65px;    position: absolute;    left: 0px;    top: 45px;}#video-saved-window .video-saved-button {    background:url(\'http://www.watchlr.com/static/images/video_saved.png\') no-repeat scroll 0px 0px transparent;    width: 45px;    height: 60px;    display: block;    margin: 5px 5px 5px 50px;}#video-saved-window .video-saved-message {    width : 225px;    height: 50px;    text-align: left;    color: #50CCFF;    font-size: 20px;}#video-saved-window .message-separator {    border-bottom: 1px solid #DDDDDD;    margin: 10px 20px;    position: absolute;    left: 0px;    top: 105px;    width: 315px;}#video-saved-window .watch-later-message {    height: 40px;    text-align: left;    font-size: 13px;    position: absolute;    left: 0px;    top: 123px;}#video-saved-window .footer {    left: 0px;    top: 180px;    width : 100%;    height: 30px;    position: absolute;}#video-saved-window .footer-left {    margin-top: 5px;}#show-message {    position:relative;    top:-5px;    margin-left:3px;    margin-right: 2px;}#video-saved-window .show-message-label {    position:relative;    top:-5px;}#video-saved-window .left {    float: left;}#video-saved-window .right {    float: right;}#video-saved-window .ok-button {    background:url(\'http://www.watchlr.com/static/images/okay_button.png\') no-repeat scroll 0px 0px transparent;    width: 47px;    height: 21px;    display: block;    margin: 0 5px 0 0;}';
com.watchlr.system.css['WatchlrIframeWindowStyles']='html { padding: 0px; margin: 0px; border:none; outline:none; height: 100%; background: transparent; }body { padding: 0px; margin: 0px; border:none; outline:none; height: 100%; background: transparent; font-style: normal; font-family:\'PT Sans\'; font-size:12px;}body * { padding: 0px; margin: 0px; outline:none; }.popup-flash-alert { position:relative; width:100%; height: 100%; background: transparent; }.popup-flash-alert > .background { position: absolute; top: 20px; left: 27px; right: 27px; bottom: 30px; background:#FFF;}.popup-flash-alert > .top-left { background:#FFF; width:27px; height:20px; position:absolute; top:0; left:0; font-size:0; border-top-left-radius:7px; border-color:#0C536F; border-width:2px 0 0 2px; border-style:solid; }.popup-flash-alert > .top-right { background:#FFF; width:27px; height:20px; position:absolute; top:0; right:0; font-size:0; border-top-right-radius:7px; border-color:#0C536F; border-width:2px 2px 0 0; border-style:solid; }.popup-flash-alert > .top { background:#FFF; height:20px; position:absolute; left:27px; right:27px; top:0; font-size:0; border-color:#0C536F; border-width:2px 0 0 0; border-style:solid; }.popup-flash-alert > .left {  background:#FFF; width:27px; position:absolute; left:0; top:20px; bottom:30px; font-size:0; border-color:#0C536F; border-width:0 0 0 2px; border-style:solid; }.popup-flash-alert > .right { background:#FFF; width:27px; position:absolute; right:0; top:20px; bottom:30px; font-size:0; border-color:#0C536F; border-width:0 2px 0 0; border-style:solid; }.popup-flash-alert > .bottom-left { background:#FFF; width:27px; height:30px; position:absolute; bottom:0; left:0; font-size:0; border-bottom-left-radius:7px; border-color:#0C536F; border-width:0 0 2px 2px; border-style:solid; }.popup-flash-alert > .bottom-right { background:#FFF; width:27px; height:30px; position:absolute; bottom:0; right:0; font-size:0; border-bottom-right-radius:7px; border-color:#0C536F; border-width:0 2px 2px 0; border-style:solid; }.popup-flash-alert > .bottom { background:#FFF; height:30px; position:absolute; left:27px; right:27px; bottom:0; font-size:0; border-color:#0C536F; border-width:0 0 2px 0; border-style:solid; }.popup-flash-alert > .middle { position: absolute; left:10px; top: 5px; bottom: 15px; right: 10px; overflow: hidden; }.popup-flash-alert > .middle > .inner { height: 100%; width: 100%; position: relative; }';

com.watchlr.system.html = {};
com.watchlr.system.html['AlertWindow']='<div class="watchlr-logo"></div><a class="closeButton" onclick="return false;"></a><div class="details">    <span class=title></span>    <br/><br/>    <span class=description></span></div><a class="okButton" onclick="return false;"></a>';
com.watchlr.system.html['FacebookConnectWindow']='<div class="watclr-logo"></div><a class="closeButton" onclick="return false;"></a><a class="watchlr-fb-connect" onclick="return false;"></a><div class="details">    <a id="facebook-sign-in">Sign in with Facebook</a>    <span class="fb-sign-in-msg">to save or like videos.</span>    <br/><br/>    <span class=\'watch-later-msg\'>Watch this video later at</span>    <a id="video-page" class=\'watch-later-msg\'>watchlr.com</a>    <span class=\'watch-later-msg\'>or on your mobile device.</span></div>';
com.watchlr.system.html['FirstVideoLikedWindow']='<div class="header"><div class="watchlr-logo left"></div><a class="close-button right" onclick="return false;"></a></div><div class = "video-liked-img"></div><div class="message video-liked-msg">    <span>When you like a video, it\'s added to</span>    <a id="user-profile">your profile</a>    <span>so others can discover it.</span></div><div class="footer"><div class="left footer-left">    <input id="fb-push-message" type="checkbox">    <label for="fb-push-message" class="fb-show-message-label">Automatically update facebook when I like videos.</label>  </div><a class="right ok-button" onclick="return false;"></a></div>';
com.watchlr.system.html['VideoBorder']='<div id="watchlr-video-border">    <div id="top-border" class="video-border video-top-border"></div>    <div id="bottom-border" class="video-border video-bottom-border"></div>    <div id="left-border" class="video-border"></div>    <div id="right-border" class="video-border"></div>    <div id="options-button" class="video-border video-options-button">        <a id="watchlr-logo" class="watchlr-image watchlr-logo-image"></a>        <div class="slash"></div>        <a id="like-btn-img" class="watchlr-image unlike-button-image"></a>        <div id="like-btn-text" class="watchlr-text unlike-button-text"></div>        <div class="slash"></div>        <a id="watch-later-btn-img" class="watchlr-image watch-later-button-image"></a>        <div id="watch-later-btn-text" class="watchlr-text watch-later-button-text"></div>    </div></div>';
com.watchlr.system.html['VideoSavedWindow']='<div class="header"><div class="watchlr-logo left"></div><a class="close-button right" onclick="return false;"></a></div><div class="video-saved"><div class="video-saved-button left"></div><div class="message video-saved-message right">    <div>Woohoo!!!</div>    <div>You saved a video!</div></div></div><div class="message-separator"></div><div class="message watch-later-message"> This video, and all the videos you save, are added to your Video Queue on <a id="video-page">watchlr.com</a>.</div><div class="footer"><div class="left footer-left">    <input id="show-message" type="checkbox">     <label for="show-message" class="show-message-label">Do not show this message again.</label>  </div><a class="right ok-button" onclick="return false;"></a></div>';
com.watchlr.system.html['WatchlrIframeWindow']='<div class="popup-flash-alert"><div class="background"></div><div class="top-left png">&nbsp;</div><div class="top">&nbsp;</div><div class="top-right png">&nbsp;</div><div class="left">&nbsp;</div><div class="right">&nbsp;</div><div class="bottom-left png">&nbsp;</div><div class="bottom">&nbsp;</div><div class="bottom-right png">&nbsp;</div><div class="middle"><div class="inner"><div class="content"></div></div></div></div>';
var bootstrap = new com.watchlr.system.runtime.Bootstrap(); bootstrap.run();})();